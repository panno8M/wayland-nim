# Generated by wayland-nim-scanner 1.23.1
{.warning[UnusedImport]:off.}
import wayland/native/client_core
import wayland/native/common
import code
export code

## The wayland CLIENT protocol
## ###########################
## 
## Interfaces
## ==========
## 
## * wl_display
## * wl_registry
## * wl_callback
## * wl_compositor
## * wl_shm_pool
## * wl_shm
## * wl_buffer
## * wl_data_offer
## * wl_data_source
## * wl_data_device
## * wl_data_device_manager
## * wl_shell
## * wl_shell_surface
## * wl_surface
## * wl_seat
## * wl_pointer
## * wl_keyboard
## * wl_touch
## * wl_output
## * wl_region
## * wl_subcompositor
## * wl_subsurface
## 
## Copyright
## =========
## 
## Copyright © 2008-2011 Kristian Høgsberg
## Copyright © 2010-2011 Intel Corporation
## Copyright © 2012-2013 Collabora, Ltd.
## 
## Permission is hereby granted, free of charge, to any person
## obtaining a copy of this software and associated documentation files
## (the "Software"), to deal in the Software without restriction,
## including without limitation the rights to use, copy, modify, merge,
## publish, distribute, sublicense, and/or sell copies of the Software,
## and to permit persons to whom the Software is furnished to do so,
## subject to the following conditions:
## 
## The above copyright notice and this permission notice (including the
## next paragraph) shall be included in all copies or substantial
## portions of the Software.
## 
## THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
## EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
## MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
## NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
## BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
## ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
## CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
## SOFTWARE.
## 

type DisplayListener* = object
  error*: proc(
    data: pointer;
    display: ptr Display;
    objectId: pointer;
    code: uint32;
    message: cstring;
  ) {.nimcall.}
  deleteId*: proc(
    data: pointer;
    display: ptr Display;
    id: uint32;
  ) {.nimcall.}
proc addListener*(display: ptr Display; listener: ptr DisplayListener; data: pointer): int {.inline.} =
  cast[ptr Proxy](display).add_listener(listener, data)

proc setUserData*(display: ptr Display; userData: pointer) {.inline.} =
  cast[ptr Proxy](display).set_user_data(user_data)
proc getUserData*(display: ptr Display): pointer {.inline.} =
  cast[ptr Proxy](display).get_user_data()
proc getVersion*(display: ptr Display): uint32 {.inline.} =
  cast[ptr Proxy](display).get_version()
proc sync*(display: ptr Display): ptr Callback {.inline.} =
  ## asynchronous roundtrip
  ## 
  ## The sync request asks the server to emit the 'done' event
  ## 	on the returned wl_callback object.  Since requests are
  ## 	handled in-order and events are delivered in-order, this can
  ## 	be used as a barrier to ensure all previous requests and the
  ## 	resulting events have been handled.
  ## 
  ## 	The object returned by this request will be destroyed by the
  ## 	compositor after the callback is fired and as such the client must not
  ## 	attempt to use it after that point.
  ## 
  ## 	The callback_data passed in the callback is undefined and should be ignored.
  ## 
  cast[ptr Callback](cast[ptr Proxy](display).marshal_flags(DisplayRequest_sync.ord, addr wl_callback_interface, cast[ptr Proxy](display).get_version(), 0, nil))
proc getRegistry*(display: ptr Display): ptr Registry {.inline.} =
  ## get global registry object
  ## 
  ## This request creates a registry object that allows the client
  ## 	to list and bind the global objects available from the
  ## 	compositor.
  ## 
  ## 	It should be noted that the server side resources consumed in
  ## 	response to a get_registry request can only be released when the
  ## 	client disconnects, not when the client side proxy is destroyed.
  ## 	Therefore, clients should invoke get_registry as infrequently as
  ## 	possible to avoid wasting memory.
  ## 
  cast[ptr Registry](cast[ptr Proxy](display).marshal_flags(DisplayRequest_get_registry.ord, addr wl_registry_interface, cast[ptr Proxy](display).get_version(), 0, nil))
type RegistryListener* = object
  global*: proc(
    data: pointer;
    registry: ptr Registry;
    name: uint32;
    `interface`: cstring;
    version: uint32;
  ) {.nimcall.}
  globalRemove*: proc(
    data: pointer;
    registry: ptr Registry;
    name: uint32;
  ) {.nimcall.}
proc addListener*(registry: ptr Registry; listener: ptr RegistryListener; data: pointer): int {.inline.} =
  cast[ptr Proxy](registry).add_listener(listener, data)

proc setUserData*(registry: ptr Registry; userData: pointer) {.inline.} =
  cast[ptr Proxy](registry).set_user_data(user_data)
proc getUserData*(registry: ptr Registry): pointer {.inline.} =
  cast[ptr Proxy](registry).get_user_data()
proc getVersion*(registry: ptr Registry): uint32 {.inline.} =
  cast[ptr Proxy](registry).get_version()
proc destroy*(registry: ptr Registry) {.inline.} =
  destroy cast[ptr Proxy](registry)
proc `bind`*(registry: ptr Registry; name: uint32; `interface`: ptr Interface; version: uint32): pointer {.inline.} =
  ## bind an object to the display
  ## 
  ## Binds a new, client-created object to the server using the
  ## 	specified name as the identifier.
  ## 
  cast[ptr Proxy](registry).marshal_flags(RegistryRequest_bind.ord, `interface`, version, 0, name, `interface`.name, version, nil)
type CallbackListener* = object
  done*: proc(
    data: pointer;
    callback: ptr Callback;
    callbackData: uint32;
  ) {.nimcall.}
proc addListener*(callback: ptr Callback; listener: ptr CallbackListener; data: pointer): int {.inline.} =
  cast[ptr Proxy](callback).add_listener(listener, data)

proc setUserData*(callback: ptr Callback; userData: pointer) {.inline.} =
  cast[ptr Proxy](callback).set_user_data(user_data)
proc getUserData*(callback: ptr Callback): pointer {.inline.} =
  cast[ptr Proxy](callback).get_user_data()
proc getVersion*(callback: ptr Callback): uint32 {.inline.} =
  cast[ptr Proxy](callback).get_version()
proc destroy*(callback: ptr Callback) {.inline.} =
  destroy cast[ptr Proxy](callback)
proc setUserData*(compositor: ptr Compositor; userData: pointer) {.inline.} =
  cast[ptr Proxy](compositor).set_user_data(user_data)
proc getUserData*(compositor: ptr Compositor): pointer {.inline.} =
  cast[ptr Proxy](compositor).get_user_data()
proc getVersion*(compositor: ptr Compositor): uint32 {.inline.} =
  cast[ptr Proxy](compositor).get_version()
proc destroy*(compositor: ptr Compositor) {.inline.} =
  destroy cast[ptr Proxy](compositor)
proc createSurface*(compositor: ptr Compositor): ptr Surface {.inline.} =
  ## create new surface
  ## 
  ## Ask the compositor to create a new surface.
  ## 
  cast[ptr Surface](cast[ptr Proxy](compositor).marshal_flags(CompositorRequest_create_surface.ord, addr wl_surface_interface, cast[ptr Proxy](compositor).get_version(), 0, nil))
proc createRegion*(compositor: ptr Compositor): ptr Region {.inline.} =
  ## create new region
  ## 
  ## Ask the compositor to create a new region.
  ## 
  cast[ptr Region](cast[ptr Proxy](compositor).marshal_flags(CompositorRequest_create_region.ord, addr wl_region_interface, cast[ptr Proxy](compositor).get_version(), 0, nil))
proc setUserData*(shmPool: ptr ShmPool; userData: pointer) {.inline.} =
  cast[ptr Proxy](shmPool).set_user_data(user_data)
proc getUserData*(shmPool: ptr ShmPool): pointer {.inline.} =
  cast[ptr Proxy](shmPool).get_user_data()
proc getVersion*(shmPool: ptr ShmPool): uint32 {.inline.} =
  cast[ptr Proxy](shmPool).get_version()
proc createBuffer*(shmPool: ptr ShmPool; offset: int32; width: int32; height: int32; stride: int32; format: uint32): ptr Buffer {.inline.} =
  ## create a buffer from the pool
  ## 
  ## Create a wl_buffer object from the pool.
  ## 
  ## 	The buffer is created offset bytes into the pool and has
  ## 	width and height as specified.  The stride argument specifies
  ## 	the number of bytes from the beginning of one row to the beginning
  ## 	of the next.  The format is the pixel format of the buffer and
  ## 	must be one of those advertised through the wl_shm.format event.
  ## 
  ## 	A buffer will keep a reference to the pool it was created from
  ## 	so it is valid to destroy the pool immediately after creating
  ## 	a buffer from it.
  ## 
  cast[ptr Buffer](cast[ptr Proxy](shmPool).marshal_flags(ShmPoolRequest_create_buffer.ord, addr wl_buffer_interface, cast[ptr Proxy](shmPool).get_version(), 0, nil, offset, width, height, stride, format))
proc destroy*(shmPool: ptr ShmPool) {.inline.} =
  ## destroy the pool
  ## 
  ## Destroy the shared memory pool.
  ## 
  ## 	The mmapped memory will be released when all
  ## 	buffers that have been created from this pool
  ## 	are gone.
  ## 
  cast[ptr Proxy](shmPool).marshal_flags(ShmPoolRequest_destroy.ord, nil, cast[ptr Proxy](shmPool).get_version(), WL_MARSHAL_FLAG_DESTROY)
proc resize*(shmPool: ptr ShmPool; size: int32) {.inline.} =
  ## change the size of the pool mapping
  ## 
  ## This request will cause the server to remap the backing memory
  ## 	for the pool from the file descriptor passed when the pool was
  ## 	created, but using the new size.  This request can only be
  ## 	used to make the pool bigger.
  ## 
  ## 	This request only changes the amount of bytes that are mmapped
  ## 	by the server and does not touch the file corresponding to the
  ## 	file descriptor passed at creation time. It is the client's
  ## 	responsibility to ensure that the file is at least as big as
  ## 	the new pool size.
  ## 
  cast[ptr Proxy](shmPool).marshal_flags(ShmPoolRequest_resize.ord, nil, cast[ptr Proxy](shmPool).get_version(), 0, size)
type ShmListener* = object
  format*: proc(
    data: pointer;
    shm: ptr Shm;
    format: uint32;
  ) {.nimcall.}
proc addListener*(shm: ptr Shm; listener: ptr ShmListener; data: pointer): int {.inline.} =
  cast[ptr Proxy](shm).add_listener(listener, data)

proc setUserData*(shm: ptr Shm; userData: pointer) {.inline.} =
  cast[ptr Proxy](shm).set_user_data(user_data)
proc getUserData*(shm: ptr Shm): pointer {.inline.} =
  cast[ptr Proxy](shm).get_user_data()
proc getVersion*(shm: ptr Shm): uint32 {.inline.} =
  cast[ptr Proxy](shm).get_version()
proc destroy*(shm: ptr Shm) {.inline.} =
  destroy cast[ptr Proxy](shm)
proc createPool*(shm: ptr Shm; fd: int32; size: int32): ptr ShmPool {.inline.} =
  ## create a shm pool
  ## 
  ## Create a new wl_shm_pool object.
  ## 
  ## 	The pool can be used to create shared memory based buffer
  ## 	objects.  The server will mmap size bytes of the passed file
  ## 	descriptor, to use as backing memory for the pool.
  ## 
  cast[ptr ShmPool](cast[ptr Proxy](shm).marshal_flags(ShmRequest_create_pool.ord, addr wl_shm_pool_interface, cast[ptr Proxy](shm).get_version(), 0, nil, fd, size))
proc release*(shm: ptr Shm) {.inline.} =
  ## release the shm object
  ## 
  ## Using this request a client can tell the server that it is not going to
  ## 	use the shm object anymore.
  ## 
  ## 	Objects created via this interface remain unaffected.
  ## 
  cast[ptr Proxy](shm).marshal_flags(ShmRequest_release.ord, nil, cast[ptr Proxy](shm).get_version(), WL_MARSHAL_FLAG_DESTROY)
type BufferListener* = object
  release*: proc(
    data: pointer;
    buffer: ptr Buffer;
  ) {.nimcall.}
proc addListener*(buffer: ptr Buffer; listener: ptr BufferListener; data: pointer): int {.inline.} =
  cast[ptr Proxy](buffer).add_listener(listener, data)

proc setUserData*(buffer: ptr Buffer; userData: pointer) {.inline.} =
  cast[ptr Proxy](buffer).set_user_data(user_data)
proc getUserData*(buffer: ptr Buffer): pointer {.inline.} =
  cast[ptr Proxy](buffer).get_user_data()
proc getVersion*(buffer: ptr Buffer): uint32 {.inline.} =
  cast[ptr Proxy](buffer).get_version()
proc destroy*(buffer: ptr Buffer) {.inline.} =
  ## destroy a buffer
  ## 
  ## Destroy a buffer. If and how you need to release the backing
  ## 	storage is defined by the buffer factory interface.
  ## 
  ## 	For possible side-effects to a surface, see wl_surface.attach.
  ## 
  cast[ptr Proxy](buffer).marshal_flags(BufferRequest_destroy.ord, nil, cast[ptr Proxy](buffer).get_version(), WL_MARSHAL_FLAG_DESTROY)
type DataOfferListener* = object
  offer*: proc(
    data: pointer;
    dataOffer: ptr DataOffer;
    mimeType: cstring;
  ) {.nimcall.}
  sourceActions*: proc(
    data: pointer;
    dataOffer: ptr DataOffer;
    sourceActions: uint32;
  ) {.nimcall.}
  action*: proc(
    data: pointer;
    dataOffer: ptr DataOffer;
    dndAction: uint32;
  ) {.nimcall.}
proc addListener*(dataOffer: ptr DataOffer; listener: ptr DataOfferListener; data: pointer): int {.inline.} =
  cast[ptr Proxy](dataOffer).add_listener(listener, data)

proc setUserData*(dataOffer: ptr DataOffer; userData: pointer) {.inline.} =
  cast[ptr Proxy](dataOffer).set_user_data(user_data)
proc getUserData*(dataOffer: ptr DataOffer): pointer {.inline.} =
  cast[ptr Proxy](dataOffer).get_user_data()
proc getVersion*(dataOffer: ptr DataOffer): uint32 {.inline.} =
  cast[ptr Proxy](dataOffer).get_version()
proc accept*(dataOffer: ptr DataOffer; serial: uint32; mimeType: cstring) {.inline.} =
  ## accept one of the offered mime types
  ## 
  ## Indicate that the client can accept the given mime type, or
  ## 	NULL for not accepted.
  ## 
  ## 	For objects of version 2 or older, this request is used by the
  ## 	client to give feedback whether the client can receive the given
  ## 	mime type, or NULL if none is accepted; the feedback does not
  ## 	determine whether the drag-and-drop operation succeeds or not.
  ## 
  ## 	For objects of version 3 or newer, this request determines the
  ## 	final result of the drag-and-drop operation. If the end result
  ## 	is that no mime types were accepted, the drag-and-drop operation
  ## 	will be cancelled and the corresponding drag source will receive
  ## 	wl_data_source.cancelled. Clients may still use this event in
  ## 	conjunction with wl_data_source.action for feedback.
  ## 
  cast[ptr Proxy](dataOffer).marshal_flags(DataOfferRequest_accept.ord, nil, cast[ptr Proxy](dataOffer).get_version(), 0, serial, mimeType)
proc receive*(dataOffer: ptr DataOffer; mimeType: cstring; fd: int32) {.inline.} =
  ## request that the data is transferred
  ## 
  ## To transfer the offered data, the client issues this request
  ## 	and indicates the mime type it wants to receive.  The transfer
  ## 	happens through the passed file descriptor (typically created
  ## 	with the pipe system call).  The source client writes the data
  ## 	in the mime type representation requested and then closes the
  ## 	file descriptor.
  ## 
  ## 	The receiving client reads from the read end of the pipe until
  ## 	EOF and then closes its end, at which point the transfer is
  ## 	complete.
  ## 
  ## 	This request may happen multiple times for different mime types,
  ## 	both before and after wl_data_device.drop. Drag-and-drop destination
  ## 	clients may preemptively fetch data or examine it more closely to
  ## 	determine acceptance.
  ## 
  cast[ptr Proxy](dataOffer).marshal_flags(DataOfferRequest_receive.ord, nil, cast[ptr Proxy](dataOffer).get_version(), 0, mimeType, fd)
proc destroy*(dataOffer: ptr DataOffer) {.inline.} =
  ## destroy data offer
  ## 
  ## Destroy the data offer.
  ## 
  cast[ptr Proxy](dataOffer).marshal_flags(DataOfferRequest_destroy.ord, nil, cast[ptr Proxy](dataOffer).get_version(), WL_MARSHAL_FLAG_DESTROY)
proc finish*(dataOffer: ptr DataOffer) {.inline.} =
  ## the offer will no longer be used
  ## 
  ## Notifies the compositor that the drag destination successfully
  ## 	finished the drag-and-drop operation.
  ## 
  ## 	Upon receiving this request, the compositor will emit
  ## 	wl_data_source.dnd_finished on the drag source client.
  ## 
  ## 	It is a client error to perform other requests than
  ## 	wl_data_offer.destroy after this one. It is also an error to perform
  ## 	this request after a NULL mime type has been set in
  ## 	wl_data_offer.accept or no action was received through
  ## 	wl_data_offer.action.
  ## 
  ## 	If wl_data_offer.finish request is received for a non drag and drop
  ## 	operation, the invalid_finish protocol error is raised.
  ## 
  cast[ptr Proxy](dataOffer).marshal_flags(DataOfferRequest_finish.ord, nil, cast[ptr Proxy](dataOffer).get_version(), 0)
proc setActions*(dataOffer: ptr DataOffer; dndActions: uint32; preferredAction: uint32) {.inline.} =
  ## set the available/preferred drag-and-drop actions
  ## 
  ## Sets the actions that the destination side client supports for
  ## 	this operation. This request may trigger the emission of
  ## 	wl_data_source.action and wl_data_offer.action events if the compositor
  ## 	needs to change the selected action.
  ## 
  ## 	This request can be called multiple times throughout the
  ## 	drag-and-drop operation, typically in response to wl_data_device.enter
  ## 	or wl_data_device.motion events.
  ## 
  ## 	This request determines the final result of the drag-and-drop
  ## 	operation. If the end result is that no action is accepted,
  ## 	the drag source will receive wl_data_source.cancelled.
  ## 
  ## 	The dnd_actions argument must contain only values expressed in the
  ## 	wl_data_device_manager.dnd_actions enum, and the preferred_action
  ## 	argument must only contain one of those values set, otherwise it
  ## 	will result in a protocol error.
  ## 
  ## 	While managing an "ask" action, the destination drag-and-drop client
  ## 	may perform further wl_data_offer.receive requests, and is expected
  ## 	to perform one last wl_data_offer.set_actions request with a preferred
  ## 	action other than "ask" (and optionally wl_data_offer.accept) before
  ## 	requesting wl_data_offer.finish, in order to convey the action selected
  ## 	by the user. If the preferred action is not in the
  ## 	wl_data_offer.source_actions mask, an error will be raised.
  ## 
  ## 	If the "ask" action is dismissed (e.g. user cancellation), the client
  ## 	is expected to perform wl_data_offer.destroy right away.
  ## 
  ## 	This request can only be made on drag-and-drop offers, a protocol error
  ## 	will be raised otherwise.
  ## 
  cast[ptr Proxy](dataOffer).marshal_flags(DataOfferRequest_set_actions.ord, nil, cast[ptr Proxy](dataOffer).get_version(), 0, dndActions, preferredAction)
type DataSourceListener* = object
  target*: proc(
    data: pointer;
    dataSource: ptr DataSource;
    mimeType: cstring;
  ) {.nimcall.}
  send*: proc(
    data: pointer;
    dataSource: ptr DataSource;
    mimeType: cstring;
    fd: int32;
  ) {.nimcall.}
  cancelled*: proc(
    data: pointer;
    dataSource: ptr DataSource;
  ) {.nimcall.}
  dndDropPerformed*: proc(
    data: pointer;
    dataSource: ptr DataSource;
  ) {.nimcall.}
  dndFinished*: proc(
    data: pointer;
    dataSource: ptr DataSource;
  ) {.nimcall.}
  action*: proc(
    data: pointer;
    dataSource: ptr DataSource;
    dndAction: uint32;
  ) {.nimcall.}
proc addListener*(dataSource: ptr DataSource; listener: ptr DataSourceListener; data: pointer): int {.inline.} =
  cast[ptr Proxy](dataSource).add_listener(listener, data)

proc setUserData*(dataSource: ptr DataSource; userData: pointer) {.inline.} =
  cast[ptr Proxy](dataSource).set_user_data(user_data)
proc getUserData*(dataSource: ptr DataSource): pointer {.inline.} =
  cast[ptr Proxy](dataSource).get_user_data()
proc getVersion*(dataSource: ptr DataSource): uint32 {.inline.} =
  cast[ptr Proxy](dataSource).get_version()
proc offer*(dataSource: ptr DataSource; mimeType: cstring) {.inline.} =
  ## add an offered mime type
  ## 
  ## This request adds a mime type to the set of mime types
  ## 	advertised to targets.  Can be called several times to offer
  ## 	multiple types.
  ## 
  cast[ptr Proxy](dataSource).marshal_flags(DataSourceRequest_offer.ord, nil, cast[ptr Proxy](dataSource).get_version(), 0, mimeType)
proc destroy*(dataSource: ptr DataSource) {.inline.} =
  ## destroy the data source
  ## 
  ## Destroy the data source.
  ## 
  cast[ptr Proxy](dataSource).marshal_flags(DataSourceRequest_destroy.ord, nil, cast[ptr Proxy](dataSource).get_version(), WL_MARSHAL_FLAG_DESTROY)
proc setActions*(dataSource: ptr DataSource; dndActions: uint32) {.inline.} =
  ## set the available drag-and-drop actions
  ## 
  ## Sets the actions that the source side client supports for this
  ## 	operation. This request may trigger wl_data_source.action and
  ## 	wl_data_offer.action events if the compositor needs to change the
  ## 	selected action.
  ## 
  ## 	The dnd_actions argument must contain only values expressed in the
  ## 	wl_data_device_manager.dnd_actions enum, otherwise it will result
  ## 	in a protocol error.
  ## 
  ## 	This request must be made once only, and can only be made on sources
  ## 	used in drag-and-drop, so it must be performed before
  ## 	wl_data_device.start_drag. Attempting to use the source other than
  ## 	for drag-and-drop will raise a protocol error.
  ## 
  cast[ptr Proxy](dataSource).marshal_flags(DataSourceRequest_set_actions.ord, nil, cast[ptr Proxy](dataSource).get_version(), 0, dndActions)
type DataDeviceListener* = object
  dataOffer*: proc(
    data: pointer;
    dataDevice: ptr DataDevice;
    id: ptr DataOffer;
  ) {.nimcall.}
  enter*: proc(
    data: pointer;
    dataDevice: ptr DataDevice;
    serial: uint32;
    surface: ptr Surface;
    x: Fixed;
    y: Fixed;
    id: ptr DataOffer;
  ) {.nimcall.}
  leave*: proc(
    data: pointer;
    dataDevice: ptr DataDevice;
  ) {.nimcall.}
  motion*: proc(
    data: pointer;
    dataDevice: ptr DataDevice;
    time: uint32;
    x: Fixed;
    y: Fixed;
  ) {.nimcall.}
  drop*: proc(
    data: pointer;
    dataDevice: ptr DataDevice;
  ) {.nimcall.}
  selection*: proc(
    data: pointer;
    dataDevice: ptr DataDevice;
    id: ptr DataOffer;
  ) {.nimcall.}
proc addListener*(dataDevice: ptr DataDevice; listener: ptr DataDeviceListener; data: pointer): int {.inline.} =
  cast[ptr Proxy](dataDevice).add_listener(listener, data)

proc setUserData*(dataDevice: ptr DataDevice; userData: pointer) {.inline.} =
  cast[ptr Proxy](dataDevice).set_user_data(user_data)
proc getUserData*(dataDevice: ptr DataDevice): pointer {.inline.} =
  cast[ptr Proxy](dataDevice).get_user_data()
proc getVersion*(dataDevice: ptr DataDevice): uint32 {.inline.} =
  cast[ptr Proxy](dataDevice).get_version()
proc destroy*(dataDevice: ptr DataDevice) {.inline.} =
  destroy cast[ptr Proxy](dataDevice)
proc startDrag*(dataDevice: ptr DataDevice; source: ptr DataSource; origin: ptr Surface; icon: ptr Surface; serial: uint32) {.inline.} =
  ## start drag-and-drop operation
  ## 
  ## This request asks the compositor to start a drag-and-drop
  ## 	operation on behalf of the client.
  ## 
  ## 	The source argument is the data source that provides the data
  ## 	for the eventual data transfer. If source is NULL, enter, leave
  ## 	and motion events are sent only to the client that initiated the
  ## 	drag and the client is expected to handle the data passing
  ## 	internally. If source is destroyed, the drag-and-drop session will be
  ## 	cancelled.
  ## 
  ## 	The origin surface is the surface where the drag originates and
  ## 	the client must have an active implicit grab that matches the
  ## 	serial.
  ## 
  ## 	The icon surface is an optional (can be NULL) surface that
  ## 	provides an icon to be moved around with the cursor.  Initially,
  ## 	the top-left corner of the icon surface is placed at the cursor
  ## 	hotspot, but subsequent wl_surface.offset requests can move the
  ## 	relative position. Attach requests must be confirmed with
  ## 	wl_surface.commit as usual. The icon surface is given the role of
  ## 	a drag-and-drop icon. If the icon surface already has another role,
  ## 	it raises a protocol error.
  ## 
  ## 	The input region is ignored for wl_surfaces with the role of a
  ## 	drag-and-drop icon.
  ## 
  ## 	The given source may not be used in any further set_selection or
  ## 	start_drag requests. Attempting to reuse a previously-used source
  ## 	may send a used_source error.
  ## 
  cast[ptr Proxy](dataDevice).marshal_flags(DataDeviceRequest_start_drag.ord, nil, cast[ptr Proxy](dataDevice).get_version(), 0, source, origin, icon, serial)
proc setSelection*(dataDevice: ptr DataDevice; source: ptr DataSource; serial: uint32) {.inline.} =
  ## copy data to the selection
  ## 
  ## This request asks the compositor to set the selection
  ## 	to the data from the source on behalf of the client.
  ## 
  ## 	To unset the selection, set the source to NULL.
  ## 
  ## 	The given source may not be used in any further set_selection or
  ## 	start_drag requests. Attempting to reuse a previously-used source
  ## 	may send a used_source error.
  ## 
  cast[ptr Proxy](dataDevice).marshal_flags(DataDeviceRequest_set_selection.ord, nil, cast[ptr Proxy](dataDevice).get_version(), 0, source, serial)
proc release*(dataDevice: ptr DataDevice) {.inline.} =
  ## destroy data device
  ## 
  ## This request destroys the data device.
  ## 
  cast[ptr Proxy](dataDevice).marshal_flags(DataDeviceRequest_release.ord, nil, cast[ptr Proxy](dataDevice).get_version(), WL_MARSHAL_FLAG_DESTROY)
proc setUserData*(dataDeviceManager: ptr DataDeviceManager; userData: pointer) {.inline.} =
  cast[ptr Proxy](dataDeviceManager).set_user_data(user_data)
proc getUserData*(dataDeviceManager: ptr DataDeviceManager): pointer {.inline.} =
  cast[ptr Proxy](dataDeviceManager).get_user_data()
proc getVersion*(dataDeviceManager: ptr DataDeviceManager): uint32 {.inline.} =
  cast[ptr Proxy](dataDeviceManager).get_version()
proc destroy*(dataDeviceManager: ptr DataDeviceManager) {.inline.} =
  destroy cast[ptr Proxy](dataDeviceManager)
proc createDataSource*(dataDeviceManager: ptr DataDeviceManager): ptr DataSource {.inline.} =
  ## create a new data source
  ## 
  ## Create a new data source.
  ## 
  cast[ptr DataSource](cast[ptr Proxy](dataDeviceManager).marshal_flags(DataDeviceManagerRequest_create_data_source.ord, addr wl_data_source_interface, cast[ptr Proxy](dataDeviceManager).get_version(), 0, nil))
proc getDataDevice*(dataDeviceManager: ptr DataDeviceManager; seat: ptr Seat): ptr DataDevice {.inline.} =
  ## create a new data device
  ## 
  ## Create a new data device for a given seat.
  ## 
  cast[ptr DataDevice](cast[ptr Proxy](dataDeviceManager).marshal_flags(DataDeviceManagerRequest_get_data_device.ord, addr wl_data_device_interface, cast[ptr Proxy](dataDeviceManager).get_version(), 0, nil, seat))
proc setUserData*(shell: ptr Shell; userData: pointer) {.inline.} =
  cast[ptr Proxy](shell).set_user_data(user_data)
proc getUserData*(shell: ptr Shell): pointer {.inline.} =
  cast[ptr Proxy](shell).get_user_data()
proc getVersion*(shell: ptr Shell): uint32 {.inline.} =
  cast[ptr Proxy](shell).get_version()
proc destroy*(shell: ptr Shell) {.inline.} =
  destroy cast[ptr Proxy](shell)
proc getShellSurface*(shell: ptr Shell; surface: ptr Surface): ptr ShellSurface {.inline.} =
  ## create a shell surface from a surface
  ## 
  ## Create a shell surface for an existing surface. This gives
  ## 	the wl_surface the role of a shell surface. If the wl_surface
  ## 	already has another role, it raises a protocol error.
  ## 
  ## 	Only one shell surface can be associated with a given surface.
  ## 
  cast[ptr ShellSurface](cast[ptr Proxy](shell).marshal_flags(ShellRequest_get_shell_surface.ord, addr wl_shell_surface_interface, cast[ptr Proxy](shell).get_version(), 0, nil, surface))
type ShellSurfaceListener* = object
  ping*: proc(
    data: pointer;
    shellSurface: ptr ShellSurface;
    serial: uint32;
  ) {.nimcall.}
  configure*: proc(
    data: pointer;
    shellSurface: ptr ShellSurface;
    edges: uint32;
    width: int32;
    height: int32;
  ) {.nimcall.}
  popupDone*: proc(
    data: pointer;
    shellSurface: ptr ShellSurface;
  ) {.nimcall.}
proc addListener*(shellSurface: ptr ShellSurface; listener: ptr ShellSurfaceListener; data: pointer): int {.inline.} =
  cast[ptr Proxy](shellSurface).add_listener(listener, data)

proc setUserData*(shellSurface: ptr ShellSurface; userData: pointer) {.inline.} =
  cast[ptr Proxy](shellSurface).set_user_data(user_data)
proc getUserData*(shellSurface: ptr ShellSurface): pointer {.inline.} =
  cast[ptr Proxy](shellSurface).get_user_data()
proc getVersion*(shellSurface: ptr ShellSurface): uint32 {.inline.} =
  cast[ptr Proxy](shellSurface).get_version()
proc destroy*(shellSurface: ptr ShellSurface) {.inline.} =
  destroy cast[ptr Proxy](shellSurface)
proc pong*(shellSurface: ptr ShellSurface; serial: uint32) {.inline.} =
  ## respond to a ping event
  ## 
  ## A client must respond to a ping event with a pong request or
  ## 	the client may be deemed unresponsive.
  ## 
  cast[ptr Proxy](shellSurface).marshal_flags(ShellSurfaceRequest_pong.ord, nil, cast[ptr Proxy](shellSurface).get_version(), 0, serial)
proc move*(shellSurface: ptr ShellSurface; seat: ptr Seat; serial: uint32) {.inline.} =
  ## start an interactive move
  ## 
  ## Start a pointer-driven move of the surface.
  ## 
  ## 	This request must be used in response to a button press event.
  ## 	The server may ignore move requests depending on the state of
  ## 	the surface (e.g. fullscreen or maximized).
  ## 
  cast[ptr Proxy](shellSurface).marshal_flags(ShellSurfaceRequest_move.ord, nil, cast[ptr Proxy](shellSurface).get_version(), 0, seat, serial)
proc resize*(shellSurface: ptr ShellSurface; seat: ptr Seat; serial: uint32; edges: uint32) {.inline.} =
  ## start an interactive resize
  ## 
  ## Start a pointer-driven resizing of the surface.
  ## 
  ## 	This request must be used in response to a button press event.
  ## 	The server may ignore resize requests depending on the state of
  ## 	the surface (e.g. fullscreen or maximized).
  ## 
  cast[ptr Proxy](shellSurface).marshal_flags(ShellSurfaceRequest_resize.ord, nil, cast[ptr Proxy](shellSurface).get_version(), 0, seat, serial, edges)
proc setToplevel*(shellSurface: ptr ShellSurface) {.inline.} =
  ## make the surface a toplevel surface
  ## 
  ## Map the surface as a toplevel surface.
  ## 
  ## 	A toplevel surface is not fullscreen, maximized or transient.
  ## 
  cast[ptr Proxy](shellSurface).marshal_flags(ShellSurfaceRequest_set_toplevel.ord, nil, cast[ptr Proxy](shellSurface).get_version(), 0)
proc setTransient*(shellSurface: ptr ShellSurface; parent: ptr Surface; x: int32; y: int32; flags: uint32) {.inline.} =
  ## make the surface a transient surface
  ## 
  ## Map the surface relative to an existing surface.
  ## 
  ## 	The x and y arguments specify the location of the upper left
  ## 	corner of the surface relative to the upper left corner of the
  ## 	parent surface, in surface-local coordinates.
  ## 
  ## 	The flags argument controls details of the transient behaviour.
  ## 
  cast[ptr Proxy](shellSurface).marshal_flags(ShellSurfaceRequest_set_transient.ord, nil, cast[ptr Proxy](shellSurface).get_version(), 0, parent, x, y, flags)
proc setFullscreen*(shellSurface: ptr ShellSurface; `method`: uint32; framerate: uint32; output: ptr Output) {.inline.} =
  ## make the surface a fullscreen surface
  ## 
  ## Map the surface as a fullscreen surface.
  ## 
  ## 	If an output parameter is given then the surface will be made
  ## 	fullscreen on that output. If the client does not specify the
  ## 	output then the compositor will apply its policy - usually
  ## 	choosing the output on which the surface has the biggest surface
  ## 	area.
  ## 
  ## 	The client may specify a method to resolve a size conflict
  ## 	between the output size and the surface size - this is provided
  ## 	through the method parameter.
  ## 
  ## 	The framerate parameter is used only when the method is set
  ## 	to "driver", to indicate the preferred framerate. A value of 0
  ## 	indicates that the client does not care about framerate.  The
  ## 	framerate is specified in mHz, that is framerate of 60000 is 60Hz.
  ## 
  ## 	A method of "scale" or "driver" implies a scaling operation of
  ## 	the surface, either via a direct scaling operation or a change of
  ## 	the output mode. This will override any kind of output scaling, so
  ## 	that mapping a surface with a buffer size equal to the mode can
  ## 	fill the screen independent of buffer_scale.
  ## 
  ## 	A method of "fill" means we don't scale up the buffer, however
  ## 	any output scale is applied. This means that you may run into
  ## 	an edge case where the application maps a buffer with the same
  ## 	size of the output mode but buffer_scale 1 (thus making a
  ## 	surface larger than the output). In this case it is allowed to
  ## 	downscale the results to fit the screen.
  ## 
  ## 	The compositor must reply to this request with a configure event
  ## 	with the dimensions for the output on which the surface will
  ## 	be made fullscreen.
  ## 
  cast[ptr Proxy](shellSurface).marshal_flags(ShellSurfaceRequest_set_fullscreen.ord, nil, cast[ptr Proxy](shellSurface).get_version(), 0, `method`, framerate, output)
proc setPopup*(shellSurface: ptr ShellSurface; seat: ptr Seat; serial: uint32; parent: ptr Surface; x: int32; y: int32; flags: uint32) {.inline.} =
  ## make the surface a popup surface
  ## 
  ## Map the surface as a popup.
  ## 
  ## 	A popup surface is a transient surface with an added pointer
  ## 	grab.
  ## 
  ## 	An existing implicit grab will be changed to owner-events mode,
  ## 	and the popup grab will continue after the implicit grab ends
  ## 	(i.e. releasing the mouse button does not cause the popup to
  ## 	be unmapped).
  ## 
  ## 	The popup grab continues until the window is destroyed or a
  ## 	mouse button is pressed in any other client's window. A click
  ## 	in any of the client's surfaces is reported as normal, however,
  ## 	clicks in other clients' surfaces will be discarded and trigger
  ## 	the callback.
  ## 
  ## 	The x and y arguments specify the location of the upper left
  ## 	corner of the surface relative to the upper left corner of the
  ## 	parent surface, in surface-local coordinates.
  ## 
  cast[ptr Proxy](shellSurface).marshal_flags(ShellSurfaceRequest_set_popup.ord, nil, cast[ptr Proxy](shellSurface).get_version(), 0, seat, serial, parent, x, y, flags)
proc setMaximized*(shellSurface: ptr ShellSurface; output: ptr Output) {.inline.} =
  ## make the surface a maximized surface
  ## 
  ## Map the surface as a maximized surface.
  ## 
  ## 	If an output parameter is given then the surface will be
  ## 	maximized on that output. If the client does not specify the
  ## 	output then the compositor will apply its policy - usually
  ## 	choosing the output on which the surface has the biggest surface
  ## 	area.
  ## 
  ## 	The compositor will reply with a configure event telling
  ## 	the expected new surface size. The operation is completed
  ## 	on the next buffer attach to this surface.
  ## 
  ## 	A maximized surface typically fills the entire output it is
  ## 	bound to, except for desktop elements such as panels. This is
  ## 	the main difference between a maximized shell surface and a
  ## 	fullscreen shell surface.
  ## 
  ## 	The details depend on the compositor implementation.
  ## 
  cast[ptr Proxy](shellSurface).marshal_flags(ShellSurfaceRequest_set_maximized.ord, nil, cast[ptr Proxy](shellSurface).get_version(), 0, output)
proc setTitle*(shellSurface: ptr ShellSurface; title: cstring) {.inline.} =
  ## set surface title
  ## 
  ## Set a short title for the surface.
  ## 
  ## 	This string may be used to identify the surface in a task bar,
  ## 	window list, or other user interface elements provided by the
  ## 	compositor.
  ## 
  ## 	The string must be encoded in UTF-8.
  ## 
  cast[ptr Proxy](shellSurface).marshal_flags(ShellSurfaceRequest_set_title.ord, nil, cast[ptr Proxy](shellSurface).get_version(), 0, title)
proc setClass*(shellSurface: ptr ShellSurface; class: cstring) {.inline.} =
  ## set surface class
  ## 
  ## Set a class for the surface.
  ## 
  ## 	The surface class identifies the general class of applications
  ## 	to which the surface belongs. A common convention is to use the
  ## 	file name (or the full path if it is a non-standard location) of
  ## 	the application's .desktop file as the class.
  ## 
  cast[ptr Proxy](shellSurface).marshal_flags(ShellSurfaceRequest_set_class.ord, nil, cast[ptr Proxy](shellSurface).get_version(), 0, class)
type SurfaceListener* = object
  enter*: proc(
    data: pointer;
    surface: ptr Surface;
    output: ptr Output;
  ) {.nimcall.}
  leave*: proc(
    data: pointer;
    surface: ptr Surface;
    output: ptr Output;
  ) {.nimcall.}
  preferredBufferScale*: proc(
    data: pointer;
    surface: ptr Surface;
    factor: int32;
  ) {.nimcall.}
  preferredBufferTransform*: proc(
    data: pointer;
    surface: ptr Surface;
    transform: uint32;
  ) {.nimcall.}
proc addListener*(surface: ptr Surface; listener: ptr SurfaceListener; data: pointer): int {.inline.} =
  cast[ptr Proxy](surface).add_listener(listener, data)

proc setUserData*(surface: ptr Surface; userData: pointer) {.inline.} =
  cast[ptr Proxy](surface).set_user_data(user_data)
proc getUserData*(surface: ptr Surface): pointer {.inline.} =
  cast[ptr Proxy](surface).get_user_data()
proc getVersion*(surface: ptr Surface): uint32 {.inline.} =
  cast[ptr Proxy](surface).get_version()
proc destroy*(surface: ptr Surface) {.inline.} =
  ## delete surface
  ## 
  ## Deletes the surface and invalidates its object ID.
  ## 
  cast[ptr Proxy](surface).marshal_flags(SurfaceRequest_destroy.ord, nil, cast[ptr Proxy](surface).get_version(), WL_MARSHAL_FLAG_DESTROY)
proc attach*(surface: ptr Surface; buffer: ptr Buffer; x: int32; y: int32) {.inline.} =
  ## set the surface contents
  ## 
  ## Set a buffer as the content of this surface.
  ## 
  ## 	The new size of the surface is calculated based on the buffer
  ## 	size transformed by the inverse buffer_transform and the
  ## 	inverse buffer_scale. This means that at commit time the supplied
  ## 	buffer size must be an integer multiple of the buffer_scale. If
  ## 	that's not the case, an invalid_size error is sent.
  ## 
  ## 	The x and y arguments specify the location of the new pending
  ## 	buffer's upper left corner, relative to the current buffer's upper
  ## 	left corner, in surface-local coordinates. In other words, the
  ## 	x and y, combined with the new surface size define in which
  ## 	directions the surface's size changes. Setting anything other than 0
  ## 	as x and y arguments is discouraged, and should instead be replaced
  ## 	with using the separate wl_surface.offset request.
  ## 
  ## 	When the bound wl_surface version is 5 or higher, passing any
  ## 	non-zero x or y is a protocol violation, and will result in an
  ## 	'invalid_offset' error being raised. The x and y arguments are ignored
  ## 	and do not change the pending state. To achieve equivalent semantics,
  ## 	use wl_surface.offset.
  ## 
  ## 	Surface contents are double-buffered state, see wl_surface.commit.
  ## 
  ## 	The initial surface contents are void; there is no content.
  ## 	wl_surface.attach assigns the given wl_buffer as the pending
  ## 	wl_buffer. wl_surface.commit makes the pending wl_buffer the new
  ## 	surface contents, and the size of the surface becomes the size
  ## 	calculated from the wl_buffer, as described above. After commit,
  ## 	there is no pending buffer until the next attach.
  ## 
  ## 	Committing a pending wl_buffer allows the compositor to read the
  ## 	pixels in the wl_buffer. The compositor may access the pixels at
  ## 	any time after the wl_surface.commit request. When the compositor
  ## 	will not access the pixels anymore, it will send the
  ## 	wl_buffer.release event. Only after receiving wl_buffer.release,
  ## 	the client may reuse the wl_buffer. A wl_buffer that has been
  ## 	attached and then replaced by another attach instead of committed
  ## 	will not receive a release event, and is not used by the
  ## 	compositor.
  ## 
  ## 	If a pending wl_buffer has been committed to more than one wl_surface,
  ## 	the delivery of wl_buffer.release events becomes undefined. A well
  ## 	behaved client should not rely on wl_buffer.release events in this
  ## 	case. Alternatively, a client could create multiple wl_buffer objects
  ## 	from the same backing storage or use wp_linux_buffer_release.
  ## 
  ## 	Destroying the wl_buffer after wl_buffer.release does not change
  ## 	the surface contents. Destroying the wl_buffer before wl_buffer.release
  ## 	is allowed as long as the underlying buffer storage isn't re-used (this
  ## 	can happen e.g. on client process termination). However, if the client
  ## 	destroys the wl_buffer before receiving the wl_buffer.release event and
  ## 	mutates the underlying buffer storage, the surface contents become
  ## 	undefined immediately.
  ## 
  ## 	If wl_surface.attach is sent with a NULL wl_buffer, the
  ## 	following wl_surface.commit will remove the surface content.
  ## 
  ## 	If a pending wl_buffer has been destroyed, the result is not specified.
  ## 	Many compositors are known to remove the surface content on the following
  ## 	wl_surface.commit, but this behaviour is not universal. Clients seeking to
  ## 	maximise compatibility should not destroy pending buffers and should
  ## 	ensure that they explicitly remove content from surfaces, even after
  ## 	destroying buffers.
  ## 
  cast[ptr Proxy](surface).marshal_flags(SurfaceRequest_attach.ord, nil, cast[ptr Proxy](surface).get_version(), 0, buffer, x, y)
proc damage*(surface: ptr Surface; x: int32; y: int32; width: int32; height: int32) {.inline.} =
  ## mark part of the surface damaged
  ## 
  ## This request is used to describe the regions where the pending
  ## 	buffer is different from the current surface contents, and where
  ## 	the surface therefore needs to be repainted. The compositor
  ## 	ignores the parts of the damage that fall outside of the surface.
  ## 
  ## 	Damage is double-buffered state, see wl_surface.commit.
  ## 
  ## 	The damage rectangle is specified in surface-local coordinates,
  ## 	where x and y specify the upper left corner of the damage rectangle.
  ## 
  ## 	The initial value for pending damage is empty: no damage.
  ## 	wl_surface.damage adds pending damage: the new pending damage
  ## 	is the union of old pending damage and the given rectangle.
  ## 
  ## 	wl_surface.commit assigns pending damage as the current damage,
  ## 	and clears pending damage. The server will clear the current
  ## 	damage as it repaints the surface.
  ## 
  ## 	Note! New clients should not use this request. Instead damage can be
  ## 	posted with wl_surface.damage_buffer which uses buffer coordinates
  ## 	instead of surface coordinates.
  ## 
  cast[ptr Proxy](surface).marshal_flags(SurfaceRequest_damage.ord, nil, cast[ptr Proxy](surface).get_version(), 0, x, y, width, height)
proc frame*(surface: ptr Surface): ptr Callback {.inline.} =
  ## request a frame throttling hint
  ## 
  ## Request a notification when it is a good time to start drawing a new
  ## 	frame, by creating a frame callback. This is useful for throttling
  ## 	redrawing operations, and driving animations.
  ## 
  ## 	When a client is animating on a wl_surface, it can use the 'frame'
  ## 	request to get notified when it is a good time to draw and commit the
  ## 	next frame of animation. If the client commits an update earlier than
  ## 	that, it is likely that some updates will not make it to the display,
  ## 	and the client is wasting resources by drawing too often.
  ## 
  ## 	The frame request will take effect on the next wl_surface.commit.
  ## 	The notification will only be posted for one frame unless
  ## 	requested again. For a wl_surface, the notifications are posted in
  ## 	the order the frame requests were committed.
  ## 
  ## 	The server must send the notifications so that a client
  ## 	will not send excessive updates, while still allowing
  ## 	the highest possible update rate for clients that wait for the reply
  ## 	before drawing again. The server should give some time for the client
  ## 	to draw and commit after sending the frame callback events to let it
  ## 	hit the next output refresh.
  ## 
  ## 	A server should avoid signaling the frame callbacks if the
  ## 	surface is not visible in any way, e.g. the surface is off-screen,
  ## 	or completely obscured by other opaque surfaces.
  ## 
  ## 	The object returned by this request will be destroyed by the
  ## 	compositor after the callback is fired and as such the client must not
  ## 	attempt to use it after that point.
  ## 
  ## 	The callback_data passed in the callback is the current time, in
  ## 	milliseconds, with an undefined base.
  ## 
  cast[ptr Callback](cast[ptr Proxy](surface).marshal_flags(SurfaceRequest_frame.ord, addr wl_callback_interface, cast[ptr Proxy](surface).get_version(), 0, nil))
proc setOpaqueRegion*(surface: ptr Surface; region: ptr Region) {.inline.} =
  ## set opaque region
  ## 
  ## This request sets the region of the surface that contains
  ## 	opaque content.
  ## 
  ## 	The opaque region is an optimization hint for the compositor
  ## 	that lets it optimize the redrawing of content behind opaque
  ## 	regions.  Setting an opaque region is not required for correct
  ## 	behaviour, but marking transparent content as opaque will result
  ## 	in repaint artifacts.
  ## 
  ## 	The opaque region is specified in surface-local coordinates.
  ## 
  ## 	The compositor ignores the parts of the opaque region that fall
  ## 	outside of the surface.
  ## 
  ## 	Opaque region is double-buffered state, see wl_surface.commit.
  ## 
  ## 	wl_surface.set_opaque_region changes the pending opaque region.
  ## 	wl_surface.commit copies the pending region to the current region.
  ## 	Otherwise, the pending and current regions are never changed.
  ## 
  ## 	The initial value for an opaque region is empty. Setting the pending
  ## 	opaque region has copy semantics, and the wl_region object can be
  ## 	destroyed immediately. A NULL wl_region causes the pending opaque
  ## 	region to be set to empty.
  ## 
  cast[ptr Proxy](surface).marshal_flags(SurfaceRequest_set_opaque_region.ord, nil, cast[ptr Proxy](surface).get_version(), 0, region)
proc setInputRegion*(surface: ptr Surface; region: ptr Region) {.inline.} =
  ## set input region
  ## 
  ## This request sets the region of the surface that can receive
  ## 	pointer and touch events.
  ## 
  ## 	Input events happening outside of this region will try the next
  ## 	surface in the server surface stack. The compositor ignores the
  ## 	parts of the input region that fall outside of the surface.
  ## 
  ## 	The input region is specified in surface-local coordinates.
  ## 
  ## 	Input region is double-buffered state, see wl_surface.commit.
  ## 
  ## 	wl_surface.set_input_region changes the pending input region.
  ## 	wl_surface.commit copies the pending region to the current region.
  ## 	Otherwise the pending and current regions are never changed,
  ## 	except cursor and icon surfaces are special cases, see
  ## 	wl_pointer.set_cursor and wl_data_device.start_drag.
  ## 
  ## 	The initial value for an input region is infinite. That means the
  ## 	whole surface will accept input. Setting the pending input region
  ## 	has copy semantics, and the wl_region object can be destroyed
  ## 	immediately. A NULL wl_region causes the input region to be set
  ## 	to infinite.
  ## 
  cast[ptr Proxy](surface).marshal_flags(SurfaceRequest_set_input_region.ord, nil, cast[ptr Proxy](surface).get_version(), 0, region)
proc commit*(surface: ptr Surface) {.inline.} =
  ## commit pending surface state
  ## 
  ## Surface state (input, opaque, and damage regions, attached buffers,
  ## 	etc.) is double-buffered. Protocol requests modify the pending state,
  ## 	as opposed to the active state in use by the compositor.
  ## 
  ## 	A commit request atomically creates a content update from the pending
  ## 	state, even if the pending state has not been touched. The content
  ## 	update is placed in a queue until it becomes active. After commit, the
  ## 	new pending state is as documented for each related request.
  ## 
  ## 	When the content update is applied, the wl_buffer is applied before all
  ## 	other state. This means that all coordinates in double-buffered state
  ## 	are relative to the newly attached wl_buffers, except for
  ## 	wl_surface.attach itself. If there is no newly attached wl_buffer, the
  ## 	coordinates are relative to the previous content update.
  ## 
  ## 	All requests that need a commit to become effective are documented
  ## 	to affect double-buffered state.
  ## 
  ## 	Other interfaces may add further double-buffered surface state.
  ## 
  cast[ptr Proxy](surface).marshal_flags(SurfaceRequest_commit.ord, nil, cast[ptr Proxy](surface).get_version(), 0)
proc setBufferTransform*(surface: ptr Surface; transform: int32) {.inline.} =
  ## sets the buffer transformation
  ## 
  ## This request sets the transformation that the client has already applied
  ## 	to the content of the buffer. The accepted values for the transform
  ## 	parameter are the values for wl_output.transform.
  ## 
  ## 	The compositor applies the inverse of this transformation whenever it
  ## 	uses the buffer contents.
  ## 
  ## 	Buffer transform is double-buffered state, see wl_surface.commit.
  ## 
  ## 	A newly created surface has its buffer transformation set to normal.
  ## 
  ## 	wl_surface.set_buffer_transform changes the pending buffer
  ## 	transformation. wl_surface.commit copies the pending buffer
  ## 	transformation to the current one. Otherwise, the pending and current
  ## 	values are never changed.
  ## 
  ## 	The purpose of this request is to allow clients to render content
  ## 	according to the output transform, thus permitting the compositor to
  ## 	use certain optimizations even if the display is rotated. Using
  ## 	hardware overlays and scanning out a client buffer for fullscreen
  ## 	surfaces are examples of such optimizations. Those optimizations are
  ## 	highly dependent on the compositor implementation, so the use of this
  ## 	request should be considered on a case-by-case basis.
  ## 
  ## 	Note that if the transform value includes 90 or 270 degree rotation,
  ## 	the width of the buffer will become the surface height and the height
  ## 	of the buffer will become the surface width.
  ## 
  ## 	If transform is not one of the values from the
  ## 	wl_output.transform enum the invalid_transform protocol error
  ## 	is raised.
  ## 
  cast[ptr Proxy](surface).marshal_flags(SurfaceRequest_set_buffer_transform.ord, nil, cast[ptr Proxy](surface).get_version(), 0, transform)
proc setBufferScale*(surface: ptr Surface; scale: int32) {.inline.} =
  ## sets the buffer scaling factor
  ## 
  ## This request sets an optional scaling factor on how the compositor
  ## 	interprets the contents of the buffer attached to the window.
  ## 
  ## 	Buffer scale is double-buffered state, see wl_surface.commit.
  ## 
  ## 	A newly created surface has its buffer scale set to 1.
  ## 
  ## 	wl_surface.set_buffer_scale changes the pending buffer scale.
  ## 	wl_surface.commit copies the pending buffer scale to the current one.
  ## 	Otherwise, the pending and current values are never changed.
  ## 
  ## 	The purpose of this request is to allow clients to supply higher
  ## 	resolution buffer data for use on high resolution outputs. It is
  ## 	intended that you pick the same buffer scale as the scale of the
  ## 	output that the surface is displayed on. This means the compositor
  ## 	can avoid scaling when rendering the surface on that output.
  ## 
  ## 	Note that if the scale is larger than 1, then you have to attach
  ## 	a buffer that is larger (by a factor of scale in each dimension)
  ## 	than the desired surface size.
  ## 
  ## 	If scale is not greater than 0 the invalid_scale protocol error is
  ## 	raised.
  ## 
  cast[ptr Proxy](surface).marshal_flags(SurfaceRequest_set_buffer_scale.ord, nil, cast[ptr Proxy](surface).get_version(), 0, scale)
proc damageBuffer*(surface: ptr Surface; x: int32; y: int32; width: int32; height: int32) {.inline.} =
  ## mark part of the surface damaged using buffer coordinates
  ## 
  ## This request is used to describe the regions where the pending
  ## 	buffer is different from the current surface contents, and where
  ## 	the surface therefore needs to be repainted. The compositor
  ## 	ignores the parts of the damage that fall outside of the surface.
  ## 
  ## 	Damage is double-buffered state, see wl_surface.commit.
  ## 
  ## 	The damage rectangle is specified in buffer coordinates,
  ## 	where x and y specify the upper left corner of the damage rectangle.
  ## 
  ## 	The initial value for pending damage is empty: no damage.
  ## 	wl_surface.damage_buffer adds pending damage: the new pending
  ## 	damage is the union of old pending damage and the given rectangle.
  ## 
  ## 	wl_surface.commit assigns pending damage as the current damage,
  ## 	and clears pending damage. The server will clear the current
  ## 	damage as it repaints the surface.
  ## 
  ## 	This request differs from wl_surface.damage in only one way - it
  ## 	takes damage in buffer coordinates instead of surface-local
  ## 	coordinates. While this generally is more intuitive than surface
  ## 	coordinates, it is especially desirable when using wp_viewport
  ## 	or when a drawing library (like EGL) is unaware of buffer scale
  ## 	and buffer transform.
  ## 
  ## 	Note: Because buffer transformation changes and damage requests may
  ## 	be interleaved in the protocol stream, it is impossible to determine
  ## 	the actual mapping between surface and buffer damage until
  ## 	wl_surface.commit time. Therefore, compositors wishing to take both
  ## 	kinds of damage into account will have to accumulate damage from the
  ## 	two requests separately and only transform from one to the other
  ## 	after receiving the wl_surface.commit.
  ## 
  cast[ptr Proxy](surface).marshal_flags(SurfaceRequest_damage_buffer.ord, nil, cast[ptr Proxy](surface).get_version(), 0, x, y, width, height)
proc offset*(surface: ptr Surface; x: int32; y: int32) {.inline.} =
  ## set the surface contents offset
  ## 
  ## The x and y arguments specify the location of the new pending
  ## 	buffer's upper left corner, relative to the current buffer's upper
  ## 	left corner, in surface-local coordinates. In other words, the
  ## 	x and y, combined with the new surface size define in which
  ## 	directions the surface's size changes.
  ## 
  ## 	Surface location offset is double-buffered state, see
  ## 	wl_surface.commit.
  ## 
  ## 	This request is semantically equivalent to and the replaces the x and y
  ## 	arguments in the wl_surface.attach request in wl_surface versions prior
  ## 	to 5. See wl_surface.attach for details.
  ## 
  cast[ptr Proxy](surface).marshal_flags(SurfaceRequest_offset.ord, nil, cast[ptr Proxy](surface).get_version(), 0, x, y)
type SeatListener* = object
  capabilities*: proc(
    data: pointer;
    seat: ptr Seat;
    capabilities: uint32;
  ) {.nimcall.}
  name*: proc(
    data: pointer;
    seat: ptr Seat;
    name: cstring;
  ) {.nimcall.}
proc addListener*(seat: ptr Seat; listener: ptr SeatListener; data: pointer): int {.inline.} =
  cast[ptr Proxy](seat).add_listener(listener, data)

proc setUserData*(seat: ptr Seat; userData: pointer) {.inline.} =
  cast[ptr Proxy](seat).set_user_data(user_data)
proc getUserData*(seat: ptr Seat): pointer {.inline.} =
  cast[ptr Proxy](seat).get_user_data()
proc getVersion*(seat: ptr Seat): uint32 {.inline.} =
  cast[ptr Proxy](seat).get_version()
proc destroy*(seat: ptr Seat) {.inline.} =
  destroy cast[ptr Proxy](seat)
proc getPointer*(seat: ptr Seat): ptr Pointer {.inline.} =
  ## return pointer object
  ## 
  ## The ID provided will be initialized to the wl_pointer interface
  ## 	for this seat.
  ## 
  ## 	This request only takes effect if the seat has the pointer
  ## 	capability, or has had the pointer capability in the past.
  ## 	It is a protocol violation to issue this request on a seat that has
  ## 	never had the pointer capability. The missing_capability error will
  ## 	be sent in this case.
  ## 
  cast[ptr Pointer](cast[ptr Proxy](seat).marshal_flags(SeatRequest_get_pointer.ord, addr wl_pointer_interface, cast[ptr Proxy](seat).get_version(), 0, nil))
proc getKeyboard*(seat: ptr Seat): ptr Keyboard {.inline.} =
  ## return keyboard object
  ## 
  ## The ID provided will be initialized to the wl_keyboard interface
  ## 	for this seat.
  ## 
  ## 	This request only takes effect if the seat has the keyboard
  ## 	capability, or has had the keyboard capability in the past.
  ## 	It is a protocol violation to issue this request on a seat that has
  ## 	never had the keyboard capability. The missing_capability error will
  ## 	be sent in this case.
  ## 
  cast[ptr Keyboard](cast[ptr Proxy](seat).marshal_flags(SeatRequest_get_keyboard.ord, addr wl_keyboard_interface, cast[ptr Proxy](seat).get_version(), 0, nil))
proc getTouch*(seat: ptr Seat): ptr Touch {.inline.} =
  ## return touch object
  ## 
  ## The ID provided will be initialized to the wl_touch interface
  ## 	for this seat.
  ## 
  ## 	This request only takes effect if the seat has the touch
  ## 	capability, or has had the touch capability in the past.
  ## 	It is a protocol violation to issue this request on a seat that has
  ## 	never had the touch capability. The missing_capability error will
  ## 	be sent in this case.
  ## 
  cast[ptr Touch](cast[ptr Proxy](seat).marshal_flags(SeatRequest_get_touch.ord, addr wl_touch_interface, cast[ptr Proxy](seat).get_version(), 0, nil))
proc release*(seat: ptr Seat) {.inline.} =
  ## release the seat object
  ## 
  ## Using this request a client can tell the server that it is not going to
  ## 	use the seat object anymore.
  ## 
  cast[ptr Proxy](seat).marshal_flags(SeatRequest_release.ord, nil, cast[ptr Proxy](seat).get_version(), WL_MARSHAL_FLAG_DESTROY)
type PointerListener* = object
  enter*: proc(
    data: pointer;
    pointer: ptr Pointer;
    serial: uint32;
    surface: ptr Surface;
    surfaceX: Fixed;
    surfaceY: Fixed;
  ) {.nimcall.}
  leave*: proc(
    data: pointer;
    pointer: ptr Pointer;
    serial: uint32;
    surface: ptr Surface;
  ) {.nimcall.}
  motion*: proc(
    data: pointer;
    pointer: ptr Pointer;
    time: uint32;
    surfaceX: Fixed;
    surfaceY: Fixed;
  ) {.nimcall.}
  button*: proc(
    data: pointer;
    pointer: ptr Pointer;
    serial: uint32;
    time: uint32;
    button: uint32;
    state: uint32;
  ) {.nimcall.}
  axis*: proc(
    data: pointer;
    pointer: ptr Pointer;
    time: uint32;
    axis: uint32;
    value: Fixed;
  ) {.nimcall.}
  frame*: proc(
    data: pointer;
    pointer: ptr Pointer;
  ) {.nimcall.}
  axisSource*: proc(
    data: pointer;
    pointer: ptr Pointer;
    axisSource: uint32;
  ) {.nimcall.}
  axisStop*: proc(
    data: pointer;
    pointer: ptr Pointer;
    time: uint32;
    axis: uint32;
  ) {.nimcall.}
  axisDiscrete*: proc(
    data: pointer;
    pointer: ptr Pointer;
    axis: uint32;
    discrete: int32;
  ) {.nimcall.}
  axisValue120*: proc(
    data: pointer;
    pointer: ptr Pointer;
    axis: uint32;
    value120: int32;
  ) {.nimcall.}
  axisRelativeDirection*: proc(
    data: pointer;
    pointer: ptr Pointer;
    axis: uint32;
    direction: uint32;
  ) {.nimcall.}
proc addListener*(pointer: ptr Pointer; listener: ptr PointerListener; data: pointer): int {.inline.} =
  cast[ptr Proxy](pointer).add_listener(listener, data)

proc setUserData*(pointer: ptr Pointer; userData: pointer) {.inline.} =
  cast[ptr Proxy](pointer).set_user_data(user_data)
proc getUserData*(pointer: ptr Pointer): pointer {.inline.} =
  cast[ptr Proxy](pointer).get_user_data()
proc getVersion*(pointer: ptr Pointer): uint32 {.inline.} =
  cast[ptr Proxy](pointer).get_version()
proc destroy*(pointer: ptr Pointer) {.inline.} =
  destroy cast[ptr Proxy](pointer)
proc setCursor*(pointer: ptr Pointer; serial: uint32; surface: ptr Surface; hotspotX: int32; hotspotY: int32) {.inline.} =
  ## set the pointer surface
  ## 
  ## Set the pointer surface, i.e., the surface that contains the
  ## 	pointer image (cursor). This request gives the surface the role
  ## 	of a cursor. If the surface already has another role, it raises
  ## 	a protocol error.
  ## 
  ## 	The cursor actually changes only if the pointer
  ## 	focus for this device is one of the requesting client's surfaces
  ## 	or the surface parameter is the current pointer surface. If
  ## 	there was a previous surface set with this request it is
  ## 	replaced. If surface is NULL, the pointer image is hidden.
  ## 
  ## 	The parameters hotspot_x and hotspot_y define the position of
  ## 	the pointer surface relative to the pointer location. Its
  ## 	top-left corner is always at (x, y) - (hotspot_x, hotspot_y),
  ## 	where (x, y) are the coordinates of the pointer location, in
  ## 	surface-local coordinates.
  ## 
  ## 	On wl_surface.offset requests to the pointer surface, hotspot_x
  ## 	and hotspot_y are decremented by the x and y parameters
  ## 	passed to the request. The offset must be applied by
  ## 	wl_surface.commit as usual.
  ## 
  ## 	The hotspot can also be updated by passing the currently set
  ## 	pointer surface to this request with new values for hotspot_x
  ## 	and hotspot_y.
  ## 
  ## 	The input region is ignored for wl_surfaces with the role of
  ## 	a cursor. When the use as a cursor ends, the wl_surface is
  ## 	unmapped.
  ## 
  ## 	The serial parameter must match the latest wl_pointer.enter
  ## 	serial number sent to the client. Otherwise the request will be
  ## 	ignored.
  ## 
  cast[ptr Proxy](pointer).marshal_flags(PointerRequest_set_cursor.ord, nil, cast[ptr Proxy](pointer).get_version(), 0, serial, surface, hotspotX, hotspotY)
proc release*(pointer: ptr Pointer) {.inline.} =
  ## release the pointer object
  ## 
  ## Using this request a client can tell the server that it is not going to
  ## 	use the pointer object anymore.
  ## 
  ## 	This request destroys the pointer proxy object, so clients must not call
  ## 	wl_pointer_destroy() after using this request.
  ## 
  cast[ptr Proxy](pointer).marshal_flags(PointerRequest_release.ord, nil, cast[ptr Proxy](pointer).get_version(), WL_MARSHAL_FLAG_DESTROY)
type KeyboardListener* = object
  keymap*: proc(
    data: pointer;
    keyboard: ptr Keyboard;
    format: uint32;
    fd: int32;
    size: uint32;
  ) {.nimcall.}
  enter*: proc(
    data: pointer;
    keyboard: ptr Keyboard;
    serial: uint32;
    surface: ptr Surface;
    keys: ptr Array;
  ) {.nimcall.}
  leave*: proc(
    data: pointer;
    keyboard: ptr Keyboard;
    serial: uint32;
    surface: ptr Surface;
  ) {.nimcall.}
  key*: proc(
    data: pointer;
    keyboard: ptr Keyboard;
    serial: uint32;
    time: uint32;
    key: uint32;
    state: uint32;
  ) {.nimcall.}
  modifiers*: proc(
    data: pointer;
    keyboard: ptr Keyboard;
    serial: uint32;
    modsDepressed: uint32;
    modsLatched: uint32;
    modsLocked: uint32;
    group: uint32;
  ) {.nimcall.}
  repeatInfo*: proc(
    data: pointer;
    keyboard: ptr Keyboard;
    rate: int32;
    delay: int32;
  ) {.nimcall.}
proc addListener*(keyboard: ptr Keyboard; listener: ptr KeyboardListener; data: pointer): int {.inline.} =
  cast[ptr Proxy](keyboard).add_listener(listener, data)

proc setUserData*(keyboard: ptr Keyboard; userData: pointer) {.inline.} =
  cast[ptr Proxy](keyboard).set_user_data(user_data)
proc getUserData*(keyboard: ptr Keyboard): pointer {.inline.} =
  cast[ptr Proxy](keyboard).get_user_data()
proc getVersion*(keyboard: ptr Keyboard): uint32 {.inline.} =
  cast[ptr Proxy](keyboard).get_version()
proc destroy*(keyboard: ptr Keyboard) {.inline.} =
  destroy cast[ptr Proxy](keyboard)
proc release*(keyboard: ptr Keyboard) {.inline.} =
  ## release the keyboard object
  cast[ptr Proxy](keyboard).marshal_flags(KeyboardRequest_release.ord, nil, cast[ptr Proxy](keyboard).get_version(), WL_MARSHAL_FLAG_DESTROY)
type TouchListener* = object
  down*: proc(
    data: pointer;
    touch: ptr Touch;
    serial: uint32;
    time: uint32;
    surface: ptr Surface;
    id: int32;
    x: Fixed;
    y: Fixed;
  ) {.nimcall.}
  up*: proc(
    data: pointer;
    touch: ptr Touch;
    serial: uint32;
    time: uint32;
    id: int32;
  ) {.nimcall.}
  motion*: proc(
    data: pointer;
    touch: ptr Touch;
    time: uint32;
    id: int32;
    x: Fixed;
    y: Fixed;
  ) {.nimcall.}
  frame*: proc(
    data: pointer;
    touch: ptr Touch;
  ) {.nimcall.}
  cancel*: proc(
    data: pointer;
    touch: ptr Touch;
  ) {.nimcall.}
  shape*: proc(
    data: pointer;
    touch: ptr Touch;
    id: int32;
    major: Fixed;
    minor: Fixed;
  ) {.nimcall.}
  orientation*: proc(
    data: pointer;
    touch: ptr Touch;
    id: int32;
    orientation: Fixed;
  ) {.nimcall.}
proc addListener*(touch: ptr Touch; listener: ptr TouchListener; data: pointer): int {.inline.} =
  cast[ptr Proxy](touch).add_listener(listener, data)

proc setUserData*(touch: ptr Touch; userData: pointer) {.inline.} =
  cast[ptr Proxy](touch).set_user_data(user_data)
proc getUserData*(touch: ptr Touch): pointer {.inline.} =
  cast[ptr Proxy](touch).get_user_data()
proc getVersion*(touch: ptr Touch): uint32 {.inline.} =
  cast[ptr Proxy](touch).get_version()
proc destroy*(touch: ptr Touch) {.inline.} =
  destroy cast[ptr Proxy](touch)
proc release*(touch: ptr Touch) {.inline.} =
  ## release the touch object
  cast[ptr Proxy](touch).marshal_flags(TouchRequest_release.ord, nil, cast[ptr Proxy](touch).get_version(), WL_MARSHAL_FLAG_DESTROY)
type OutputListener* = object
  geometry*: proc(
    data: pointer;
    output: ptr Output;
    x: int32;
    y: int32;
    physicalWidth: int32;
    physicalHeight: int32;
    subpixel: int32;
    make: cstring;
    model: cstring;
    transform: int32;
  ) {.nimcall.}
  mode*: proc(
    data: pointer;
    output: ptr Output;
    flags: uint32;
    width: int32;
    height: int32;
    refresh: int32;
  ) {.nimcall.}
  done*: proc(
    data: pointer;
    output: ptr Output;
  ) {.nimcall.}
  scale*: proc(
    data: pointer;
    output: ptr Output;
    factor: int32;
  ) {.nimcall.}
  name*: proc(
    data: pointer;
    output: ptr Output;
    name: cstring;
  ) {.nimcall.}
  description*: proc(
    data: pointer;
    output: ptr Output;
    description: cstring;
  ) {.nimcall.}
proc addListener*(output: ptr Output; listener: ptr OutputListener; data: pointer): int {.inline.} =
  cast[ptr Proxy](output).add_listener(listener, data)

proc setUserData*(output: ptr Output; userData: pointer) {.inline.} =
  cast[ptr Proxy](output).set_user_data(user_data)
proc getUserData*(output: ptr Output): pointer {.inline.} =
  cast[ptr Proxy](output).get_user_data()
proc getVersion*(output: ptr Output): uint32 {.inline.} =
  cast[ptr Proxy](output).get_version()
proc destroy*(output: ptr Output) {.inline.} =
  destroy cast[ptr Proxy](output)
proc release*(output: ptr Output) {.inline.} =
  ## release the output object
  ## 
  ## Using this request a client can tell the server that it is not going to
  ## 	use the output object anymore.
  ## 
  cast[ptr Proxy](output).marshal_flags(OutputRequest_release.ord, nil, cast[ptr Proxy](output).get_version(), WL_MARSHAL_FLAG_DESTROY)
proc setUserData*(region: ptr Region; userData: pointer) {.inline.} =
  cast[ptr Proxy](region).set_user_data(user_data)
proc getUserData*(region: ptr Region): pointer {.inline.} =
  cast[ptr Proxy](region).get_user_data()
proc getVersion*(region: ptr Region): uint32 {.inline.} =
  cast[ptr Proxy](region).get_version()
proc destroy*(region: ptr Region) {.inline.} =
  ## destroy region
  ## 
  ## Destroy the region.  This will invalidate the object ID.
  ## 
  cast[ptr Proxy](region).marshal_flags(RegionRequest_destroy.ord, nil, cast[ptr Proxy](region).get_version(), WL_MARSHAL_FLAG_DESTROY)
proc add*(region: ptr Region; x: int32; y: int32; width: int32; height: int32) {.inline.} =
  ## add rectangle to region
  ## 
  ## Add the specified rectangle to the region.
  ## 
  cast[ptr Proxy](region).marshal_flags(RegionRequest_add.ord, nil, cast[ptr Proxy](region).get_version(), 0, x, y, width, height)
proc subtract*(region: ptr Region; x: int32; y: int32; width: int32; height: int32) {.inline.} =
  ## subtract rectangle from region
  ## 
  ## Subtract the specified rectangle from the region.
  ## 
  cast[ptr Proxy](region).marshal_flags(RegionRequest_subtract.ord, nil, cast[ptr Proxy](region).get_version(), 0, x, y, width, height)
proc setUserData*(subcompositor: ptr Subcompositor; userData: pointer) {.inline.} =
  cast[ptr Proxy](subcompositor).set_user_data(user_data)
proc getUserData*(subcompositor: ptr Subcompositor): pointer {.inline.} =
  cast[ptr Proxy](subcompositor).get_user_data()
proc getVersion*(subcompositor: ptr Subcompositor): uint32 {.inline.} =
  cast[ptr Proxy](subcompositor).get_version()
proc destroy*(subcompositor: ptr Subcompositor) {.inline.} =
  ## unbind from the subcompositor interface
  ## 
  ## Informs the server that the client will not be using this
  ## 	protocol object anymore. This does not affect any other
  ## 	objects, wl_subsurface objects included.
  ## 
  cast[ptr Proxy](subcompositor).marshal_flags(SubcompositorRequest_destroy.ord, nil, cast[ptr Proxy](subcompositor).get_version(), WL_MARSHAL_FLAG_DESTROY)
proc getSubsurface*(subcompositor: ptr Subcompositor; surface: ptr Surface; parent: ptr Surface): ptr Subsurface {.inline.} =
  ## give a surface the role sub-surface
  ## 
  ## Create a sub-surface interface for the given surface, and
  ## 	associate it with the given parent surface. This turns a
  ## 	plain wl_surface into a sub-surface.
  ## 
  ## 	The to-be sub-surface must not already have another role, and it
  ## 	must not have an existing wl_subsurface object. Otherwise the
  ## 	bad_surface protocol error is raised.
  ## 
  ## 	Adding sub-surfaces to a parent is a double-buffered operation on the
  ## 	parent (see wl_surface.commit). The effect of adding a sub-surface
  ## 	becomes visible on the next time the state of the parent surface is
  ## 	applied.
  ## 
  ## 	The parent surface must not be one of the child surface's descendants,
  ## 	and the parent must be different from the child surface, otherwise the
  ## 	bad_parent protocol error is raised.
  ## 
  ## 	This request modifies the behaviour of wl_surface.commit request on
  ## 	the sub-surface, see the documentation on wl_subsurface interface.
  ## 
  cast[ptr Subsurface](cast[ptr Proxy](subcompositor).marshal_flags(SubcompositorRequest_get_subsurface.ord, addr wl_subsurface_interface, cast[ptr Proxy](subcompositor).get_version(), 0, nil, surface, parent))
proc setUserData*(subsurface: ptr Subsurface; userData: pointer) {.inline.} =
  cast[ptr Proxy](subsurface).set_user_data(user_data)
proc getUserData*(subsurface: ptr Subsurface): pointer {.inline.} =
  cast[ptr Proxy](subsurface).get_user_data()
proc getVersion*(subsurface: ptr Subsurface): uint32 {.inline.} =
  cast[ptr Proxy](subsurface).get_version()
proc destroy*(subsurface: ptr Subsurface) {.inline.} =
  ## remove sub-surface interface
  ## 
  ## The sub-surface interface is removed from the wl_surface object
  ## 	that was turned into a sub-surface with a
  ## 	wl_subcompositor.get_subsurface request. The wl_surface's association
  ## 	to the parent is deleted. The wl_surface is unmapped immediately.
  ## 
  cast[ptr Proxy](subsurface).marshal_flags(SubsurfaceRequest_destroy.ord, nil, cast[ptr Proxy](subsurface).get_version(), WL_MARSHAL_FLAG_DESTROY)
proc setPosition*(subsurface: ptr Subsurface; x: int32; y: int32) {.inline.} =
  ## reposition the sub-surface
  ## 
  ## This schedules a sub-surface position change.
  ## 	The sub-surface will be moved so that its origin (top left
  ## 	corner pixel) will be at the location x, y of the parent surface
  ## 	coordinate system. The coordinates are not restricted to the parent
  ## 	surface area. Negative values are allowed.
  ## 
  ## 	The scheduled coordinates will take effect whenever the state of the
  ## 	parent surface is applied.
  ## 
  ## 	If more than one set_position request is invoked by the client before
  ## 	the commit of the parent surface, the position of a new request always
  ## 	replaces the scheduled position from any previous request.
  ## 
  ## 	The initial position is 0, 0.
  ## 
  cast[ptr Proxy](subsurface).marshal_flags(SubsurfaceRequest_set_position.ord, nil, cast[ptr Proxy](subsurface).get_version(), 0, x, y)
proc placeAbove*(subsurface: ptr Subsurface; sibling: ptr Surface) {.inline.} =
  ## restack the sub-surface
  ## 
  ## This sub-surface is taken from the stack, and put back just
  ## 	above the reference surface, changing the z-order of the sub-surfaces.
  ## 	The reference surface must be one of the sibling surfaces, or the
  ## 	parent surface. Using any other surface, including this sub-surface,
  ## 	will cause a protocol error.
  ## 
  ## 	The z-order is double-buffered. Requests are handled in order and
  ## 	applied immediately to a pending state. The final pending state is
  ## 	copied to the active state the next time the state of the parent
  ## 	surface is applied.
  ## 
  ## 	A new sub-surface is initially added as the top-most in the stack
  ## 	of its siblings and parent.
  ## 
  cast[ptr Proxy](subsurface).marshal_flags(SubsurfaceRequest_place_above.ord, nil, cast[ptr Proxy](subsurface).get_version(), 0, sibling)
proc placeBelow*(subsurface: ptr Subsurface; sibling: ptr Surface) {.inline.} =
  ## restack the sub-surface
  ## 
  ## The sub-surface is placed just below the reference surface.
  ## 	See wl_subsurface.place_above.
  ## 
  cast[ptr Proxy](subsurface).marshal_flags(SubsurfaceRequest_place_below.ord, nil, cast[ptr Proxy](subsurface).get_version(), 0, sibling)
proc setSync*(subsurface: ptr Subsurface) {.inline.} =
  ## set sub-surface to synchronized mode
  ## 
  ## Change the commit behaviour of the sub-surface to synchronized
  ## 	mode, also described as the parent dependent mode.
  ## 
  ## 	In synchronized mode, wl_surface.commit on a sub-surface will
  ## 	accumulate the committed state in a cache, but the state will
  ## 	not be applied and hence will not change the compositor output.
  ## 	The cached state is applied to the sub-surface immediately after
  ## 	the parent surface's state is applied. This ensures atomic
  ## 	updates of the parent and all its synchronized sub-surfaces.
  ## 	Applying the cached state will invalidate the cache, so further
  ## 	parent surface commits do not (re-)apply old state.
  ## 
  ## 	See wl_subsurface for the recursive effect of this mode.
  ## 
  cast[ptr Proxy](subsurface).marshal_flags(SubsurfaceRequest_set_sync.ord, nil, cast[ptr Proxy](subsurface).get_version(), 0)
proc setDesync*(subsurface: ptr Subsurface) {.inline.} =
  ## set sub-surface to desynchronized mode
  ## 
  ## Change the commit behaviour of the sub-surface to desynchronized
  ## 	mode, also described as independent or freely running mode.
  ## 
  ## 	In desynchronized mode, wl_surface.commit on a sub-surface will
  ## 	apply the pending state directly, without caching, as happens
  ## 	normally with a wl_surface. Calling wl_surface.commit on the
  ## 	parent surface has no effect on the sub-surface's wl_surface
  ## 	state. This mode allows a sub-surface to be updated on its own.
  ## 
  ## 	If cached state exists when wl_surface.commit is called in
  ## 	desynchronized mode, the pending state is added to the cached
  ## 	state, and applied as a whole. This invalidates the cache.
  ## 
  ## 	Note: even if a sub-surface is set to desynchronized, a parent
  ## 	sub-surface may override it to behave as synchronized. For details,
  ## 	see wl_subsurface.
  ## 
  ## 	If a surface's parent surface behaves as desynchronized, then
  ## 	the cached state is applied on set_desync.
  ## 
  cast[ptr Proxy](subsurface).marshal_flags(SubsurfaceRequest_set_desync.ord, nil, cast[ptr Proxy](subsurface).get_version(), 0)
