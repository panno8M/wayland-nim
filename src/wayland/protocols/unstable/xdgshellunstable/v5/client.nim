# Generated by wayland-nim-scanner 1.23.1
{.warning[UnusedImport]:off.}
import wayland/native/client
import wayland/native/common
import code
export code

## The xdg_shell_unstable_v5 CLIENT protocol
## #########################################
## 
## Interfaces
## ==========
## 
## * xdg_shell
## * xdg_surface
## * xdg_popup
## 
## Copyright
## =========
## 
## Copyright © 2008-2013 Kristian Høgsberg
## Copyright © 2013      Rafael Antognolli
## Copyright © 2013      Jasper St. Pierre
## Copyright © 2010-2013 Intel Corporation
## 
## Permission is hereby granted, free of charge, to any person obtaining a
## copy of this software and associated documentation files (the "Software"),
## to deal in the Software without restriction, including without limitation
## the rights to use, copy, modify, merge, publish, distribute, sublicense,
## and/or sell copies of the Software, and to permit persons to whom the
## Software is furnished to do so, subject to the following conditions:
## 
## The above copyright notice and this permission notice (including the next
## paragraph) shall be included in all copies or substantial portions of the
## Software.
## 
## THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
## IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
## FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
## THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
## LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
## FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
## DEALINGS IN THE SOFTWARE.
## 

type XdgShellListener* = object
  ping*: proc(
    data: pointer;
    xdgShell: ptr XdgShell;
    serial: uint32;
  ) {.nimcall.}
proc addListener*(xdgShell: ptr XdgShell; listener: ptr XdgShellListener; data: pointer): int {.inline.} =
  cast[ptr Proxy](xdgShell).add_listener(listener, data)

proc setUserData*(xdgShell: ptr XdgShell; userData: pointer) {.inline.} =
  cast[ptr Proxy](xdgShell).set_user_data(user_data)
proc getUserData*(xdgShell: ptr XdgShell): pointer {.inline.} =
  cast[ptr Proxy](xdgShell).get_user_data()
proc getVersion*(xdgShell: ptr XdgShell): uint32 {.inline.} =
  cast[ptr Proxy](xdgShell).get_version()
proc destroy*(xdgShell: ptr XdgShell) {.inline.} =
  ## destroy xdg_shell
  ## 
  ## Destroy this xdg_shell object.
  ## 
  ## Destroying a bound xdg_shell object while there are surfaces
  ## still alive created by this xdg_shell object instance is illegal
  ## and will result in a protocol error.
  ## 
  cast[ptr Proxy](xdgShell).marshal_flags(XdgShellRequest_destroy.ord, nil, cast[ptr Proxy](xdgShell).get_version(), WL_MARSHAL_FLAG_DESTROY)
proc useUnstableVersion*(xdgShell: ptr XdgShell; version: int32) {.inline.} =
  ## enable use of this unstable version
  ## 
  ## Negotiate the unstable version of the interface.  This
  ## 	mechanism is in place to ensure client and server agree on the
  ## 	unstable versions of the protocol that they speak or exit
  ## 	cleanly if they don't agree.  This request will go away once
  ## 	the xdg-shell protocol is stable.
  ## 
  cast[ptr Proxy](xdgShell).marshal_flags(XdgShellRequest_use_unstable_version.ord, nil, cast[ptr Proxy](xdgShell).get_version(), 0, version)
proc getXdgSurface*(xdgShell: ptr XdgShell; surface: ptr Surface): ptr XdgSurface {.inline.} =
  ## create a shell surface from a surface
  ## 
  ## This creates an xdg_surface for the given surface and gives it the
  ## 	xdg_surface role. A wl_surface can only be given an xdg_surface role
  ## 	once. If get_xdg_surface is called with a wl_surface that already has
  ## 	an active xdg_surface associated with it, or if it had any other role,
  ## 	an error is raised.
  ## 
  ## 	See the documentation of xdg_surface for more details about what an
  ## 	xdg_surface is and how it is used.
  ## 
  cast[ptr XdgSurface](cast[ptr Proxy](xdgShell).marshal_flags(XdgShellRequest_get_xdg_surface.ord, addr xdg_surface_interface, cast[ptr Proxy](xdgShell).get_version(), 0, nil, surface))
proc getXdgPopup*(xdgShell: ptr XdgShell; surface: ptr Surface; parent: ptr Surface; seat: ptr Seat; serial: uint32; x: int32; y: int32): ptr XdgPopup {.inline.} =
  ## create a popup for a surface
  ## 
  ## This creates an xdg_popup for the given surface and gives it the
  ## 	xdg_popup role. A wl_surface can only be given an xdg_popup role
  ## 	once. If get_xdg_popup is called with a wl_surface that already has
  ## 	an active xdg_popup associated with it, or if it had any other role,
  ## 	an error is raised.
  ## 
  ## 	This request must be used in response to some sort of user action
  ## 	like a button press, key press, or touch down event.
  ## 
  ## 	See the documentation of xdg_popup for more details about what an
  ## 	xdg_popup is and how it is used.
  ## 
  cast[ptr XdgPopup](cast[ptr Proxy](xdgShell).marshal_flags(XdgShellRequest_get_xdg_popup.ord, addr xdg_popup_interface, cast[ptr Proxy](xdgShell).get_version(), 0, nil, surface, parent, seat, serial, x, y))
proc pong*(xdgShell: ptr XdgShell; serial: uint32) {.inline.} =
  ## respond to a ping event
  ## 
  ## A client must respond to a ping event with a pong request or
  ## 	the client may be deemed unresponsive.
  ## 
  cast[ptr Proxy](xdgShell).marshal_flags(XdgShellRequest_pong.ord, nil, cast[ptr Proxy](xdgShell).get_version(), 0, serial)
type XdgSurfaceListener* = object
  configure*: proc(
    data: pointer;
    xdgSurface: ptr XdgSurface;
    width: int32;
    height: int32;
    states: ptr Array;
    serial: uint32;
  ) {.nimcall.}
  close*: proc(
    data: pointer;
    xdgSurface: ptr XdgSurface;
  ) {.nimcall.}
proc addListener*(xdgSurface: ptr XdgSurface; listener: ptr XdgSurfaceListener; data: pointer): int {.inline.} =
  cast[ptr Proxy](xdgSurface).add_listener(listener, data)

proc setUserData*(xdgSurface: ptr XdgSurface; userData: pointer) {.inline.} =
  cast[ptr Proxy](xdgSurface).set_user_data(user_data)
proc getUserData*(xdgSurface: ptr XdgSurface): pointer {.inline.} =
  cast[ptr Proxy](xdgSurface).get_user_data()
proc getVersion*(xdgSurface: ptr XdgSurface): uint32 {.inline.} =
  cast[ptr Proxy](xdgSurface).get_version()
proc destroy*(xdgSurface: ptr XdgSurface) {.inline.} =
  ## Destroy the xdg_surface
  ## 
  ## Unmap and destroy the window. The window will be effectively
  ## 	hidden from the user's point of view, and all state like
  ## 	maximization, fullscreen, and so on, will be lost.
  ## 
  cast[ptr Proxy](xdgSurface).marshal_flags(XdgSurfaceRequest_destroy.ord, nil, cast[ptr Proxy](xdgSurface).get_version(), WL_MARSHAL_FLAG_DESTROY)
proc setParent*(xdgSurface: ptr XdgSurface; parent: ptr XdgSurface) {.inline.} =
  ## set the parent of this surface
  ## 
  ## Set the "parent" of this surface. This window should be stacked
  ## 	above a parent. The parent surface must be mapped as long as this
  ## 	surface is mapped.
  ## 
  ## 	Parent windows should be set on dialogs, toolboxes, or other
  ## 	"auxiliary" surfaces, so that the parent is raised when the dialog
  ## 	is raised.
  ## 
  cast[ptr Proxy](xdgSurface).marshal_flags(XdgSurfaceRequest_set_parent.ord, nil, cast[ptr Proxy](xdgSurface).get_version(), 0, parent)
proc setTitle*(xdgSurface: ptr XdgSurface; title: cstring) {.inline.} =
  ## set surface title
  ## 
  ## Set a short title for the surface.
  ## 
  ## 	This string may be used to identify the surface in a task bar,
  ## 	window list, or other user interface elements provided by the
  ## 	compositor.
  ## 
  ## 	The string must be encoded in UTF-8.
  ## 
  cast[ptr Proxy](xdgSurface).marshal_flags(XdgSurfaceRequest_set_title.ord, nil, cast[ptr Proxy](xdgSurface).get_version(), 0, title)
proc setAppId*(xdgSurface: ptr XdgSurface; appId: cstring) {.inline.} =
  ## set application ID
  ## 
  ## Set an application identifier for the surface.
  ## 
  ## 	The app ID identifies the general class of applications to which
  ## 	the surface belongs. The compositor can use this to group multiple
  ## 	surfaces together, or to determine how to launch a new application.
  ## 
  ## 	For D-Bus activatable applications, the app ID is used as the D-Bus
  ## 	service name.
  ## 
  ## 	The compositor shell will try to group application surfaces together
  ## 	by their app ID.  As a best practice, it is suggested to select app
  ## 	ID's that match the basename of the application's .desktop file.
  ## 	For example, "org.freedesktop.FooViewer" where the .desktop file is
  ## 	"org.freedesktop.FooViewer.desktop".
  ## 
  ## 	See the desktop-entry specification [0] for more details on
  ## 	application identifiers and how they relate to well-known D-Bus
  ## 	names and .desktop files.
  ## 
  ## 	[0] http://standards.freedesktop.org/desktop-entry-spec/
  ## 
  cast[ptr Proxy](xdgSurface).marshal_flags(XdgSurfaceRequest_set_app_id.ord, nil, cast[ptr Proxy](xdgSurface).get_version(), 0, appId)
proc showWindowMenu*(xdgSurface: ptr XdgSurface; seat: ptr Seat; serial: uint32; x: int32; y: int32) {.inline.} =
  ## show the window menu
  ## 
  ## Clients implementing client-side decorations might want to show
  ## a context menu when right-clicking on the decorations, giving the
  ## user a menu that they can use to maximize or minimize the window.
  ## 
  ## This request asks the compositor to pop up such a window menu at
  ## the given position, relative to the local surface coordinates of
  ## the parent surface. There are no guarantees as to what menu items
  ## the window menu contains.
  ## 
  ## This request must be used in response to some sort of user action
  ## like a button press, key press, or touch down event.
  ## 
  cast[ptr Proxy](xdgSurface).marshal_flags(XdgSurfaceRequest_show_window_menu.ord, nil, cast[ptr Proxy](xdgSurface).get_version(), 0, seat, serial, x, y)
proc move*(xdgSurface: ptr XdgSurface; seat: ptr Seat; serial: uint32) {.inline.} =
  ## start an interactive move
  ## 
  ## Start an interactive, user-driven move of the surface.
  ## 
  ## 	This request must be used in response to some sort of user action
  ## 	like a button press, key press, or touch down event. The passed
  ## 	serial is used to determine the type of interactive move (touch,
  ## 	pointer, etc).
  ## 
  ## 	The server may ignore move requests depending on the state of
  ## 	the surface (e.g. fullscreen or maximized), or if the passed serial
  ## 	is no longer valid.
  ## 
  ## 	If triggered, the surface will lose the focus of the device
  ## 	(wl_pointer, wl_touch, etc) used for the move. It is up to the
  ## 	compositor to visually indicate that the move is taking place, such as
  ## 	updating a pointer cursor, during the move. There is no guarantee
  ## 	that the device focus will return when the move is completed.
  ## 
  cast[ptr Proxy](xdgSurface).marshal_flags(XdgSurfaceRequest_move.ord, nil, cast[ptr Proxy](xdgSurface).get_version(), 0, seat, serial)
proc resize*(xdgSurface: ptr XdgSurface; seat: ptr Seat; serial: uint32; edges: uint32) {.inline.} =
  ## start an interactive resize
  ## 
  ## Start a user-driven, interactive resize of the surface.
  ## 
  ## 	This request must be used in response to some sort of user action
  ## 	like a button press, key press, or touch down event. The passed
  ## 	serial is used to determine the type of interactive resize (touch,
  ## 	pointer, etc).
  ## 
  ## 	The server may ignore resize requests depending on the state of
  ## 	the surface (e.g. fullscreen or maximized).
  ## 
  ## 	If triggered, the client will receive configure events with the
  ## 	"resize" state enum value and the expected sizes. See the "resize"
  ## 	enum value for more details about what is required. The client
  ## 	must also acknowledge configure events using "ack_configure". After
  ## 	the resize is completed, the client will receive another "configure"
  ## 	event without the resize state.
  ## 
  ## 	If triggered, the surface also will lose the focus of the device
  ## 	(wl_pointer, wl_touch, etc) used for the resize. It is up to the
  ## 	compositor to visually indicate that the resize is taking place,
  ## 	such as updating a pointer cursor, during the resize. There is no
  ## 	guarantee that the device focus will return when the resize is
  ## 	completed.
  ## 
  ## 	The edges parameter specifies how the surface should be resized,
  ## 	and is one of the values of the resize_edge enum. The compositor
  ## 	may use this information to update the surface position for
  ## 	example when dragging the top left corner. The compositor may also
  ## 	use this information to adapt its behavior, e.g. choose an
  ## 	appropriate cursor image.
  ## 
  cast[ptr Proxy](xdgSurface).marshal_flags(XdgSurfaceRequest_resize.ord, nil, cast[ptr Proxy](xdgSurface).get_version(), 0, seat, serial, edges)
proc ackConfigure*(xdgSurface: ptr XdgSurface; serial: uint32) {.inline.} =
  ## ack a configure event
  ## 
  ## When a configure event is received, if a client commits the
  ## surface in response to the configure event, then the client
  ## must make an ack_configure request sometime before the commit
  ## request, passing along the serial of the configure event.
  ## 
  ## For instance, the compositor might use this information to move
  ## a surface to the top left only when the client has drawn itself
  ## for the maximized or fullscreen state.
  ## 
  ## If the client receives multiple configure events before it
  ## can respond to one, it only has to ack the last configure event.
  ## 
  ## A client is not required to commit immediately after sending
  ## an ack_configure request - it may even ack_configure several times
  ## before its next surface commit.
  ## 
  ## The compositor expects that the most recently received
  ## ack_configure request at the time of a commit indicates which
  ## configure event the client is responding to.
  ## 
  cast[ptr Proxy](xdgSurface).marshal_flags(XdgSurfaceRequest_ack_configure.ord, nil, cast[ptr Proxy](xdgSurface).get_version(), 0, serial)
proc setWindowGeometry*(xdgSurface: ptr XdgSurface; x: int32; y: int32; width: int32; height: int32) {.inline.} =
  ## set the new window geometry
  ## 
  ## The window geometry of a window is its "visible bounds" from the
  ## user's perspective. Client-side decorations often have invisible
  ## portions like drop-shadows which should be ignored for the
  ## purposes of aligning, placing and constraining windows.
  ## 
  ## The window geometry is double-buffered state, see wl_surface.commit.
  ## 
  ## Once the window geometry of the surface is set once, it is not
  ## possible to unset it, and it will remain the same until
  ## set_window_geometry is called again, even if a new subsurface or
  ## buffer is attached.
  ## 
  ## If never set, the value is the full bounds of the surface,
  ## including any subsurfaces. This updates dynamically on every
  ## commit. This unset mode is meant for extremely simple clients.
  ## 
  ## If responding to a configure event, the window geometry in here
  ## must respect the sizing negotiations specified by the states in
  ## the configure event.
  ## 
  ## The arguments are given in the surface local coordinate space of
  ## the wl_surface associated with this xdg_surface.
  ## 
  ## The width and height must be greater than zero.
  ## 
  cast[ptr Proxy](xdgSurface).marshal_flags(XdgSurfaceRequest_set_window_geometry.ord, nil, cast[ptr Proxy](xdgSurface).get_version(), 0, x, y, width, height)
proc setMaximized*(xdgSurface: ptr XdgSurface) {.inline.} =
  ## maximize the window
  ## 
  ## Maximize the surface.
  ## 
  ## After requesting that the surface should be maximized, the compositor
  ## will respond by emitting a configure event with the "maximized" state
  ## and the required window geometry. The client should then update its
  ## content, drawing it in a maximized state, i.e. without shadow or other
  ## decoration outside of the window geometry. The client must also
  ## acknowledge the configure when committing the new content (see
  ## ack_configure).
  ## 
  ## It is up to the compositor to decide how and where to maximize the
  ## surface, for example which output and what region of the screen should
  ## be used.
  ## 
  ## If the surface was already maximized, the compositor will still emit
  ## a configure event with the "maximized" state.
  ## 
  ## Note that unrelated compositor side state changes may cause
  ## configure events to be emitted at any time, meaning trying to
  ## match this request to a specific future configure event is
  ## futile.
  ## 
  cast[ptr Proxy](xdgSurface).marshal_flags(XdgSurfaceRequest_set_maximized.ord, nil, cast[ptr Proxy](xdgSurface).get_version(), 0)
proc unsetMaximized*(xdgSurface: ptr XdgSurface) {.inline.} =
  ## unmaximize the window
  ## 
  ## Unmaximize the surface.
  ## 
  ## After requesting that the surface should be unmaximized, the compositor
  ## will respond by emitting a configure event without the "maximized"
  ## state. If available, the compositor will include the window geometry
  ## dimensions the window had prior to being maximized in the configure
  ## request. The client must then update its content, drawing it in a
  ## regular state, i.e. potentially with shadow, etc. The client must also
  ## acknowledge the configure when committing the new content (see
  ## ack_configure).
  ## 
  ## It is up to the compositor to position the surface after it was
  ## unmaximized; usually the position the surface had before maximizing, if
  ## applicable.
  ## 
  ## If the surface was already not maximized, the compositor will still
  ## emit a configure event without the "maximized" state.
  ## 
  ## Note that unrelated compositor side state changes may cause
  ## configure events to be emitted at any time, meaning trying to
  ## match this request to a specific future configure event is
  ## futile.
  ## 
  cast[ptr Proxy](xdgSurface).marshal_flags(XdgSurfaceRequest_unset_maximized.ord, nil, cast[ptr Proxy](xdgSurface).get_version(), 0)
proc setFullscreen*(xdgSurface: ptr XdgSurface; output: ptr Output) {.inline.} =
  ## set the window as fullscreen on a monitor
  ## 
  ## Make the surface fullscreen.
  ## 
  ## You can specify an output that you would prefer to be fullscreen.
  ## 	If this value is NULL, it's up to the compositor to choose which
  ## display will be used to map this surface.
  ## 
  ## If the surface doesn't cover the whole output, the compositor will
  ## position the surface in the center of the output and compensate with
  ## black borders filling the rest of the output.
  ## 
  cast[ptr Proxy](xdgSurface).marshal_flags(XdgSurfaceRequest_set_fullscreen.ord, nil, cast[ptr Proxy](xdgSurface).get_version(), 0, output)
proc unsetFullscreen*(xdgSurface: ptr XdgSurface) {.inline.} =
  cast[ptr Proxy](xdgSurface).marshal_flags(XdgSurfaceRequest_unset_fullscreen.ord, nil, cast[ptr Proxy](xdgSurface).get_version(), 0)
proc setMinimized*(xdgSurface: ptr XdgSurface) {.inline.} =
  ## set the window as minimized
  ## 
  ## Request that the compositor minimize your surface. There is no
  ## 	way to know if the surface is currently minimized, nor is there
  ## 	any way to unset minimization on this surface.
  ## 
  ## 	If you are looking to throttle redrawing when minimized, please
  ## 	instead use the wl_surface.frame event for this, as this will
  ## 	also work with live previews on windows in Alt-Tab, Expose or
  ## 	similar compositor features.
  ## 
  cast[ptr Proxy](xdgSurface).marshal_flags(XdgSurfaceRequest_set_minimized.ord, nil, cast[ptr Proxy](xdgSurface).get_version(), 0)
type XdgPopupListener* = object
  popupDone*: proc(
    data: pointer;
    xdgPopup: ptr XdgPopup;
  ) {.nimcall.}
proc addListener*(xdgPopup: ptr XdgPopup; listener: ptr XdgPopupListener; data: pointer): int {.inline.} =
  cast[ptr Proxy](xdgPopup).add_listener(listener, data)

proc setUserData*(xdgPopup: ptr XdgPopup; userData: pointer) {.inline.} =
  cast[ptr Proxy](xdgPopup).set_user_data(user_data)
proc getUserData*(xdgPopup: ptr XdgPopup): pointer {.inline.} =
  cast[ptr Proxy](xdgPopup).get_user_data()
proc getVersion*(xdgPopup: ptr XdgPopup): uint32 {.inline.} =
  cast[ptr Proxy](xdgPopup).get_version()
proc destroy*(xdgPopup: ptr XdgPopup) {.inline.} =
  ## remove xdg_popup interface
  ## 
  ## This destroys the popup. Explicitly destroying the xdg_popup
  ## 	object will also dismiss the popup, and unmap the surface.
  ## 
  ## 	If this xdg_popup is not the "topmost" popup, a protocol error
  ## 	will be sent.
  ## 
  cast[ptr Proxy](xdgPopup).marshal_flags(XdgPopupRequest_destroy.ord, nil, cast[ptr Proxy](xdgPopup).get_version(), WL_MARSHAL_FLAG_DESTROY)
