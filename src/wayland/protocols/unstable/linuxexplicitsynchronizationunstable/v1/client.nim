# Generated by wayland-nim-scanner 1.23.1
{.warning[UnusedImport]:off.}
import wayland/native/client
import wayland/native/common
import code
export code

## The zwp_linux_explicit_synchronization_unstable_v1 CLIENT protocol
## ##################################################################
## 
## Interfaces
## ==========
## 
## * zwp_linux_explicit_synchronization_v1
## * zwp_linux_surface_synchronization_v1
## * zwp_linux_buffer_release_v1
## 
## Copyright
## =========
## 
## Copyright 2016 The Chromium Authors.
## Copyright 2017 Intel Corporation
## Copyright 2018 Collabora, Ltd
## 
## Permission is hereby granted, free of charge, to any person obtaining a
## copy of this software and associated documentation files (the "Software"),
## to deal in the Software without restriction, including without limitation
## the rights to use, copy, modify, merge, publish, distribute, sublicense,
## and/or sell copies of the Software, and to permit persons to whom the
## Software is furnished to do so, subject to the following conditions:
## 
## The above copyright notice and this permission notice (including the next
## paragraph) shall be included in all copies or substantial portions of the
## Software.
## 
## THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
## IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
## FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
## THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
## LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
## FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
## DEALINGS IN THE SOFTWARE.
## 

proc setUserData*(zwpLinuxExplicitSynchronizationV1: ptr ZwpLinuxExplicitSynchronizationV1; userData: pointer) {.inline.} =
  cast[ptr Proxy](zwpLinuxExplicitSynchronizationV1).set_user_data(user_data)
proc getUserData*(zwpLinuxExplicitSynchronizationV1: ptr ZwpLinuxExplicitSynchronizationV1): pointer {.inline.} =
  cast[ptr Proxy](zwpLinuxExplicitSynchronizationV1).get_user_data()
proc getVersion*(zwpLinuxExplicitSynchronizationV1: ptr ZwpLinuxExplicitSynchronizationV1): uint32 {.inline.} =
  cast[ptr Proxy](zwpLinuxExplicitSynchronizationV1).get_version()
proc destroy*(zwpLinuxExplicitSynchronizationV1: ptr ZwpLinuxExplicitSynchronizationV1) {.inline.} =
  ## destroy explicit synchronization factory object
  ## 
  ## Destroy this explicit synchronization factory object. Other objects,
  ## including zwp_linux_surface_synchronization_v1 objects created by this
  ## factory, shall not be affected by this request.
  ## 
  cast[ptr Proxy](zwpLinuxExplicitSynchronizationV1).marshal_flags(ZwpLinuxExplicitSynchronizationV1Request_destroy.ord, nil, cast[ptr Proxy](zwpLinuxExplicitSynchronizationV1).get_version(), WL_MARSHAL_FLAG_DESTROY)
proc getSynchronization*(zwpLinuxExplicitSynchronizationV1: ptr ZwpLinuxExplicitSynchronizationV1; surface: ptr Surface): ptr ZwpLinuxSurfaceSynchronizationV1 {.inline.} =
  ## extend surface interface for explicit synchronization
  ## 
  ## Instantiate an interface extension for the given wl_surface to provide
  ## explicit synchronization.
  ## 
  ## If the given wl_surface already has an explicit synchronization object
  ## associated, the synchronization_exists protocol error is raised.
  ## 
  ## Graphics APIs, like EGL or Vulkan, that manage the buffer queue and
  ## commits of a wl_surface themselves, are likely to be using this
  ## extension internally. If a client is using such an API for a
  ## wl_surface, it should not directly use this extension on that surface,
  ## to avoid raising a synchronization_exists protocol error.
  ## 
  cast[ptr ZwpLinuxSurfaceSynchronizationV1](cast[ptr Proxy](zwpLinuxExplicitSynchronizationV1).marshal_flags(ZwpLinuxExplicitSynchronizationV1Request_get_synchronization.ord, addr zwp_linux_surface_synchronization_v1_interface, cast[ptr Proxy](zwpLinuxExplicitSynchronizationV1).get_version(), 0, nil, surface))
proc setUserData*(zwpLinuxSurfaceSynchronizationV1: ptr ZwpLinuxSurfaceSynchronizationV1; userData: pointer) {.inline.} =
  cast[ptr Proxy](zwpLinuxSurfaceSynchronizationV1).set_user_data(user_data)
proc getUserData*(zwpLinuxSurfaceSynchronizationV1: ptr ZwpLinuxSurfaceSynchronizationV1): pointer {.inline.} =
  cast[ptr Proxy](zwpLinuxSurfaceSynchronizationV1).get_user_data()
proc getVersion*(zwpLinuxSurfaceSynchronizationV1: ptr ZwpLinuxSurfaceSynchronizationV1): uint32 {.inline.} =
  cast[ptr Proxy](zwpLinuxSurfaceSynchronizationV1).get_version()
proc destroy*(zwpLinuxSurfaceSynchronizationV1: ptr ZwpLinuxSurfaceSynchronizationV1) {.inline.} =
  ## destroy synchronization object
  ## 
  ## Destroy this explicit synchronization object.
  ## 
  ## Any fence set by this object with set_acquire_fence since the last
  ## commit will be discarded by the server. Any fences set by this object
  ## before the last commit are not affected.
  ## 
  ## zwp_linux_buffer_release_v1 objects created by this object are not
  ## affected by this request.
  ## 
  cast[ptr Proxy](zwpLinuxSurfaceSynchronizationV1).marshal_flags(ZwpLinuxSurfaceSynchronizationV1Request_destroy.ord, nil, cast[ptr Proxy](zwpLinuxSurfaceSynchronizationV1).get_version(), WL_MARSHAL_FLAG_DESTROY)
proc setAcquireFence*(zwpLinuxSurfaceSynchronizationV1: ptr ZwpLinuxSurfaceSynchronizationV1; fd: int32) {.inline.} =
  ## set the acquire fence
  ## 
  ## Set the acquire fence that must be signaled before the compositor
  ## may sample from the buffer attached with wl_surface.attach. The fence
  ## is a dma_fence kernel object.
  ## 
  ## The acquire fence is double-buffered state, and will be applied on the
  ## next wl_surface.commit request for the associated surface. Thus, it
  ## applies only to the buffer that is attached to the surface at commit
  ## time.
  ## 
  ## If the provided fd is not a valid dma_fence fd, then an INVALID_FENCE
  ## error is raised.
  ## 
  ## If a fence has already been attached during the same commit cycle, a
  ## DUPLICATE_FENCE error is raised.
  ## 
  ## If the associated wl_surface was destroyed, a NO_SURFACE error is
  ## raised.
  ## 
  ## If at surface commit time the attached buffer does not support explicit
  ## synchronization, an UNSUPPORTED_BUFFER error is raised.
  ## 
  ## If at surface commit time there is no buffer attached, a NO_BUFFER
  ## error is raised.
  ## 
  cast[ptr Proxy](zwpLinuxSurfaceSynchronizationV1).marshal_flags(ZwpLinuxSurfaceSynchronizationV1Request_set_acquire_fence.ord, nil, cast[ptr Proxy](zwpLinuxSurfaceSynchronizationV1).get_version(), 0, fd)
proc getRelease*(zwpLinuxSurfaceSynchronizationV1: ptr ZwpLinuxSurfaceSynchronizationV1): ptr ZwpLinuxBufferReleaseV1 {.inline.} =
  ## release fence for last-attached buffer
  ## 
  ## Create a listener for the release of the buffer attached by the
  ## client with wl_surface.attach. See zwp_linux_buffer_release_v1
  ## documentation for more information.
  ## 
  ## The release object is double-buffered state, and will be associated
  ## with the buffer that is attached to the surface at wl_surface.commit
  ## time.
  ## 
  ## If a zwp_linux_buffer_release_v1 object has already been requested for
  ## the surface in the same commit cycle, a DUPLICATE_RELEASE error is
  ## raised.
  ## 
  ## If the associated wl_surface was destroyed, a NO_SURFACE error
  ## is raised.
  ## 
  ## If at surface commit time there is no buffer attached, a NO_BUFFER
  ## error is raised.
  ## 
  cast[ptr ZwpLinuxBufferReleaseV1](cast[ptr Proxy](zwpLinuxSurfaceSynchronizationV1).marshal_flags(ZwpLinuxSurfaceSynchronizationV1Request_get_release.ord, addr zwp_linux_buffer_release_v1_interface, cast[ptr Proxy](zwpLinuxSurfaceSynchronizationV1).get_version(), 0, nil))
type ZwpLinuxBufferReleaseV1Listener* = object
  fencedRelease*: proc(
    data: pointer;
    zwpLinuxBufferReleaseV1: ptr ZwpLinuxBufferReleaseV1;
    fence: int32;
  ) {.nimcall.}
  immediateRelease*: proc(
    data: pointer;
    zwpLinuxBufferReleaseV1: ptr ZwpLinuxBufferReleaseV1;
  ) {.nimcall.}
proc addListener*(zwpLinuxBufferReleaseV1: ptr ZwpLinuxBufferReleaseV1; listener: ptr ZwpLinuxBufferReleaseV1Listener; data: pointer): int {.inline.} =
  cast[ptr Proxy](zwpLinuxBufferReleaseV1).add_listener(listener, data)

proc setUserData*(zwpLinuxBufferReleaseV1: ptr ZwpLinuxBufferReleaseV1; userData: pointer) {.inline.} =
  cast[ptr Proxy](zwpLinuxBufferReleaseV1).set_user_data(user_data)
proc getUserData*(zwpLinuxBufferReleaseV1: ptr ZwpLinuxBufferReleaseV1): pointer {.inline.} =
  cast[ptr Proxy](zwpLinuxBufferReleaseV1).get_user_data()
proc getVersion*(zwpLinuxBufferReleaseV1: ptr ZwpLinuxBufferReleaseV1): uint32 {.inline.} =
  cast[ptr Proxy](zwpLinuxBufferReleaseV1).get_version()
proc destroy*(zwpLinuxBufferReleaseV1: ptr ZwpLinuxBufferReleaseV1) {.inline.} =
  destroy cast[ptr Proxy](zwpLinuxBufferReleaseV1)
