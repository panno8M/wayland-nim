# Generated by wayland-nim-scanner 1.23.1
{.warning[UnusedImport]:off.}
import wayland/native/client
import wayland/native/common
import code
export code

## The xdg_shell CLIENT protocol
## #############################
## 
## Interfaces
## ==========
## 
## * xdg_wm_base
## * xdg_positioner
## * xdg_surface
## * xdg_toplevel
## * xdg_popup
## 
## Copyright
## =========
## 
## Copyright © 2008-2013 Kristian Høgsberg
## Copyright © 2013      Rafael Antognolli
## Copyright © 2013      Jasper St. Pierre
## Copyright © 2010-2013 Intel Corporation
## Copyright © 2015-2017 Samsung Electronics Co., Ltd
## Copyright © 2015-2017 Red Hat Inc.
## 
## Permission is hereby granted, free of charge, to any person obtaining a
## copy of this software and associated documentation files (the "Software"),
## to deal in the Software without restriction, including without limitation
## the rights to use, copy, modify, merge, publish, distribute, sublicense,
## and/or sell copies of the Software, and to permit persons to whom the
## Software is furnished to do so, subject to the following conditions:
## 
## The above copyright notice and this permission notice (including the next
## paragraph) shall be included in all copies or substantial portions of the
## Software.
## 
## THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
## IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
## FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
## THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
## LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
## FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
## DEALINGS IN THE SOFTWARE.
## 

type XdgWmBaseListener* = object
  ping*: proc(
    data: pointer;
    xdgWmBase: ptr XdgWmBase;
    serial: uint32;
  ) {.nimcall.}
proc addListener*(xdgWmBase: ptr XdgWmBase; listener: ptr XdgWmBaseListener; data: pointer): int {.inline.} =
  cast[ptr Proxy](xdgWmBase).add_listener(listener, data)

proc setUserData*(xdgWmBase: ptr XdgWmBase; userData: pointer) {.inline.} =
  cast[ptr Proxy](xdgWmBase).set_user_data(user_data)
proc getUserData*(xdgWmBase: ptr XdgWmBase): pointer {.inline.} =
  cast[ptr Proxy](xdgWmBase).get_user_data()
proc getVersion*(xdgWmBase: ptr XdgWmBase): uint32 {.inline.} =
  cast[ptr Proxy](xdgWmBase).get_version()
proc destroy*(xdgWmBase: ptr XdgWmBase) {.inline.} =
  ## destroy xdg_wm_base
  ## 
  ## Destroy this xdg_wm_base object.
  ## 
  ## 	Destroying a bound xdg_wm_base object while there are surfaces
  ## 	still alive created by this xdg_wm_base object instance is illegal
  ## 	and will result in a defunct_surfaces error.
  ## 
  cast[ptr Proxy](xdgWmBase).marshal_flags(XdgWmBaseRequest_destroy.ord, nil, cast[ptr Proxy](xdgWmBase).get_version(), WL_MARSHAL_FLAG_DESTROY)
proc createPositioner*(xdgWmBase: ptr XdgWmBase): ptr XdgPositioner {.inline.} =
  ## create a positioner object
  ## 
  ## Create a positioner object. A positioner object is used to position
  ## 	surfaces relative to some parent surface. See the interface description
  ## 	and xdg_surface.get_popup for details.
  ## 
  cast[ptr XdgPositioner](cast[ptr Proxy](xdgWmBase).marshal_flags(XdgWmBaseRequest_create_positioner.ord, addr xdg_positioner_interface, cast[ptr Proxy](xdgWmBase).get_version(), 0, nil))
proc getXdgSurface*(xdgWmBase: ptr XdgWmBase; surface: ptr Surface): ptr XdgSurface {.inline.} =
  ## create a shell surface from a surface
  ## 
  ## This creates an xdg_surface for the given surface. While xdg_surface
  ## 	itself is not a role, the corresponding surface may only be assigned
  ## 	a role extending xdg_surface, such as xdg_toplevel or xdg_popup. It is
  ## 	illegal to create an xdg_surface for a wl_surface which already has an
  ## 	assigned role and this will result in a role error.
  ## 
  ## 	This creates an xdg_surface for the given surface. An xdg_surface is
  ## 	used as basis to define a role to a given surface, such as xdg_toplevel
  ## 	or xdg_popup. It also manages functionality shared between xdg_surface
  ## 	based surface roles.
  ## 
  ## 	See the documentation of xdg_surface for more details about what an
  ## 	xdg_surface is and how it is used.
  ## 
  cast[ptr XdgSurface](cast[ptr Proxy](xdgWmBase).marshal_flags(XdgWmBaseRequest_get_xdg_surface.ord, addr xdg_surface_interface, cast[ptr Proxy](xdgWmBase).get_version(), 0, nil, surface))
proc pong*(xdgWmBase: ptr XdgWmBase; serial: uint32) {.inline.} =
  ## respond to a ping event
  ## 
  ## A client must respond to a ping event with a pong request or
  ## 	the client may be deemed unresponsive. See xdg_wm_base.ping
  ## 	and xdg_wm_base.error.unresponsive.
  ## 
  cast[ptr Proxy](xdgWmBase).marshal_flags(XdgWmBaseRequest_pong.ord, nil, cast[ptr Proxy](xdgWmBase).get_version(), 0, serial)
proc setUserData*(xdgPositioner: ptr XdgPositioner; userData: pointer) {.inline.} =
  cast[ptr Proxy](xdgPositioner).set_user_data(user_data)
proc getUserData*(xdgPositioner: ptr XdgPositioner): pointer {.inline.} =
  cast[ptr Proxy](xdgPositioner).get_user_data()
proc getVersion*(xdgPositioner: ptr XdgPositioner): uint32 {.inline.} =
  cast[ptr Proxy](xdgPositioner).get_version()
proc destroy*(xdgPositioner: ptr XdgPositioner) {.inline.} =
  ## destroy the xdg_positioner object
  ## 
  ## Notify the compositor that the xdg_positioner will no longer be used.
  ## 
  cast[ptr Proxy](xdgPositioner).marshal_flags(XdgPositionerRequest_destroy.ord, nil, cast[ptr Proxy](xdgPositioner).get_version(), WL_MARSHAL_FLAG_DESTROY)
proc setSize*(xdgPositioner: ptr XdgPositioner; width: int32; height: int32) {.inline.} =
  ## set the size of the to-be positioned rectangle
  ## 
  ## Set the size of the surface that is to be positioned with the positioner
  ## 	object. The size is in surface-local coordinates and corresponds to the
  ## 	window geometry. See xdg_surface.set_window_geometry.
  ## 
  ## 	If a zero or negative size is set the invalid_input error is raised.
  ## 
  cast[ptr Proxy](xdgPositioner).marshal_flags(XdgPositionerRequest_set_size.ord, nil, cast[ptr Proxy](xdgPositioner).get_version(), 0, width, height)
proc setAnchorRect*(xdgPositioner: ptr XdgPositioner; x: int32; y: int32; width: int32; height: int32) {.inline.} =
  ## set the anchor rectangle within the parent surface
  ## 
  ## Specify the anchor rectangle within the parent surface that the child
  ## 	surface will be placed relative to. The rectangle is relative to the
  ## 	window geometry as defined by xdg_surface.set_window_geometry of the
  ## 	parent surface.
  ## 
  ## 	When the xdg_positioner object is used to position a child surface, the
  ## 	anchor rectangle may not extend outside the window geometry of the
  ## 	positioned child's parent surface.
  ## 
  ## 	If a negative size is set the invalid_input error is raised.
  ## 
  cast[ptr Proxy](xdgPositioner).marshal_flags(XdgPositionerRequest_set_anchor_rect.ord, nil, cast[ptr Proxy](xdgPositioner).get_version(), 0, x, y, width, height)
proc setAnchor*(xdgPositioner: ptr XdgPositioner; anchor: uint32) {.inline.} =
  ## set anchor rectangle anchor
  ## 
  ## Defines the anchor point for the anchor rectangle. The specified anchor
  ## 	is used derive an anchor point that the child surface will be
  ## 	positioned relative to. If a corner anchor is set (e.g. 'top_left' or
  ## 	'bottom_right'), the anchor point will be at the specified corner;
  ## 	otherwise, the derived anchor point will be centered on the specified
  ## 	edge, or in the center of the anchor rectangle if no edge is specified.
  ## 
  cast[ptr Proxy](xdgPositioner).marshal_flags(XdgPositionerRequest_set_anchor.ord, nil, cast[ptr Proxy](xdgPositioner).get_version(), 0, anchor)
proc setGravity*(xdgPositioner: ptr XdgPositioner; gravity: uint32) {.inline.} =
  ## set child surface gravity
  ## 
  ## Defines in what direction a surface should be positioned, relative to
  ## 	the anchor point of the parent surface. If a corner gravity is
  ## 	specified (e.g. 'bottom_right' or 'top_left'), then the child surface
  ## 	will be placed towards the specified gravity; otherwise, the child
  ## 	surface will be centered over the anchor point on any axis that had no
  ## 	gravity specified. If the gravity is not in the ‘gravity’ enum, an
  ## 	invalid_input error is raised.
  ## 
  cast[ptr Proxy](xdgPositioner).marshal_flags(XdgPositionerRequest_set_gravity.ord, nil, cast[ptr Proxy](xdgPositioner).get_version(), 0, gravity)
proc setConstraintAdjustment*(xdgPositioner: ptr XdgPositioner; constraintAdjustment: uint32) {.inline.} =
  ## set the adjustment to be done when constrained
  ## 
  ## Specify how the window should be positioned if the originally intended
  ## 	position caused the surface to be constrained, meaning at least
  ## 	partially outside positioning boundaries set by the compositor. The
  ## 	adjustment is set by constructing a bitmask describing the adjustment to
  ## 	be made when the surface is constrained on that axis.
  ## 
  ## 	If no bit for one axis is set, the compositor will assume that the child
  ## 	surface should not change its position on that axis when constrained.
  ## 
  ## 	If more than one bit for one axis is set, the order of how adjustments
  ## 	are applied is specified in the corresponding adjustment descriptions.
  ## 
  ## 	The default adjustment is none.
  ## 
  cast[ptr Proxy](xdgPositioner).marshal_flags(XdgPositionerRequest_set_constraint_adjustment.ord, nil, cast[ptr Proxy](xdgPositioner).get_version(), 0, constraintAdjustment)
proc setOffset*(xdgPositioner: ptr XdgPositioner; x: int32; y: int32) {.inline.} =
  ## set surface position offset
  ## 
  ## Specify the surface position offset relative to the position of the
  ## 	anchor on the anchor rectangle and the anchor on the surface. For
  ## 	example if the anchor of the anchor rectangle is at (x, y), the surface
  ## 	has the gravity bottom|right, and the offset is (ox, oy), the calculated
  ## 	surface position will be (x + ox, y + oy). The offset position of the
  ## 	surface is the one used for constraint testing. See
  ## 	set_constraint_adjustment.
  ## 
  ## 	An example use case is placing a popup menu on top of a user interface
  ## 	element, while aligning the user interface element of the parent surface
  ## 	with some user interface element placed somewhere in the popup surface.
  ## 
  cast[ptr Proxy](xdgPositioner).marshal_flags(XdgPositionerRequest_set_offset.ord, nil, cast[ptr Proxy](xdgPositioner).get_version(), 0, x, y)
proc setReactive*(xdgPositioner: ptr XdgPositioner) {.inline.} =
  ## continuously reconstrain the surface
  ## 
  ## When set reactive, the surface is reconstrained if the conditions used
  ## 	for constraining changed, e.g. the parent window moved.
  ## 
  ## 	If the conditions changed and the popup was reconstrained, an
  ## 	xdg_popup.configure event is sent with updated geometry, followed by an
  ## 	xdg_surface.configure event.
  ## 
  cast[ptr Proxy](xdgPositioner).marshal_flags(XdgPositionerRequest_set_reactive.ord, nil, cast[ptr Proxy](xdgPositioner).get_version(), 0)
proc setParentSize*(xdgPositioner: ptr XdgPositioner; parentWidth: int32; parentHeight: int32) {.inline.} =
  ## Set the parent window geometry the compositor should use when
  ## 	positioning the popup. The compositor may use this information to
  ## 	determine the future state the popup should be constrained using. If
  ## 	this doesn't match the dimension of the parent the popup is eventually
  ## 	positioned against, the behavior is undefined.
  ## 
  ## 	The arguments are given in the surface-local coordinate space.
  ## 
  cast[ptr Proxy](xdgPositioner).marshal_flags(XdgPositionerRequest_set_parent_size.ord, nil, cast[ptr Proxy](xdgPositioner).get_version(), 0, parentWidth, parentHeight)
proc setParentConfigure*(xdgPositioner: ptr XdgPositioner; serial: uint32) {.inline.} =
  ## set parent configure this is a response to
  ## 
  ## Set the serial of an xdg_surface.configure event this positioner will be
  ## 	used in response to. The compositor may use this information together
  ## 	with set_parent_size to determine what future state the popup should be
  ## 	constrained using.
  ## 
  cast[ptr Proxy](xdgPositioner).marshal_flags(XdgPositionerRequest_set_parent_configure.ord, nil, cast[ptr Proxy](xdgPositioner).get_version(), 0, serial)
type XdgSurfaceListener* = object
  configure*: proc(
    data: pointer;
    xdgSurface: ptr XdgSurface;
    serial: uint32;
  ) {.nimcall.}
proc addListener*(xdgSurface: ptr XdgSurface; listener: ptr XdgSurfaceListener; data: pointer): int {.inline.} =
  cast[ptr Proxy](xdgSurface).add_listener(listener, data)

proc setUserData*(xdgSurface: ptr XdgSurface; userData: pointer) {.inline.} =
  cast[ptr Proxy](xdgSurface).set_user_data(user_data)
proc getUserData*(xdgSurface: ptr XdgSurface): pointer {.inline.} =
  cast[ptr Proxy](xdgSurface).get_user_data()
proc getVersion*(xdgSurface: ptr XdgSurface): uint32 {.inline.} =
  cast[ptr Proxy](xdgSurface).get_version()
proc destroy*(xdgSurface: ptr XdgSurface) {.inline.} =
  ## destroy the xdg_surface
  ## 
  ## Destroy the xdg_surface object. An xdg_surface must only be destroyed
  ## 	after its role object has been destroyed, otherwise
  ## 	a defunct_role_object error is raised.
  ## 
  cast[ptr Proxy](xdgSurface).marshal_flags(XdgSurfaceRequest_destroy.ord, nil, cast[ptr Proxy](xdgSurface).get_version(), WL_MARSHAL_FLAG_DESTROY)
proc getToplevel*(xdgSurface: ptr XdgSurface): ptr XdgToplevel {.inline.} =
  ## assign the xdg_toplevel surface role
  ## 
  ## This creates an xdg_toplevel object for the given xdg_surface and gives
  ## 	the associated wl_surface the xdg_toplevel role.
  ## 
  ## 	See the documentation of xdg_toplevel for more details about what an
  ## 	xdg_toplevel is and how it is used.
  ## 
  cast[ptr XdgToplevel](cast[ptr Proxy](xdgSurface).marshal_flags(XdgSurfaceRequest_get_toplevel.ord, addr xdg_toplevel_interface, cast[ptr Proxy](xdgSurface).get_version(), 0, nil))
proc getPopup*(xdgSurface: ptr XdgSurface; parent: ptr XdgSurface; positioner: ptr XdgPositioner): ptr XdgPopup {.inline.} =
  ## assign the xdg_popup surface role
  ## 
  ## This creates an xdg_popup object for the given xdg_surface and gives
  ## 	the associated wl_surface the xdg_popup role.
  ## 
  ## 	If null is passed as a parent, a parent surface must be specified using
  ## 	some other protocol, before committing the initial state.
  ## 
  ## 	See the documentation of xdg_popup for more details about what an
  ## 	xdg_popup is and how it is used.
  ## 
  cast[ptr XdgPopup](cast[ptr Proxy](xdgSurface).marshal_flags(XdgSurfaceRequest_get_popup.ord, addr xdg_popup_interface, cast[ptr Proxy](xdgSurface).get_version(), 0, nil, parent, positioner))
proc setWindowGeometry*(xdgSurface: ptr XdgSurface; x: int32; y: int32; width: int32; height: int32) {.inline.} =
  ## set the new window geometry
  ## 
  ## The window geometry of a surface is its "visible bounds" from the
  ## 	user's perspective. Client-side decorations often have invisible
  ## 	portions like drop-shadows which should be ignored for the
  ## 	purposes of aligning, placing and constraining windows.
  ## 
  ## 	The window geometry is double-buffered state, see wl_surface.commit.
  ## 
  ## 	When maintaining a position, the compositor should treat the (x, y)
  ## 	coordinate of the window geometry as the top left corner of the window.
  ## 	A client changing the (x, y) window geometry coordinate should in
  ## 	general not alter the position of the window.
  ## 
  ## 	Once the window geometry of the surface is set, it is not possible to
  ## 	unset it, and it will remain the same until set_window_geometry is
  ## 	called again, even if a new subsurface or buffer is attached.
  ## 
  ## 	If never set, the value is the full bounds of the surface,
  ## 	including any subsurfaces. This updates dynamically on every
  ## 	commit. This unset is meant for extremely simple clients.
  ## 
  ## 	The arguments are given in the surface-local coordinate space of
  ## 	the wl_surface associated with this xdg_surface, and may extend outside
  ## 	of the wl_surface itself to mark parts of the subsurface tree as part of
  ## 	the window geometry.
  ## 
  ## 	When applied, the effective window geometry will be the set window
  ## 	geometry clamped to the bounding rectangle of the combined
  ## 	geometry of the surface of the xdg_surface and the associated
  ## 	subsurfaces.
  ## 
  ## 	The effective geometry will not be recalculated unless a new call to
  ## 	set_window_geometry is done and the new pending surface state is
  ## 	subsequently applied.
  ## 
  ## 	The width and height of the effective window geometry must be
  ## 	greater than zero. Setting an invalid size will raise an
  ## 	invalid_size error.
  ## 
  cast[ptr Proxy](xdgSurface).marshal_flags(XdgSurfaceRequest_set_window_geometry.ord, nil, cast[ptr Proxy](xdgSurface).get_version(), 0, x, y, width, height)
proc ackConfigure*(xdgSurface: ptr XdgSurface; serial: uint32) {.inline.} =
  ## ack a configure event
  ## 
  ## When a configure event is received, if a client commits the
  ## 	surface in response to the configure event, then the client
  ## 	must make an ack_configure request sometime before the commit
  ## 	request, passing along the serial of the configure event.
  ## 
  ## 	For instance, for toplevel surfaces the compositor might use this
  ## 	information to move a surface to the top left only when the client has
  ## 	drawn itself for the maximized or fullscreen state.
  ## 
  ## 	If the client receives multiple configure events before it
  ## 	can respond to one, it only has to ack the last configure event.
  ## 	Acking a configure event that was never sent raises an invalid_serial
  ## 	error.
  ## 
  ## 	A client is not required to commit immediately after sending
  ## 	an ack_configure request - it may even ack_configure several times
  ## 	before its next surface commit.
  ## 
  ## 	A client may send multiple ack_configure requests before committing, but
  ## 	only the last request sent before a commit indicates which configure
  ## 	event the client really is responding to.
  ## 
  ## 	Sending an ack_configure request consumes the serial number sent with
  ## 	the request, as well as serial numbers sent by all configure events
  ## 	sent on this xdg_surface prior to the configure event referenced by
  ## 	the committed serial.
  ## 
  ## 	It is an error to issue multiple ack_configure requests referencing a
  ## 	serial from the same configure event, or to issue an ack_configure
  ## 	request referencing a serial from a configure event issued before the
  ## 	event identified by the last ack_configure request for the same
  ## 	xdg_surface. Doing so will raise an invalid_serial error.
  ## 
  cast[ptr Proxy](xdgSurface).marshal_flags(XdgSurfaceRequest_ack_configure.ord, nil, cast[ptr Proxy](xdgSurface).get_version(), 0, serial)
type XdgToplevelListener* = object
  configure*: proc(
    data: pointer;
    xdgToplevel: ptr XdgToplevel;
    width: int32;
    height: int32;
    states: ptr Array;
  ) {.nimcall.}
  close*: proc(
    data: pointer;
    xdgToplevel: ptr XdgToplevel;
  ) {.nimcall.}
  configureBounds*: proc(
    data: pointer;
    xdgToplevel: ptr XdgToplevel;
    width: int32;
    height: int32;
  ) {.nimcall.}
  wmCapabilities*: proc(
    data: pointer;
    xdgToplevel: ptr XdgToplevel;
    capabilities: ptr Array;
  ) {.nimcall.}
proc addListener*(xdgToplevel: ptr XdgToplevel; listener: ptr XdgToplevelListener; data: pointer): int {.inline.} =
  cast[ptr Proxy](xdgToplevel).add_listener(listener, data)

proc setUserData*(xdgToplevel: ptr XdgToplevel; userData: pointer) {.inline.} =
  cast[ptr Proxy](xdgToplevel).set_user_data(user_data)
proc getUserData*(xdgToplevel: ptr XdgToplevel): pointer {.inline.} =
  cast[ptr Proxy](xdgToplevel).get_user_data()
proc getVersion*(xdgToplevel: ptr XdgToplevel): uint32 {.inline.} =
  cast[ptr Proxy](xdgToplevel).get_version()
proc destroy*(xdgToplevel: ptr XdgToplevel) {.inline.} =
  ## destroy the xdg_toplevel
  ## 
  ## This request destroys the role surface and unmaps the surface;
  ## 	see "Unmapping" behavior in interface section for details.
  ## 
  cast[ptr Proxy](xdgToplevel).marshal_flags(XdgToplevelRequest_destroy.ord, nil, cast[ptr Proxy](xdgToplevel).get_version(), WL_MARSHAL_FLAG_DESTROY)
proc setParent*(xdgToplevel: ptr XdgToplevel; parent: ptr XdgToplevel) {.inline.} =
  ## set the parent of this surface
  ## 
  ## Set the "parent" of this surface. This surface should be stacked
  ## 	above the parent surface and all other ancestor surfaces.
  ## 
  ## 	Parent surfaces should be set on dialogs, toolboxes, or other
  ## 	"auxiliary" surfaces, so that the parent is raised when the dialog
  ## 	is raised.
  ## 
  ## 	Setting a null parent for a child surface unsets its parent. Setting
  ## 	a null parent for a surface which currently has no parent is a no-op.
  ## 
  ## 	Only mapped surfaces can have child surfaces. Setting a parent which
  ## 	is not mapped is equivalent to setting a null parent. If a surface
  ## 	becomes unmapped, its children's parent is set to the parent of
  ## 	the now-unmapped surface. If the now-unmapped surface has no parent,
  ## 	its children's parent is unset. If the now-unmapped surface becomes
  ## 	mapped again, its parent-child relationship is not restored.
  ## 
  ## 	The parent toplevel must not be one of the child toplevel's
  ## 	descendants, and the parent must be different from the child toplevel,
  ## 	otherwise the invalid_parent protocol error is raised.
  ## 
  cast[ptr Proxy](xdgToplevel).marshal_flags(XdgToplevelRequest_set_parent.ord, nil, cast[ptr Proxy](xdgToplevel).get_version(), 0, parent)
proc setTitle*(xdgToplevel: ptr XdgToplevel; title: cstring) {.inline.} =
  ## set surface title
  ## 
  ## Set a short title for the surface.
  ## 
  ## 	This string may be used to identify the surface in a task bar,
  ## 	window list, or other user interface elements provided by the
  ## 	compositor.
  ## 
  ## 	The string must be encoded in UTF-8.
  ## 
  cast[ptr Proxy](xdgToplevel).marshal_flags(XdgToplevelRequest_set_title.ord, nil, cast[ptr Proxy](xdgToplevel).get_version(), 0, title)
proc setAppId*(xdgToplevel: ptr XdgToplevel; appId: cstring) {.inline.} =
  ## set application ID
  ## 
  ## Set an application identifier for the surface.
  ## 
  ## 	The app ID identifies the general class of applications to which
  ## 	the surface belongs. The compositor can use this to group multiple
  ## 	surfaces together, or to determine how to launch a new application.
  ## 
  ## 	For D-Bus activatable applications, the app ID is used as the D-Bus
  ## 	service name.
  ## 
  ## 	The compositor shell will try to group application surfaces together
  ## 	by their app ID. As a best practice, it is suggested to select app
  ## 	ID's that match the basename of the application's .desktop file.
  ## 	For example, "org.freedesktop.FooViewer" where the .desktop file is
  ## 	"org.freedesktop.FooViewer.desktop".
  ## 
  ## 	Like other properties, a set_app_id request can be sent after the
  ## 	xdg_toplevel has been mapped to update the property.
  ## 
  ## 	See the desktop-entry specification [0] for more details on
  ## 	application identifiers and how they relate to well-known D-Bus
  ## 	names and .desktop files.
  ## 
  ## 	[0] https://standards.freedesktop.org/desktop-entry-spec/
  ## 
  cast[ptr Proxy](xdgToplevel).marshal_flags(XdgToplevelRequest_set_app_id.ord, nil, cast[ptr Proxy](xdgToplevel).get_version(), 0, appId)
proc showWindowMenu*(xdgToplevel: ptr XdgToplevel; seat: ptr Seat; serial: uint32; x: int32; y: int32) {.inline.} =
  ## show the window menu
  ## 
  ## Clients implementing client-side decorations might want to show
  ## 	a context menu when right-clicking on the decorations, giving the
  ## 	user a menu that they can use to maximize or minimize the window.
  ## 
  ## 	This request asks the compositor to pop up such a window menu at
  ## 	the given position, relative to the local surface coordinates of
  ## 	the parent surface. There are no guarantees as to what menu items
  ## 	the window menu contains, or even if a window menu will be drawn
  ## 	at all.
  ## 
  ## 	This request must be used in response to some sort of user action
  ## 	like a button press, key press, or touch down event.
  ## 
  cast[ptr Proxy](xdgToplevel).marshal_flags(XdgToplevelRequest_show_window_menu.ord, nil, cast[ptr Proxy](xdgToplevel).get_version(), 0, seat, serial, x, y)
proc move*(xdgToplevel: ptr XdgToplevel; seat: ptr Seat; serial: uint32) {.inline.} =
  ## start an interactive move
  ## 
  ## Start an interactive, user-driven move of the surface.
  ## 
  ## 	This request must be used in response to some sort of user action
  ## 	like a button press, key press, or touch down event. The passed
  ## 	serial is used to determine the type of interactive move (touch,
  ## 	pointer, etc).
  ## 
  ## 	The server may ignore move requests depending on the state of
  ## 	the surface (e.g. fullscreen or maximized), or if the passed serial
  ## 	is no longer valid.
  ## 
  ## 	If triggered, the surface will lose the focus of the device
  ## 	(wl_pointer, wl_touch, etc) used for the move. It is up to the
  ## 	compositor to visually indicate that the move is taking place, such as
  ## 	updating a pointer cursor, during the move. There is no guarantee
  ## 	that the device focus will return when the move is completed.
  ## 
  cast[ptr Proxy](xdgToplevel).marshal_flags(XdgToplevelRequest_move.ord, nil, cast[ptr Proxy](xdgToplevel).get_version(), 0, seat, serial)
proc resize*(xdgToplevel: ptr XdgToplevel; seat: ptr Seat; serial: uint32; edges: uint32) {.inline.} =
  ## start an interactive resize
  ## 
  ## Start a user-driven, interactive resize of the surface.
  ## 
  ## 	This request must be used in response to some sort of user action
  ## 	like a button press, key press, or touch down event. The passed
  ## 	serial is used to determine the type of interactive resize (touch,
  ## 	pointer, etc).
  ## 
  ## 	The server may ignore resize requests depending on the state of
  ## 	the surface (e.g. fullscreen or maximized).
  ## 
  ## 	If triggered, the client will receive configure events with the
  ## 	"resize" state enum value and the expected sizes. See the "resize"
  ## 	enum value for more details about what is required. The client
  ## 	must also acknowledge configure events using "ack_configure". After
  ## 	the resize is completed, the client will receive another "configure"
  ## 	event without the resize state.
  ## 
  ## 	If triggered, the surface also will lose the focus of the device
  ## 	(wl_pointer, wl_touch, etc) used for the resize. It is up to the
  ## 	compositor to visually indicate that the resize is taking place,
  ## 	such as updating a pointer cursor, during the resize. There is no
  ## 	guarantee that the device focus will return when the resize is
  ## 	completed.
  ## 
  ## 	The edges parameter specifies how the surface should be resized, and
  ## 	is one of the values of the resize_edge enum. Values not matching
  ## 	a variant of the enum will cause the invalid_resize_edge protocol error.
  ## 	The compositor may use this information to update the surface position
  ## 	for example when dragging the top left corner. The compositor may also
  ## 	use this information to adapt its behavior, e.g. choose an appropriate
  ## 	cursor image.
  ## 
  cast[ptr Proxy](xdgToplevel).marshal_flags(XdgToplevelRequest_resize.ord, nil, cast[ptr Proxy](xdgToplevel).get_version(), 0, seat, serial, edges)
proc setMaxSize*(xdgToplevel: ptr XdgToplevel; width: int32; height: int32) {.inline.} =
  ## set the maximum size
  ## 
  ## Set a maximum size for the window.
  ## 
  ## 	The client can specify a maximum size so that the compositor does
  ## 	not try to configure the window beyond this size.
  ## 
  ## 	The width and height arguments are in window geometry coordinates.
  ## 	See xdg_surface.set_window_geometry.
  ## 
  ## 	Values set in this way are double-buffered, see wl_surface.commit.
  ## 
  ## 	The compositor can use this information to allow or disallow
  ## 	different states like maximize or fullscreen and draw accurate
  ## 	animations.
  ## 
  ## 	Similarly, a tiling window manager may use this information to
  ## 	place and resize client windows in a more effective way.
  ## 
  ## 	The client should not rely on the compositor to obey the maximum
  ## 	size. The compositor may decide to ignore the values set by the
  ## 	client and request a larger size.
  ## 
  ## 	If never set, or a value of zero in the request, means that the
  ## 	client has no expected maximum size in the given dimension.
  ## 	As a result, a client wishing to reset the maximum size
  ## 	to an unspecified state can use zero for width and height in the
  ## 	request.
  ## 
  ## 	Requesting a maximum size to be smaller than the minimum size of
  ## 	a surface is illegal and will result in an invalid_size error.
  ## 
  ## 	The width and height must be greater than or equal to zero. Using
  ## 	strictly negative values for width or height will result in a
  ## 	invalid_size error.
  ## 
  cast[ptr Proxy](xdgToplevel).marshal_flags(XdgToplevelRequest_set_max_size.ord, nil, cast[ptr Proxy](xdgToplevel).get_version(), 0, width, height)
proc setMinSize*(xdgToplevel: ptr XdgToplevel; width: int32; height: int32) {.inline.} =
  ## set the minimum size
  ## 
  ## Set a minimum size for the window.
  ## 
  ## 	The client can specify a minimum size so that the compositor does
  ## 	not try to configure the window below this size.
  ## 
  ## 	The width and height arguments are in window geometry coordinates.
  ## 	See xdg_surface.set_window_geometry.
  ## 
  ## 	Values set in this way are double-buffered, see wl_surface.commit.
  ## 
  ## 	The compositor can use this information to allow or disallow
  ## 	different states like maximize or fullscreen and draw accurate
  ## 	animations.
  ## 
  ## 	Similarly, a tiling window manager may use this information to
  ## 	place and resize client windows in a more effective way.
  ## 
  ## 	The client should not rely on the compositor to obey the minimum
  ## 	size. The compositor may decide to ignore the values set by the
  ## 	client and request a smaller size.
  ## 
  ## 	If never set, or a value of zero in the request, means that the
  ## 	client has no expected minimum size in the given dimension.
  ## 	As a result, a client wishing to reset the minimum size
  ## 	to an unspecified state can use zero for width and height in the
  ## 	request.
  ## 
  ## 	Requesting a minimum size to be larger than the maximum size of
  ## 	a surface is illegal and will result in an invalid_size error.
  ## 
  ## 	The width and height must be greater than or equal to zero. Using
  ## 	strictly negative values for width and height will result in a
  ## 	invalid_size error.
  ## 
  cast[ptr Proxy](xdgToplevel).marshal_flags(XdgToplevelRequest_set_min_size.ord, nil, cast[ptr Proxy](xdgToplevel).get_version(), 0, width, height)
proc setMaximized*(xdgToplevel: ptr XdgToplevel) {.inline.} =
  ## maximize the window
  ## 
  ## Maximize the surface.
  ## 
  ## 	After requesting that the surface should be maximized, the compositor
  ## 	will respond by emitting a configure event. Whether this configure
  ## 	actually sets the window maximized is subject to compositor policies.
  ## 	The client must then update its content, drawing in the configured
  ## 	state. The client must also acknowledge the configure when committing
  ## 	the new content (see ack_configure).
  ## 
  ## 	It is up to the compositor to decide how and where to maximize the
  ## 	surface, for example which output and what region of the screen should
  ## 	be used.
  ## 
  ## 	If the surface was already maximized, the compositor will still emit
  ## 	a configure event with the "maximized" state.
  ## 
  ## 	If the surface is in a fullscreen state, this request has no direct
  ## 	effect. It may alter the state the surface is returned to when
  ## 	unmaximized unless overridden by the compositor.
  ## 
  cast[ptr Proxy](xdgToplevel).marshal_flags(XdgToplevelRequest_set_maximized.ord, nil, cast[ptr Proxy](xdgToplevel).get_version(), 0)
proc unsetMaximized*(xdgToplevel: ptr XdgToplevel) {.inline.} =
  ## unmaximize the window
  ## 
  ## Unmaximize the surface.
  ## 
  ## 	After requesting that the surface should be unmaximized, the compositor
  ## 	will respond by emitting a configure event. Whether this actually
  ## 	un-maximizes the window is subject to compositor policies.
  ## 	If available and applicable, the compositor will include the window
  ## 	geometry dimensions the window had prior to being maximized in the
  ## 	configure event. The client must then update its content, drawing it in
  ## 	the configured state. The client must also acknowledge the configure
  ## 	when committing the new content (see ack_configure).
  ## 
  ## 	It is up to the compositor to position the surface after it was
  ## 	unmaximized; usually the position the surface had before maximizing, if
  ## 	applicable.
  ## 
  ## 	If the surface was already not maximized, the compositor will still
  ## 	emit a configure event without the "maximized" state.
  ## 
  ## 	If the surface is in a fullscreen state, this request has no direct
  ## 	effect. It may alter the state the surface is returned to when
  ## 	unmaximized unless overridden by the compositor.
  ## 
  cast[ptr Proxy](xdgToplevel).marshal_flags(XdgToplevelRequest_unset_maximized.ord, nil, cast[ptr Proxy](xdgToplevel).get_version(), 0)
proc setFullscreen*(xdgToplevel: ptr XdgToplevel; output: ptr Output) {.inline.} =
  ## set the window as fullscreen on an output
  ## 
  ## Make the surface fullscreen.
  ## 
  ## 	After requesting that the surface should be fullscreened, the
  ## 	compositor will respond by emitting a configure event. Whether the
  ## 	client is actually put into a fullscreen state is subject to compositor
  ## 	policies. The client must also acknowledge the configure when
  ## 	committing the new content (see ack_configure).
  ## 
  ## 	The output passed by the request indicates the client's preference as
  ## 	to which display it should be set fullscreen on. If this value is NULL,
  ## 	it's up to the compositor to choose which display will be used to map
  ## 	this surface.
  ## 
  ## 	If the surface doesn't cover the whole output, the compositor will
  ## 	position the surface in the center of the output and compensate with
  ## 	with border fill covering the rest of the output. The content of the
  ## 	border fill is undefined, but should be assumed to be in some way that
  ## 	attempts to blend into the surrounding area (e.g. solid black).
  ## 
  ## 	If the fullscreened surface is not opaque, the compositor must make
  ## 	sure that other screen content not part of the same surface tree (made
  ## 	up of subsurfaces, popups or similarly coupled surfaces) are not
  ## 	visible below the fullscreened surface.
  ## 
  cast[ptr Proxy](xdgToplevel).marshal_flags(XdgToplevelRequest_set_fullscreen.ord, nil, cast[ptr Proxy](xdgToplevel).get_version(), 0, output)
proc unsetFullscreen*(xdgToplevel: ptr XdgToplevel) {.inline.} =
  ## unset the window as fullscreen
  ## 
  ## Make the surface no longer fullscreen.
  ## 
  ## 	After requesting that the surface should be unfullscreened, the
  ## 	compositor will respond by emitting a configure event.
  ## 	Whether this actually removes the fullscreen state of the client is
  ## 	subject to compositor policies.
  ## 
  ## 	Making a surface unfullscreen sets states for the surface based on the following:
  ## 	* the state(s) it may have had before becoming fullscreen
  ## 	* any state(s) decided by the compositor
  ## 	* any state(s) requested by the client while the surface was fullscreen
  ## 
  ## 	The compositor may include the previous window geometry dimensions in
  ## 	the configure event, if applicable.
  ## 
  ## 	The client must also acknowledge the configure when committing the new
  ## 	content (see ack_configure).
  ## 
  cast[ptr Proxy](xdgToplevel).marshal_flags(XdgToplevelRequest_unset_fullscreen.ord, nil, cast[ptr Proxy](xdgToplevel).get_version(), 0)
proc setMinimized*(xdgToplevel: ptr XdgToplevel) {.inline.} =
  ## set the window as minimized
  ## 
  ## Request that the compositor minimize your surface. There is no
  ## 	way to know if the surface is currently minimized, nor is there
  ## 	any way to unset minimization on this surface.
  ## 
  ## 	If you are looking to throttle redrawing when minimized, please
  ## 	instead use the wl_surface.frame event for this, as this will
  ## 	also work with live previews on windows in Alt-Tab, Expose or
  ## 	similar compositor features.
  ## 
  cast[ptr Proxy](xdgToplevel).marshal_flags(XdgToplevelRequest_set_minimized.ord, nil, cast[ptr Proxy](xdgToplevel).get_version(), 0)
type XdgPopupListener* = object
  configure*: proc(
    data: pointer;
    xdgPopup: ptr XdgPopup;
    x: int32;
    y: int32;
    width: int32;
    height: int32;
  ) {.nimcall.}
  popupDone*: proc(
    data: pointer;
    xdgPopup: ptr XdgPopup;
  ) {.nimcall.}
  repositioned*: proc(
    data: pointer;
    xdgPopup: ptr XdgPopup;
    token: uint32;
  ) {.nimcall.}
proc addListener*(xdgPopup: ptr XdgPopup; listener: ptr XdgPopupListener; data: pointer): int {.inline.} =
  cast[ptr Proxy](xdgPopup).add_listener(listener, data)

proc setUserData*(xdgPopup: ptr XdgPopup; userData: pointer) {.inline.} =
  cast[ptr Proxy](xdgPopup).set_user_data(user_data)
proc getUserData*(xdgPopup: ptr XdgPopup): pointer {.inline.} =
  cast[ptr Proxy](xdgPopup).get_user_data()
proc getVersion*(xdgPopup: ptr XdgPopup): uint32 {.inline.} =
  cast[ptr Proxy](xdgPopup).get_version()
proc destroy*(xdgPopup: ptr XdgPopup) {.inline.} =
  ## remove xdg_popup interface
  ## 
  ## This destroys the popup. Explicitly destroying the xdg_popup
  ## 	object will also dismiss the popup, and unmap the surface.
  ## 
  ## 	If this xdg_popup is not the "topmost" popup, the
  ## 	xdg_wm_base.not_the_topmost_popup protocol error will be sent.
  ## 
  cast[ptr Proxy](xdgPopup).marshal_flags(XdgPopupRequest_destroy.ord, nil, cast[ptr Proxy](xdgPopup).get_version(), WL_MARSHAL_FLAG_DESTROY)
proc grab*(xdgPopup: ptr XdgPopup; seat: ptr Seat; serial: uint32) {.inline.} =
  ## make the popup take an explicit grab
  ## 
  ## This request makes the created popup take an explicit grab. An explicit
  ## 	grab will be dismissed when the user dismisses the popup, or when the
  ## 	client destroys the xdg_popup. This can be done by the user clicking
  ## 	outside the surface, using the keyboard, or even locking the screen
  ## 	through closing the lid or a timeout.
  ## 
  ## 	If the compositor denies the grab, the popup will be immediately
  ## 	dismissed.
  ## 
  ## 	This request must be used in response to some sort of user action like a
  ## 	button press, key press, or touch down event. The serial number of the
  ## 	event should be passed as 'serial'.
  ## 
  ## 	The parent of a grabbing popup must either be an xdg_toplevel surface or
  ## 	another xdg_popup with an explicit grab. If the parent is another
  ## 	xdg_popup it means that the popups are nested, with this popup now being
  ## 	the topmost popup.
  ## 
  ## 	Nested popups must be destroyed in the reverse order they were created
  ## 	in, e.g. the only popup you are allowed to destroy at all times is the
  ## 	topmost one.
  ## 
  ## 	When compositors choose to dismiss a popup, they may dismiss every
  ## 	nested grabbing popup as well. When a compositor dismisses popups, it
  ## 	will follow the same dismissing order as required from the client.
  ## 
  ## 	If the topmost grabbing popup is destroyed, the grab will be returned to
  ## 	the parent of the popup, if that parent previously had an explicit grab.
  ## 
  ## 	If the parent is a grabbing popup which has already been dismissed, this
  ## 	popup will be immediately dismissed. If the parent is a popup that did
  ## 	not take an explicit grab, an error will be raised.
  ## 
  ## 	During a popup grab, the client owning the grab will receive pointer
  ## 	and touch events for all their surfaces as normal (similar to an
  ## 	"owner-events" grab in X11 parlance), while the top most grabbing popup
  ## 	will always have keyboard focus.
  ## 
  cast[ptr Proxy](xdgPopup).marshal_flags(XdgPopupRequest_grab.ord, nil, cast[ptr Proxy](xdgPopup).get_version(), 0, seat, serial)
proc reposition*(xdgPopup: ptr XdgPopup; positioner: ptr XdgPositioner; token: uint32) {.inline.} =
  ## recalculate the popup's location
  ## 
  ## Reposition an already-mapped popup. The popup will be placed given the
  ## 	details in the passed xdg_positioner object, and a
  ## 	xdg_popup.repositioned followed by xdg_popup.configure and
  ## 	xdg_surface.configure will be emitted in response. Any parameters set
  ## 	by the previous positioner will be discarded.
  ## 
  ## 	The passed token will be sent in the corresponding
  ## 	xdg_popup.repositioned event. The new popup position will not take
  ## 	effect until the corresponding configure event is acknowledged by the
  ## 	client. See xdg_popup.repositioned for details. The token itself is
  ## 	opaque, and has no other special meaning.
  ## 
  ## 	If multiple reposition requests are sent, the compositor may skip all
  ## 	but the last one.
  ## 
  ## 	If the popup is repositioned in response to a configure event for its
  ## 	parent, the client should send an xdg_positioner.set_parent_configure
  ## 	and possibly an xdg_positioner.set_parent_size request to allow the
  ## 	compositor to properly constrain the popup.
  ## 
  ## 	If the popup is repositioned together with a parent that is being
  ## 	resized, but not in response to a configure event, the client should
  ## 	send an xdg_positioner.set_parent_size request.
  ## 
  cast[ptr Proxy](xdgPopup).marshal_flags(XdgPopupRequest_reposition.ord, nil, cast[ptr Proxy](xdgPopup).get_version(), 0, positioner, token)
