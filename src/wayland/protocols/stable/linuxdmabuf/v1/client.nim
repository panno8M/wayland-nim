# Generated by wayland-nim-scanner 1.23.1
{.warning[UnusedImport]:off.}
import wayland/native/client
import wayland/native/common
import code
export code

## The linux_dmabuf_v1 CLIENT protocol
## ###################################
## 
## Interfaces
## ==========
## 
## * zwp_linux_dmabuf_v1
## * zwp_linux_buffer_params_v1
## * zwp_linux_dmabuf_feedback_v1
## 
## Copyright
## =========
## 
## Copyright Â© 2014, 2015 Collabora, Ltd.
## 
## Permission is hereby granted, free of charge, to any person obtaining a
## copy of this software and associated documentation files (the "Software"),
## to deal in the Software without restriction, including without limitation
## the rights to use, copy, modify, merge, publish, distribute, sublicense,
## and/or sell copies of the Software, and to permit persons to whom the
## Software is furnished to do so, subject to the following conditions:
## 
## The above copyright notice and this permission notice (including the next
## paragraph) shall be included in all copies or substantial portions of the
## Software.
## 
## THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
## IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
## FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
## THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
## LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
## FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
## DEALINGS IN THE SOFTWARE.
## 

type ZwpLinuxDmabufV1Listener* = object
  format*: proc(
    data: pointer;
    zwpLinuxDmabufV1: ptr ZwpLinuxDmabufV1;
    format: uint32;
  ) {.nimcall.}
  modifier*: proc(
    data: pointer;
    zwpLinuxDmabufV1: ptr ZwpLinuxDmabufV1;
    format: uint32;
    modifierHi: uint32;
    modifierLo: uint32;
  ) {.nimcall.}
proc addListener*(zwpLinuxDmabufV1: ptr ZwpLinuxDmabufV1; listener: ptr ZwpLinuxDmabufV1Listener; data: pointer): int {.inline.} =
  cast[ptr Proxy](zwpLinuxDmabufV1).add_listener(listener, data)

proc setUserData*(zwpLinuxDmabufV1: ptr ZwpLinuxDmabufV1; userData: pointer) {.inline.} =
  cast[ptr Proxy](zwpLinuxDmabufV1).set_user_data(user_data)
proc getUserData*(zwpLinuxDmabufV1: ptr ZwpLinuxDmabufV1): pointer {.inline.} =
  cast[ptr Proxy](zwpLinuxDmabufV1).get_user_data()
proc getVersion*(zwpLinuxDmabufV1: ptr ZwpLinuxDmabufV1): uint32 {.inline.} =
  cast[ptr Proxy](zwpLinuxDmabufV1).get_version()
proc destroy*(zwpLinuxDmabufV1: ptr ZwpLinuxDmabufV1) {.inline.} =
  ## unbind the factory
  ## 
  ## Objects created through this interface, especially wl_buffers, will
  ## remain valid.
  ## 
  cast[ptr Proxy](zwpLinuxDmabufV1).marshal_flags(ZwpLinuxDmabufV1Request_destroy.ord, nil, cast[ptr Proxy](zwpLinuxDmabufV1).get_version(), WL_MARSHAL_FLAG_DESTROY)
proc createParams*(zwpLinuxDmabufV1: ptr ZwpLinuxDmabufV1): ptr ZwpLinuxBufferParamsV1 {.inline.} =
  ## create a temporary object for buffer parameters
  ## 
  ## This temporary object is used to collect multiple dmabuf handles into
  ## a single batch to create a wl_buffer. It can only be used once and
  ## should be destroyed after a 'created' or 'failed' event has been
  ## received.
  ## 
  cast[ptr ZwpLinuxBufferParamsV1](cast[ptr Proxy](zwpLinuxDmabufV1).marshal_flags(ZwpLinuxDmabufV1Request_create_params.ord, addr zwp_linux_buffer_params_v1_interface, cast[ptr Proxy](zwpLinuxDmabufV1).get_version(), 0, nil))
proc getDefaultFeedback*(zwpLinuxDmabufV1: ptr ZwpLinuxDmabufV1): ptr ZwpLinuxDmabufFeedbackV1 {.inline.} =
  ## get default feedback
  ## 
  ## This request creates a new wp_linux_dmabuf_feedback object not bound
  ## to a particular surface. This object will deliver feedback about dmabuf
  ## parameters to use if the client doesn't support per-surface feedback
  ## (see get_surface_feedback).
  ## 
  cast[ptr ZwpLinuxDmabufFeedbackV1](cast[ptr Proxy](zwpLinuxDmabufV1).marshal_flags(ZwpLinuxDmabufV1Request_get_default_feedback.ord, addr zwp_linux_dmabuf_feedback_v1_interface, cast[ptr Proxy](zwpLinuxDmabufV1).get_version(), 0, nil))
proc getSurfaceFeedback*(zwpLinuxDmabufV1: ptr ZwpLinuxDmabufV1; surface: ptr Surface): ptr ZwpLinuxDmabufFeedbackV1 {.inline.} =
  ## get feedback for a surface
  ## 
  ## This request creates a new wp_linux_dmabuf_feedback object for the
  ## specified wl_surface. This object will deliver feedback about dmabuf
  ## parameters to use for buffers attached to this surface.
  ## 
  ## If the surface is destroyed before the wp_linux_dmabuf_feedback object,
  ## the feedback object becomes inert.
  ## 
  cast[ptr ZwpLinuxDmabufFeedbackV1](cast[ptr Proxy](zwpLinuxDmabufV1).marshal_flags(ZwpLinuxDmabufV1Request_get_surface_feedback.ord, addr zwp_linux_dmabuf_feedback_v1_interface, cast[ptr Proxy](zwpLinuxDmabufV1).get_version(), 0, nil, surface))
type ZwpLinuxBufferParamsV1Listener* = object
  created*: proc(
    data: pointer;
    zwpLinuxBufferParamsV1: ptr ZwpLinuxBufferParamsV1;
    buffer: ptr Buffer;
  ) {.nimcall.}
  failed*: proc(
    data: pointer;
    zwpLinuxBufferParamsV1: ptr ZwpLinuxBufferParamsV1;
  ) {.nimcall.}
proc addListener*(zwpLinuxBufferParamsV1: ptr ZwpLinuxBufferParamsV1; listener: ptr ZwpLinuxBufferParamsV1Listener; data: pointer): int {.inline.} =
  cast[ptr Proxy](zwpLinuxBufferParamsV1).add_listener(listener, data)

proc setUserData*(zwpLinuxBufferParamsV1: ptr ZwpLinuxBufferParamsV1; userData: pointer) {.inline.} =
  cast[ptr Proxy](zwpLinuxBufferParamsV1).set_user_data(user_data)
proc getUserData*(zwpLinuxBufferParamsV1: ptr ZwpLinuxBufferParamsV1): pointer {.inline.} =
  cast[ptr Proxy](zwpLinuxBufferParamsV1).get_user_data()
proc getVersion*(zwpLinuxBufferParamsV1: ptr ZwpLinuxBufferParamsV1): uint32 {.inline.} =
  cast[ptr Proxy](zwpLinuxBufferParamsV1).get_version()
proc destroy*(zwpLinuxBufferParamsV1: ptr ZwpLinuxBufferParamsV1) {.inline.} =
  ## delete this object, used or not
  ## 
  ## Cleans up the temporary data sent to the server for dmabuf-based
  ## wl_buffer creation.
  ## 
  cast[ptr Proxy](zwpLinuxBufferParamsV1).marshal_flags(ZwpLinuxBufferParamsV1Request_destroy.ord, nil, cast[ptr Proxy](zwpLinuxBufferParamsV1).get_version(), WL_MARSHAL_FLAG_DESTROY)
proc add*(zwpLinuxBufferParamsV1: ptr ZwpLinuxBufferParamsV1; fd: int32; planeIdx: uint32; offset: uint32; stride: uint32; modifierHi: uint32; modifierLo: uint32) {.inline.} =
  ## add a dmabuf to the temporary set
  ## 
  ## This request adds one dmabuf to the set in this
  ## zwp_linux_buffer_params_v1.
  ## 
  ## The 64-bit unsigned value combined from modifier_hi and modifier_lo
  ## is the dmabuf layout modifier. DRM AddFB2 ioctl calls this the
  ## fb modifier, which is defined in drm_mode.h of Linux UAPI.
  ## This is an opaque token. Drivers use this token to express tiling,
  ## compression, etc. driver-specific modifications to the base format
  ## defined by the DRM fourcc code.
  ## 
  ## Starting from version 4, the invalid_format protocol error is sent if
  ## the format + modifier pair was not advertised as supported.
  ## 
  ## Starting from version 5, the invalid_format protocol error is sent if
  ## all planes don't use the same modifier.
  ## 
  ## This request raises the PLANE_IDX error if plane_idx is too large.
  ## The error PLANE_SET is raised if attempting to set a plane that
  ## was already set.
  ## 
  cast[ptr Proxy](zwpLinuxBufferParamsV1).marshal_flags(ZwpLinuxBufferParamsV1Request_add.ord, nil, cast[ptr Proxy](zwpLinuxBufferParamsV1).get_version(), 0, fd, planeIdx, offset, stride, modifierHi, modifierLo)
proc create*(zwpLinuxBufferParamsV1: ptr ZwpLinuxBufferParamsV1; width: int32; height: int32; format: uint32; flags: uint32) {.inline.} =
  ## create a wl_buffer from the given dmabufs
  ## 
  ## This asks for creation of a wl_buffer from the added dmabuf
  ## buffers. The wl_buffer is not created immediately but returned via
  ## the 'created' event if the dmabuf sharing succeeds. The sharing
  ## may fail at runtime for reasons a client cannot predict, in
  ## which case the 'failed' event is triggered.
  ## 
  ## The 'format' argument is a DRM_FORMAT code, as defined by the
  ## libdrm's drm_fourcc.h. The Linux kernel's DRM sub-system is the
  ## authoritative source on how the format codes should work.
  ## 
  ## The 'flags' is a bitfield of the flags defined in enum "flags".
  ## 'y_invert' means the that the image needs to be y-flipped.
  ## 
  ## Flag 'interlaced' means that the frame in the buffer is not
  ## progressive as usual, but interlaced. An interlaced buffer as
  ## supported here must always contain both top and bottom fields.
  ## The top field always begins on the first pixel row. The temporal
  ## ordering between the two fields is top field first, unless
  ## 'bottom_first' is specified. It is undefined whether 'bottom_first'
  ## is ignored if 'interlaced' is not set.
  ## 
  ## This protocol does not convey any information about field rate,
  ## duration, or timing, other than the relative ordering between the
  ## two fields in one buffer. A compositor may have to estimate the
  ## intended field rate from the incoming buffer rate. It is undefined
  ## whether the time of receiving wl_surface.commit with a new buffer
  ## attached, applying the wl_surface state, wl_surface.frame callback
  ## trigger, presentation, or any other point in the compositor cycle
  ## is used to measure the frame or field times. There is no support
  ## for detecting missed or late frames/fields/buffers either, and
  ## there is no support whatsoever for cooperating with interlaced
  ## compositor output.
  ## 
  ## The composited image quality resulting from the use of interlaced
  ## buffers is explicitly undefined. A compositor may use elaborate
  ## hardware features or software to deinterlace and create progressive
  ## output frames from a sequence of interlaced input buffers, or it
  ## may produce substandard image quality. However, compositors that
  ## cannot guarantee reasonable image quality in all cases are recommended
  ## to just reject all interlaced buffers.
  ## 
  ## Any argument errors, including non-positive width or height,
  ## mismatch between the number of planes and the format, bad
  ## format, bad offset or stride, may be indicated by fatal protocol
  ## errors: INCOMPLETE, INVALID_FORMAT, INVALID_DIMENSIONS,
  ## OUT_OF_BOUNDS.
  ## 
  ## Dmabuf import errors in the server that are not obvious client
  ## bugs are returned via the 'failed' event as non-fatal. This
  ## allows attempting dmabuf sharing and falling back in the client
  ## if it fails.
  ## 
  ## This request can be sent only once in the object's lifetime, after
  ## which the only legal request is destroy. This object should be
  ## destroyed after issuing a 'create' request. Attempting to use this
  ## object after issuing 'create' raises ALREADY_USED protocol error.
  ## 
  ## It is not mandatory to issue 'create'. If a client wants to
  ## cancel the buffer creation, it can just destroy this object.
  ## 
  cast[ptr Proxy](zwpLinuxBufferParamsV1).marshal_flags(ZwpLinuxBufferParamsV1Request_create.ord, nil, cast[ptr Proxy](zwpLinuxBufferParamsV1).get_version(), 0, width, height, format, flags)
proc createImmed*(zwpLinuxBufferParamsV1: ptr ZwpLinuxBufferParamsV1; width: int32; height: int32; format: uint32; flags: uint32): ptr Buffer {.inline.} =
  ## immediately create a wl_buffer from the given dmabufs
  ## 
  ## This asks for immediate creation of a wl_buffer by importing the
  ## added dmabufs.
  ## 
  ## In case of import success, no event is sent from the server, and the
  ## wl_buffer is ready to be used by the client.
  ## 
  ## Upon import failure, either of the following may happen, as seen fit
  ## by the implementation:
  ## - the client is terminated with one of the following fatal protocol
  ## errors:
  ## - INCOMPLETE, INVALID_FORMAT, INVALID_DIMENSIONS, OUT_OF_BOUNDS,
  ## in case of argument errors such as mismatch between the number
  ## of planes and the format, bad format, non-positive width or
  ## height, or bad offset or stride.
  ## - INVALID_WL_BUFFER, in case the cause for failure is unknown or
  ## platform specific.
  ## - the server creates an invalid wl_buffer, marks it as failed and
  ## sends a 'failed' event to the client. The result of using this
  ## invalid wl_buffer as an argument in any request by the client is
  ## defined by the compositor implementation.
  ## 
  ## This takes the same arguments as a 'create' request, and obeys the
  ## same restrictions.
  ## 
  cast[ptr Buffer](cast[ptr Proxy](zwpLinuxBufferParamsV1).marshal_flags(ZwpLinuxBufferParamsV1Request_create_immed.ord, addr wl_buffer_interface, cast[ptr Proxy](zwpLinuxBufferParamsV1).get_version(), 0, nil, width, height, format, flags))
type ZwpLinuxDmabufFeedbackV1Listener* = object
  done*: proc(
    data: pointer;
    zwpLinuxDmabufFeedbackV1: ptr ZwpLinuxDmabufFeedbackV1;
  ) {.nimcall.}
  formatTable*: proc(
    data: pointer;
    zwpLinuxDmabufFeedbackV1: ptr ZwpLinuxDmabufFeedbackV1;
    fd: int32;
    size: uint32;
  ) {.nimcall.}
  mainDevice*: proc(
    data: pointer;
    zwpLinuxDmabufFeedbackV1: ptr ZwpLinuxDmabufFeedbackV1;
    device: ptr Array;
  ) {.nimcall.}
  trancheDone*: proc(
    data: pointer;
    zwpLinuxDmabufFeedbackV1: ptr ZwpLinuxDmabufFeedbackV1;
  ) {.nimcall.}
  trancheTargetDevice*: proc(
    data: pointer;
    zwpLinuxDmabufFeedbackV1: ptr ZwpLinuxDmabufFeedbackV1;
    device: ptr Array;
  ) {.nimcall.}
  trancheFormats*: proc(
    data: pointer;
    zwpLinuxDmabufFeedbackV1: ptr ZwpLinuxDmabufFeedbackV1;
    indices: ptr Array;
  ) {.nimcall.}
  trancheFlags*: proc(
    data: pointer;
    zwpLinuxDmabufFeedbackV1: ptr ZwpLinuxDmabufFeedbackV1;
    flags: uint32;
  ) {.nimcall.}
proc addListener*(zwpLinuxDmabufFeedbackV1: ptr ZwpLinuxDmabufFeedbackV1; listener: ptr ZwpLinuxDmabufFeedbackV1Listener; data: pointer): int {.inline.} =
  cast[ptr Proxy](zwpLinuxDmabufFeedbackV1).add_listener(listener, data)

proc setUserData*(zwpLinuxDmabufFeedbackV1: ptr ZwpLinuxDmabufFeedbackV1; userData: pointer) {.inline.} =
  cast[ptr Proxy](zwpLinuxDmabufFeedbackV1).set_user_data(user_data)
proc getUserData*(zwpLinuxDmabufFeedbackV1: ptr ZwpLinuxDmabufFeedbackV1): pointer {.inline.} =
  cast[ptr Proxy](zwpLinuxDmabufFeedbackV1).get_user_data()
proc getVersion*(zwpLinuxDmabufFeedbackV1: ptr ZwpLinuxDmabufFeedbackV1): uint32 {.inline.} =
  cast[ptr Proxy](zwpLinuxDmabufFeedbackV1).get_version()
proc destroy*(zwpLinuxDmabufFeedbackV1: ptr ZwpLinuxDmabufFeedbackV1) {.inline.} =
  ## destroy the feedback object
  ## 
  ## Using this request a client can tell the server that it is not going to
  ## use the wp_linux_dmabuf_feedback object anymore.
  ## 
  cast[ptr Proxy](zwpLinuxDmabufFeedbackV1).marshal_flags(ZwpLinuxDmabufFeedbackV1Request_destroy.ord, nil, cast[ptr Proxy](zwpLinuxDmabufFeedbackV1).get_version(), WL_MARSHAL_FLAG_DESTROY)
