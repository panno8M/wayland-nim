# Generated by wayland-nim-scanner 1.23.1
{.warning[UnusedImport]:off.}
import wayland/native/client
import wayland/native/common
import wayland/protocols/staging/extImageCaptureSource/v1/client as extImageCaptureSource_client
import code
export code

## The ext_image_copy_capture_v1 CLIENT protocol
## #############################################
## 
## Interfaces
## ==========
## 
## * ext_image_copy_capture_manager_v1
## * ext_image_copy_capture_session_v1
## * ext_image_copy_capture_frame_v1
## * ext_image_copy_capture_cursor_session_v1
## 
## Copyright
## =========
## 
## Copyright © 2021-2023 Andri Yngvason
## Copyright © 2024 Simon Ser
## 
## Permission is hereby granted, free of charge, to any person obtaining a
## copy of this software and associated documentation files (the "Software"),
## to deal in the Software without restriction, including without limitation
## the rights to use, copy, modify, merge, publish, distribute, sublicense,
## and/or sell copies of the Software, and to permit persons to whom the
## Software is furnished to do so, subject to the following conditions:
## 
## The above copyright notice and this permission notice (including the next
## paragraph) shall be included in all copies or substantial portions of the
## Software.
## 
## THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
## IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
## FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
## THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
## LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
## FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
## DEALINGS IN THE SOFTWARE.
## 

proc setUserData*(extImageCopyCaptureManagerV1: ptr ExtImageCopyCaptureManagerV1; userData: pointer) {.inline.} =
  cast[ptr Proxy](extImageCopyCaptureManagerV1).set_user_data(user_data)
proc getUserData*(extImageCopyCaptureManagerV1: ptr ExtImageCopyCaptureManagerV1): pointer {.inline.} =
  cast[ptr Proxy](extImageCopyCaptureManagerV1).get_user_data()
proc getVersion*(extImageCopyCaptureManagerV1: ptr ExtImageCopyCaptureManagerV1): uint32 {.inline.} =
  cast[ptr Proxy](extImageCopyCaptureManagerV1).get_version()
proc createSession*(extImageCopyCaptureManagerV1: ptr ExtImageCopyCaptureManagerV1; source: ptr ExtImageCaptureSourceV1; options: uint32): ptr ExtImageCopyCaptureSessionV1 {.inline.} =
  ## capture an image capture source
  ## 
  ## Create a capturing session for an image capture source.
  ## 
  ## If the paint_cursors option is set, cursors shall be composited onto
  ## the captured frame. The cursor must not be composited onto the frame
  ## if this flag is not set.
  ## 
  ## If the options bitfield is invalid, the invalid_option protocol error
  ## is sent.
  ## 
  cast[ptr ExtImageCopyCaptureSessionV1](cast[ptr Proxy](extImageCopyCaptureManagerV1).marshal_flags(ExtImageCopyCaptureManagerV1Request_create_session.ord, addr ext_image_copy_capture_session_v1_interface, cast[ptr Proxy](extImageCopyCaptureManagerV1).get_version(), 0, nil, source, options))
proc createPointerCursorSession*(extImageCopyCaptureManagerV1: ptr ExtImageCopyCaptureManagerV1; source: ptr ExtImageCaptureSourceV1; pointer: ptr Pointer): ptr ExtImageCopyCaptureCursorSessionV1 {.inline.} =
  ## capture the pointer cursor of an image capture source
  ## 
  ## Create a cursor capturing session for the pointer of an image capture
  ## source.
  ## 
  cast[ptr ExtImageCopyCaptureCursorSessionV1](cast[ptr Proxy](extImageCopyCaptureManagerV1).marshal_flags(ExtImageCopyCaptureManagerV1Request_create_pointer_cursor_session.ord, addr ext_image_copy_capture_cursor_session_v1_interface, cast[ptr Proxy](extImageCopyCaptureManagerV1).get_version(), 0, nil, source, pointer))
proc destroy*(extImageCopyCaptureManagerV1: ptr ExtImageCopyCaptureManagerV1) {.inline.} =
  ## destroy the manager
  ## 
  ## Destroy the manager object.
  ## 
  ## Other objects created via this interface are unaffected.
  ## 
  cast[ptr Proxy](extImageCopyCaptureManagerV1).marshal_flags(ExtImageCopyCaptureManagerV1Request_destroy.ord, nil, cast[ptr Proxy](extImageCopyCaptureManagerV1).get_version(), WL_MARSHAL_FLAG_DESTROY)
type ExtImageCopyCaptureSessionV1Listener* = object
  bufferSize*: proc(
    data: pointer;
    extImageCopyCaptureSessionV1: ptr ExtImageCopyCaptureSessionV1;
    width: uint32;
    height: uint32;
  ) {.nimcall.}
  shmFormat*: proc(
    data: pointer;
    extImageCopyCaptureSessionV1: ptr ExtImageCopyCaptureSessionV1;
    format: uint32;
  ) {.nimcall.}
  dmabufDevice*: proc(
    data: pointer;
    extImageCopyCaptureSessionV1: ptr ExtImageCopyCaptureSessionV1;
    device: ptr Array;
  ) {.nimcall.}
  dmabufFormat*: proc(
    data: pointer;
    extImageCopyCaptureSessionV1: ptr ExtImageCopyCaptureSessionV1;
    format: uint32;
    modifiers: ptr Array;
  ) {.nimcall.}
  done*: proc(
    data: pointer;
    extImageCopyCaptureSessionV1: ptr ExtImageCopyCaptureSessionV1;
  ) {.nimcall.}
  stopped*: proc(
    data: pointer;
    extImageCopyCaptureSessionV1: ptr ExtImageCopyCaptureSessionV1;
  ) {.nimcall.}
proc addListener*(extImageCopyCaptureSessionV1: ptr ExtImageCopyCaptureSessionV1; listener: ptr ExtImageCopyCaptureSessionV1Listener; data: pointer): int {.inline.} =
  cast[ptr Proxy](extImageCopyCaptureSessionV1).add_listener(listener, data)

proc setUserData*(extImageCopyCaptureSessionV1: ptr ExtImageCopyCaptureSessionV1; userData: pointer) {.inline.} =
  cast[ptr Proxy](extImageCopyCaptureSessionV1).set_user_data(user_data)
proc getUserData*(extImageCopyCaptureSessionV1: ptr ExtImageCopyCaptureSessionV1): pointer {.inline.} =
  cast[ptr Proxy](extImageCopyCaptureSessionV1).get_user_data()
proc getVersion*(extImageCopyCaptureSessionV1: ptr ExtImageCopyCaptureSessionV1): uint32 {.inline.} =
  cast[ptr Proxy](extImageCopyCaptureSessionV1).get_version()
proc createFrame*(extImageCopyCaptureSessionV1: ptr ExtImageCopyCaptureSessionV1): ptr ExtImageCopyCaptureFrameV1 {.inline.} =
  ## create a frame
  ## 
  ## Create a capture frame for this session.
  ## 
  ## At most one frame object can exist for a given session at any time. If
  ## a client sends a create_frame request before a previous frame object
  ## has been destroyed, the duplicate_frame protocol error is raised.
  ## 
  cast[ptr ExtImageCopyCaptureFrameV1](cast[ptr Proxy](extImageCopyCaptureSessionV1).marshal_flags(ExtImageCopyCaptureSessionV1Request_create_frame.ord, addr ext_image_copy_capture_frame_v1_interface, cast[ptr Proxy](extImageCopyCaptureSessionV1).get_version(), 0, nil))
proc destroy*(extImageCopyCaptureSessionV1: ptr ExtImageCopyCaptureSessionV1) {.inline.} =
  ## delete this object
  ## 
  ## Destroys the session. This request can be sent at any time by the
  ## client.
  ## 
  ## This request doesn't affect ext_image_copy_capture_frame_v1 objects created by
  ## this object.
  ## 
  cast[ptr Proxy](extImageCopyCaptureSessionV1).marshal_flags(ExtImageCopyCaptureSessionV1Request_destroy.ord, nil, cast[ptr Proxy](extImageCopyCaptureSessionV1).get_version(), WL_MARSHAL_FLAG_DESTROY)
type ExtImageCopyCaptureFrameV1Listener* = object
  transform*: proc(
    data: pointer;
    extImageCopyCaptureFrameV1: ptr ExtImageCopyCaptureFrameV1;
    transform: uint32;
  ) {.nimcall.}
  damage*: proc(
    data: pointer;
    extImageCopyCaptureFrameV1: ptr ExtImageCopyCaptureFrameV1;
    x: int32;
    y: int32;
    width: int32;
    height: int32;
  ) {.nimcall.}
  presentationTime*: proc(
    data: pointer;
    extImageCopyCaptureFrameV1: ptr ExtImageCopyCaptureFrameV1;
    tvSecHi: uint32;
    tvSecLo: uint32;
    tvNsec: uint32;
  ) {.nimcall.}
  ready*: proc(
    data: pointer;
    extImageCopyCaptureFrameV1: ptr ExtImageCopyCaptureFrameV1;
  ) {.nimcall.}
  failed*: proc(
    data: pointer;
    extImageCopyCaptureFrameV1: ptr ExtImageCopyCaptureFrameV1;
    reason: uint32;
  ) {.nimcall.}
proc addListener*(extImageCopyCaptureFrameV1: ptr ExtImageCopyCaptureFrameV1; listener: ptr ExtImageCopyCaptureFrameV1Listener; data: pointer): int {.inline.} =
  cast[ptr Proxy](extImageCopyCaptureFrameV1).add_listener(listener, data)

proc setUserData*(extImageCopyCaptureFrameV1: ptr ExtImageCopyCaptureFrameV1; userData: pointer) {.inline.} =
  cast[ptr Proxy](extImageCopyCaptureFrameV1).set_user_data(user_data)
proc getUserData*(extImageCopyCaptureFrameV1: ptr ExtImageCopyCaptureFrameV1): pointer {.inline.} =
  cast[ptr Proxy](extImageCopyCaptureFrameV1).get_user_data()
proc getVersion*(extImageCopyCaptureFrameV1: ptr ExtImageCopyCaptureFrameV1): uint32 {.inline.} =
  cast[ptr Proxy](extImageCopyCaptureFrameV1).get_version()
proc destroy*(extImageCopyCaptureFrameV1: ptr ExtImageCopyCaptureFrameV1) {.inline.} =
  ## destroy this object
  ## 
  ## Destroys the frame. This request can be sent at any time by the
  ## client.
  ## 
  cast[ptr Proxy](extImageCopyCaptureFrameV1).marshal_flags(ExtImageCopyCaptureFrameV1Request_destroy.ord, nil, cast[ptr Proxy](extImageCopyCaptureFrameV1).get_version(), WL_MARSHAL_FLAG_DESTROY)
proc attachBuffer*(extImageCopyCaptureFrameV1: ptr ExtImageCopyCaptureFrameV1; buffer: ptr Buffer) {.inline.} =
  ## attach buffer to session
  ## 
  ## Attach a buffer to the session.
  ## 
  ## The wl_buffer.release request is unused.
  ## 
  ## The new buffer replaces any previously attached buffer.
  ## 
  ## This request must not be sent after capture, or else the
  ## already_captured protocol error is raised.
  ## 
  cast[ptr Proxy](extImageCopyCaptureFrameV1).marshal_flags(ExtImageCopyCaptureFrameV1Request_attach_buffer.ord, nil, cast[ptr Proxy](extImageCopyCaptureFrameV1).get_version(), 0, buffer)
proc damageBuffer*(extImageCopyCaptureFrameV1: ptr ExtImageCopyCaptureFrameV1; x: int32; y: int32; width: int32; height: int32) {.inline.} =
  ## damage buffer
  ## 
  ## Apply damage to the buffer which is to be captured next. This request
  ## may be sent multiple times to describe a region.
  ## 
  ## The client indicates the accumulated damage since this wl_buffer was
  ## last captured. During capture, the compositor will update the buffer
  ## with at least the union of the region passed by the client and the
  ## region advertised by ext_image_copy_capture_frame_v1.damage.
  ## 
  ## When a wl_buffer is captured for the first time, or when the client
  ## doesn't track damage, the client must damage the whole buffer.
  ## 
  ## This is for optimisation purposes. The compositor may use this
  ## information to reduce copying.
  ## 
  ## These coordinates originate from the upper left corner of the buffer.
  ## 
  ## If x or y are strictly negative, or if width or height are negative or
  ## zero, the invalid_buffer_damage protocol error is raised.
  ## 
  ## This request must not be sent after capture, or else the
  ## already_captured protocol error is raised.
  ## 
  cast[ptr Proxy](extImageCopyCaptureFrameV1).marshal_flags(ExtImageCopyCaptureFrameV1Request_damage_buffer.ord, nil, cast[ptr Proxy](extImageCopyCaptureFrameV1).get_version(), 0, x, y, width, height)
proc capture*(extImageCopyCaptureFrameV1: ptr ExtImageCopyCaptureFrameV1) {.inline.} =
  ## capture a frame
  ## 
  ## Capture a frame.
  ## 
  ## Unless this is the first successful captured frame performed in this
  ## session, the compositor may wait an indefinite amount of time for the
  ## source content to change before performing the copy.
  ## 
  ## This request may only be sent once, or else the already_captured
  ## protocol error is raised. A buffer must be attached before this request
  ## is sent, or else the no_buffer protocol error is raised.
  ## 
  cast[ptr Proxy](extImageCopyCaptureFrameV1).marshal_flags(ExtImageCopyCaptureFrameV1Request_capture.ord, nil, cast[ptr Proxy](extImageCopyCaptureFrameV1).get_version(), 0)
type ExtImageCopyCaptureCursorSessionV1Listener* = object
  enter*: proc(
    data: pointer;
    extImageCopyCaptureCursorSessionV1: ptr ExtImageCopyCaptureCursorSessionV1;
  ) {.nimcall.}
  leave*: proc(
    data: pointer;
    extImageCopyCaptureCursorSessionV1: ptr ExtImageCopyCaptureCursorSessionV1;
  ) {.nimcall.}
  position*: proc(
    data: pointer;
    extImageCopyCaptureCursorSessionV1: ptr ExtImageCopyCaptureCursorSessionV1;
    x: int32;
    y: int32;
  ) {.nimcall.}
  hotspot*: proc(
    data: pointer;
    extImageCopyCaptureCursorSessionV1: ptr ExtImageCopyCaptureCursorSessionV1;
    x: int32;
    y: int32;
  ) {.nimcall.}
proc addListener*(extImageCopyCaptureCursorSessionV1: ptr ExtImageCopyCaptureCursorSessionV1; listener: ptr ExtImageCopyCaptureCursorSessionV1Listener; data: pointer): int {.inline.} =
  cast[ptr Proxy](extImageCopyCaptureCursorSessionV1).add_listener(listener, data)

proc setUserData*(extImageCopyCaptureCursorSessionV1: ptr ExtImageCopyCaptureCursorSessionV1; userData: pointer) {.inline.} =
  cast[ptr Proxy](extImageCopyCaptureCursorSessionV1).set_user_data(user_data)
proc getUserData*(extImageCopyCaptureCursorSessionV1: ptr ExtImageCopyCaptureCursorSessionV1): pointer {.inline.} =
  cast[ptr Proxy](extImageCopyCaptureCursorSessionV1).get_user_data()
proc getVersion*(extImageCopyCaptureCursorSessionV1: ptr ExtImageCopyCaptureCursorSessionV1): uint32 {.inline.} =
  cast[ptr Proxy](extImageCopyCaptureCursorSessionV1).get_version()
proc destroy*(extImageCopyCaptureCursorSessionV1: ptr ExtImageCopyCaptureCursorSessionV1) {.inline.} =
  ## delete this object
  ## 
  ## Destroys the session. This request can be sent at any time by the
  ## client.
  ## 
  ## This request doesn't affect ext_image_copy_capture_frame_v1 objects created by
  ## this object.
  ## 
  cast[ptr Proxy](extImageCopyCaptureCursorSessionV1).marshal_flags(ExtImageCopyCaptureCursorSessionV1Request_destroy.ord, nil, cast[ptr Proxy](extImageCopyCaptureCursorSessionV1).get_version(), WL_MARSHAL_FLAG_DESTROY)
proc getCaptureSession*(extImageCopyCaptureCursorSessionV1: ptr ExtImageCopyCaptureCursorSessionV1): ptr ExtImageCopyCaptureSessionV1 {.inline.} =
  ## get image copy capturer session
  ## 
  ## Gets the image copy capture session for this cursor session.
  ## 
  ## The session will produce frames of the cursor image. The compositor may
  ## pause the session when the cursor leaves the captured area.
  ## 
  ## This request must not be sent more than once, or else the
  ## duplicate_session protocol error is raised.
  ## 
  cast[ptr ExtImageCopyCaptureSessionV1](cast[ptr Proxy](extImageCopyCaptureCursorSessionV1).marshal_flags(ExtImageCopyCaptureCursorSessionV1Request_get_capture_session.ord, addr ext_image_copy_capture_session_v1_interface, cast[ptr Proxy](extImageCopyCaptureCursorSessionV1).get_version(), 0, nil))
