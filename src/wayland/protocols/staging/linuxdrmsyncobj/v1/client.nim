# Generated by wayland-nim-scanner 1.23.1
{.warning[UnusedImport]:off.}
import wayland/native/client
import wayland/native/common
import code
export code

## The linux_drm_syncobj_v1 CLIENT protocol
## ########################################
## 
## Interfaces
## ==========
## 
## * wp_linux_drm_syncobj_manager_v1
## * wp_linux_drm_syncobj_timeline_v1
## * wp_linux_drm_syncobj_surface_v1
## 
## Copyright
## =========
## 
## Copyright 2016 The Chromium Authors.
## Copyright 2017 Intel Corporation
## Copyright 2018 Collabora, Ltd
## Copyright 2021 Simon Ser
## 
## Permission is hereby granted, free of charge, to any person obtaining a
## copy of this software and associated documentation files (the "Software"),
## to deal in the Software without restriction, including without limitation
## the rights to use, copy, modify, merge, publish, distribute, sublicense,
## and/or sell copies of the Software, and to permit persons to whom the
## Software is furnished to do so, subject to the following conditions:
## 
## The above copyright notice and this permission notice (including the next
## paragraph) shall be included in all copies or substantial portions of the
## Software.
## 
## THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
## IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
## FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
## THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
## LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
## FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
## DEALINGS IN THE SOFTWARE.
## 

proc setUserData*(wpLinuxDrmSyncobjManagerV1: ptr WpLinuxDrmSyncobjManagerV1; userData: pointer) {.inline.} =
  cast[ptr Proxy](wpLinuxDrmSyncobjManagerV1).set_user_data(user_data)
proc getUserData*(wpLinuxDrmSyncobjManagerV1: ptr WpLinuxDrmSyncobjManagerV1): pointer {.inline.} =
  cast[ptr Proxy](wpLinuxDrmSyncobjManagerV1).get_user_data()
proc getVersion*(wpLinuxDrmSyncobjManagerV1: ptr WpLinuxDrmSyncobjManagerV1): uint32 {.inline.} =
  cast[ptr Proxy](wpLinuxDrmSyncobjManagerV1).get_version()
proc destroy*(wpLinuxDrmSyncobjManagerV1: ptr WpLinuxDrmSyncobjManagerV1) {.inline.} =
  ## destroy explicit synchronization factory object
  ## 
  ## Destroy this explicit synchronization factory object. Other objects
  ## shall not be affected by this request.
  ## 
  cast[ptr Proxy](wpLinuxDrmSyncobjManagerV1).marshal_flags(WpLinuxDrmSyncobjManagerV1Request_destroy.ord, nil, cast[ptr Proxy](wpLinuxDrmSyncobjManagerV1).get_version(), WL_MARSHAL_FLAG_DESTROY)
proc getSurface*(wpLinuxDrmSyncobjManagerV1: ptr WpLinuxDrmSyncobjManagerV1; surface: ptr Surface): ptr WpLinuxDrmSyncobjSurfaceV1 {.inline.} =
  ## extend surface interface for explicit synchronization
  ## 
  ## Instantiate an interface extension for the given wl_surface to provide
  ## explicit synchronization.
  ## 
  ## If the given wl_surface already has an explicit synchronization object
  ## associated, the surface_exists protocol error is raised.
  ## 
  ## Graphics APIs, like EGL or Vulkan, that manage the buffer queue and
  ## commits of a wl_surface themselves, are likely to be using this
  ## extension internally. If a client is using such an API for a
  ## wl_surface, it should not directly use this extension on that surface,
  ## to avoid raising a surface_exists protocol error.
  ## 
  cast[ptr WpLinuxDrmSyncobjSurfaceV1](cast[ptr Proxy](wpLinuxDrmSyncobjManagerV1).marshal_flags(WpLinuxDrmSyncobjManagerV1Request_get_surface.ord, addr wp_linux_drm_syncobj_surface_v1_interface, cast[ptr Proxy](wpLinuxDrmSyncobjManagerV1).get_version(), 0, nil, surface))
proc importTimeline*(wpLinuxDrmSyncobjManagerV1: ptr WpLinuxDrmSyncobjManagerV1; fd: int32): ptr WpLinuxDrmSyncobjTimelineV1 {.inline.} =
  ## import a DRM syncobj timeline
  ## 
  ## Import a DRM synchronization object timeline.
  ## 
  ## If the FD cannot be imported, the invalid_timeline error is raised.
  ## 
  cast[ptr WpLinuxDrmSyncobjTimelineV1](cast[ptr Proxy](wpLinuxDrmSyncobjManagerV1).marshal_flags(WpLinuxDrmSyncobjManagerV1Request_import_timeline.ord, addr wp_linux_drm_syncobj_timeline_v1_interface, cast[ptr Proxy](wpLinuxDrmSyncobjManagerV1).get_version(), 0, nil, fd))
proc setUserData*(wpLinuxDrmSyncobjTimelineV1: ptr WpLinuxDrmSyncobjTimelineV1; userData: pointer) {.inline.} =
  cast[ptr Proxy](wpLinuxDrmSyncobjTimelineV1).set_user_data(user_data)
proc getUserData*(wpLinuxDrmSyncobjTimelineV1: ptr WpLinuxDrmSyncobjTimelineV1): pointer {.inline.} =
  cast[ptr Proxy](wpLinuxDrmSyncobjTimelineV1).get_user_data()
proc getVersion*(wpLinuxDrmSyncobjTimelineV1: ptr WpLinuxDrmSyncobjTimelineV1): uint32 {.inline.} =
  cast[ptr Proxy](wpLinuxDrmSyncobjTimelineV1).get_version()
proc destroy*(wpLinuxDrmSyncobjTimelineV1: ptr WpLinuxDrmSyncobjTimelineV1) {.inline.} =
  ## destroy the timeline
  ## 
  ## Destroy the synchronization object timeline. Other objects are not
  ## affected by this request, in particular timeline points set by
  ## set_acquire_point and set_release_point are not unset.
  ## 
  cast[ptr Proxy](wpLinuxDrmSyncobjTimelineV1).marshal_flags(WpLinuxDrmSyncobjTimelineV1Request_destroy.ord, nil, cast[ptr Proxy](wpLinuxDrmSyncobjTimelineV1).get_version(), WL_MARSHAL_FLAG_DESTROY)
proc setUserData*(wpLinuxDrmSyncobjSurfaceV1: ptr WpLinuxDrmSyncobjSurfaceV1; userData: pointer) {.inline.} =
  cast[ptr Proxy](wpLinuxDrmSyncobjSurfaceV1).set_user_data(user_data)
proc getUserData*(wpLinuxDrmSyncobjSurfaceV1: ptr WpLinuxDrmSyncobjSurfaceV1): pointer {.inline.} =
  cast[ptr Proxy](wpLinuxDrmSyncobjSurfaceV1).get_user_data()
proc getVersion*(wpLinuxDrmSyncobjSurfaceV1: ptr WpLinuxDrmSyncobjSurfaceV1): uint32 {.inline.} =
  cast[ptr Proxy](wpLinuxDrmSyncobjSurfaceV1).get_version()
proc destroy*(wpLinuxDrmSyncobjSurfaceV1: ptr WpLinuxDrmSyncobjSurfaceV1) {.inline.} =
  ## destroy the surface synchronization object
  ## 
  ## Destroy this surface synchronization object.
  ## 
  ## Any timeline point set by this object with set_acquire_point or
  ## set_release_point since the last commit may be discarded by the
  ## compositor. Any timeline point set by this object before the last
  ## commit will not be affected.
  ## 
  cast[ptr Proxy](wpLinuxDrmSyncobjSurfaceV1).marshal_flags(WpLinuxDrmSyncobjSurfaceV1Request_destroy.ord, nil, cast[ptr Proxy](wpLinuxDrmSyncobjSurfaceV1).get_version(), WL_MARSHAL_FLAG_DESTROY)
proc setAcquirePoint*(wpLinuxDrmSyncobjSurfaceV1: ptr WpLinuxDrmSyncobjSurfaceV1; timeline: ptr WpLinuxDrmSyncobjTimelineV1; pointHi: uint32; pointLo: uint32) {.inline.} =
  ## set the acquire timeline point
  ## 
  ## Set the timeline point that must be signalled before the compositor may
  ## sample from the buffer attached with wl_surface.attach.
  ## 
  ## The 64-bit unsigned value combined from point_hi and point_lo is the
  ## point value.
  ## 
  ## The acquire point is double-buffered state, and will be applied on the
  ## next wl_surface.commit request for the associated surface. Thus, it
  ## applies only to the buffer that is attached to the surface at commit
  ## time.
  ## 
  ## If an acquire point has already been attached during the same commit
  ## cycle, the new point replaces the old one.
  ## 
  ## If the associated wl_surface was destroyed, a no_surface error is
  ## raised.
  ## 
  ## If at surface commit time there is a pending acquire timeline point set
  ## but no pending buffer attached, a no_buffer error is raised. If at
  ## surface commit time there is a pending buffer attached but no pending
  ## acquire timeline point set, the no_acquire_point protocol error is
  ## raised.
  ## 
  cast[ptr Proxy](wpLinuxDrmSyncobjSurfaceV1).marshal_flags(WpLinuxDrmSyncobjSurfaceV1Request_set_acquire_point.ord, nil, cast[ptr Proxy](wpLinuxDrmSyncobjSurfaceV1).get_version(), 0, timeline, pointHi, pointLo)
proc setReleasePoint*(wpLinuxDrmSyncobjSurfaceV1: ptr WpLinuxDrmSyncobjSurfaceV1; timeline: ptr WpLinuxDrmSyncobjTimelineV1; pointHi: uint32; pointLo: uint32) {.inline.} =
  ## set the release timeline point
  ## 
  ## Set the timeline point that must be signalled by the compositor when it
  ## has finished its usage of the buffer attached with wl_surface.attach
  ## for the relevant commit.
  ## 
  ## Once the timeline point is signaled, and assuming the associated buffer
  ## is not pending release from other wl_surface.commit requests, no
  ## additional explicit or implicit synchronization with the compositor is
  ## required to safely re-use the buffer.
  ## 
  ## Note that clients cannot rely on the release point being always
  ## signaled after the acquire point: compositors may release buffers
  ## without ever reading from them. In addition, the compositor may use
  ## different presentation paths for different commits, which may have
  ## different release behavior. As a result, the compositor may signal the
  ## release points in a different order than the client committed them.
  ## 
  ## Because signaling a timeline point also signals every previous point,
  ## it is generally not safe to use the same timeline object for the
  ## release points of multiple buffers. The out-of-order signaling
  ## described above may lead to a release point being signaled before the
  ## compositor has finished reading. To avoid this, it is strongly
  ## recommended that each buffer should use a separate timeline for its
  ## release points.
  ## 
  ## The 64-bit unsigned value combined from point_hi and point_lo is the
  ## point value.
  ## 
  ## The release point is double-buffered state, and will be applied on the
  ## next wl_surface.commit request for the associated surface. Thus, it
  ## applies only to the buffer that is attached to the surface at commit
  ## time.
  ## 
  ## If a release point has already been attached during the same commit
  ## cycle, the new point replaces the old one.
  ## 
  ## If the associated wl_surface was destroyed, a no_surface error is
  ## raised.
  ## 
  ## If at surface commit time there is a pending release timeline point set
  ## but no pending buffer attached, a no_buffer error is raised. If at
  ## surface commit time there is a pending buffer attached but no pending
  ## release timeline point set, the no_release_point protocol error is
  ## raised.
  ## 
  cast[ptr Proxy](wpLinuxDrmSyncobjSurfaceV1).marshal_flags(WpLinuxDrmSyncobjSurfaceV1Request_set_release_point.ord, nil, cast[ptr Proxy](wpLinuxDrmSyncobjSurfaceV1).get_version(), 0, timeline, pointHi, pointLo)
