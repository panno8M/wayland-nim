# Generated by wayland-nim-scanner 1.23.1
{.warning[UnusedImport]:off.}
import wayland/native/client
import wayland/native/common
import code
export code

## The ext_foreign_toplevel_list_v1 CLIENT protocol
## ################################################
## 
## Interfaces
## ==========
## 
## * ext_foreign_toplevel_list_v1
## * ext_foreign_toplevel_handle_v1
## 
## Copyright
## =========
## 
## Copyright © 2018 Ilia Bozhinov
## Copyright © 2020 Isaac Freund
## Copyright © 2022 wb9688
## Copyright © 2023 i509VCB
## 
## Permission to use, copy, modify, distribute, and sell this
## software and its documentation for any purpose is hereby granted
## without fee, provided that the above copyright notice appear in
## all copies and that both that copyright notice and this permission
## notice appear in supporting documentation, and that the name of
## the copyright holders not be used in advertising or publicity
## pertaining to distribution of the software without specific,
## written prior permission.  The copyright holders make no
## representations about the suitability of this software for any
## purpose.  It is provided "as is" without express or implied
## warranty.
## 
## THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
## SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
## FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
## SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
## WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
## AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
## ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
## THIS SOFTWARE.
## 

type ExtForeignToplevelListV1Listener* = object
  toplevel*: proc(
    data: pointer;
    extForeignToplevelListV1: ptr ExtForeignToplevelListV1;
    toplevel: ptr ExtForeignToplevelHandleV1;
  ) {.nimcall.}
  finished*: proc(
    data: pointer;
    extForeignToplevelListV1: ptr ExtForeignToplevelListV1;
  ) {.nimcall.}
proc addListener*(extForeignToplevelListV1: ptr ExtForeignToplevelListV1; listener: ptr ExtForeignToplevelListV1Listener; data: pointer): int {.inline.} =
  cast[ptr Proxy](extForeignToplevelListV1).add_listener(listener, data)

proc setUserData*(extForeignToplevelListV1: ptr ExtForeignToplevelListV1; userData: pointer) {.inline.} =
  cast[ptr Proxy](extForeignToplevelListV1).set_user_data(user_data)
proc getUserData*(extForeignToplevelListV1: ptr ExtForeignToplevelListV1): pointer {.inline.} =
  cast[ptr Proxy](extForeignToplevelListV1).get_user_data()
proc getVersion*(extForeignToplevelListV1: ptr ExtForeignToplevelListV1): uint32 {.inline.} =
  cast[ptr Proxy](extForeignToplevelListV1).get_version()
proc stop*(extForeignToplevelListV1: ptr ExtForeignToplevelListV1) {.inline.} =
  ## stop sending events
  ## 
  ## This request indicates that the client no longer wishes to receive
  ## events for new toplevels.
  ## 
  ## The Wayland protocol is asynchronous, meaning the compositor may send
  ## further toplevel events until the stop request is processed.
  ## The client should wait for a ext_foreign_toplevel_list_v1.finished
  ## event before destroying this object.
  ## 
  cast[ptr Proxy](extForeignToplevelListV1).marshal_flags(ExtForeignToplevelListV1Request_stop.ord, nil, cast[ptr Proxy](extForeignToplevelListV1).get_version(), 0)
proc destroy*(extForeignToplevelListV1: ptr ExtForeignToplevelListV1) {.inline.} =
  ## destroy the ext_foreign_toplevel_list_v1 object
  ## 
  ## This request should be called either when the client will no longer
  ## use the ext_foreign_toplevel_list_v1 or after the finished event
  ## has been received to allow destruction of the object.
  ## 
  ## If a client wishes to destroy this object it should send a
  ## ext_foreign_toplevel_list_v1.stop request and wait for a ext_foreign_toplevel_list_v1.finished
  ## event, then destroy the handles and then this object.
  ## 
  cast[ptr Proxy](extForeignToplevelListV1).marshal_flags(ExtForeignToplevelListV1Request_destroy.ord, nil, cast[ptr Proxy](extForeignToplevelListV1).get_version(), WL_MARSHAL_FLAG_DESTROY)
type ExtForeignToplevelHandleV1Listener* = object
  closed*: proc(
    data: pointer;
    extForeignToplevelHandleV1: ptr ExtForeignToplevelHandleV1;
  ) {.nimcall.}
  done*: proc(
    data: pointer;
    extForeignToplevelHandleV1: ptr ExtForeignToplevelHandleV1;
  ) {.nimcall.}
  title*: proc(
    data: pointer;
    extForeignToplevelHandleV1: ptr ExtForeignToplevelHandleV1;
    title: cstring;
  ) {.nimcall.}
  appId*: proc(
    data: pointer;
    extForeignToplevelHandleV1: ptr ExtForeignToplevelHandleV1;
    appId: cstring;
  ) {.nimcall.}
  identifier*: proc(
    data: pointer;
    extForeignToplevelHandleV1: ptr ExtForeignToplevelHandleV1;
    identifier: cstring;
  ) {.nimcall.}
proc addListener*(extForeignToplevelHandleV1: ptr ExtForeignToplevelHandleV1; listener: ptr ExtForeignToplevelHandleV1Listener; data: pointer): int {.inline.} =
  cast[ptr Proxy](extForeignToplevelHandleV1).add_listener(listener, data)

proc setUserData*(extForeignToplevelHandleV1: ptr ExtForeignToplevelHandleV1; userData: pointer) {.inline.} =
  cast[ptr Proxy](extForeignToplevelHandleV1).set_user_data(user_data)
proc getUserData*(extForeignToplevelHandleV1: ptr ExtForeignToplevelHandleV1): pointer {.inline.} =
  cast[ptr Proxy](extForeignToplevelHandleV1).get_user_data()
proc getVersion*(extForeignToplevelHandleV1: ptr ExtForeignToplevelHandleV1): uint32 {.inline.} =
  cast[ptr Proxy](extForeignToplevelHandleV1).get_version()
proc destroy*(extForeignToplevelHandleV1: ptr ExtForeignToplevelHandleV1) {.inline.} =
  ## destroy the ext_foreign_toplevel_handle_v1 object
  ## 
  ## This request should be used when the client will no longer use the handle
  ## or after the closed event has been received to allow destruction of the
  ## object.
  ## 
  ## When a handle is destroyed, a new handle may not be created by the server
  ## until the toplevel is unmapped and then remapped. Destroying a toplevel handle
  ## is not recommended unless the client is cleaning up child objects
  ## before destroying the ext_foreign_toplevel_list_v1 object, the toplevel
  ## was closed or the toplevel handle will not be used in the future.
  ## 
  ## Other protocols which extend the ext_foreign_toplevel_handle_v1
  ## interface should require destructors for extension interfaces be
  ## called before allowing the toplevel handle to be destroyed.
  ## 
  cast[ptr Proxy](extForeignToplevelHandleV1).marshal_flags(ExtForeignToplevelHandleV1Request_destroy.ord, nil, cast[ptr Proxy](extForeignToplevelHandleV1).get_version(), WL_MARSHAL_FLAG_DESTROY)
