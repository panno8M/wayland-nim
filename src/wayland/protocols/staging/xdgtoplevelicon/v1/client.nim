# Generated by wayland-nim-scanner 1.23.1
{.warning[UnusedImport]:off.}
import wayland/native/client
import wayland/native/common
import wayland/protocols/stable/xdgShell/client as xdgShell_client
import code
export code

## The xdg_toplevel_icon_v1 CLIENT protocol
## ########################################
## 
## Interfaces
## ==========
## 
## * xdg_toplevel_icon_manager_v1
## * xdg_toplevel_icon_v1
## 
## Copyright
## =========
## 
## Copyright © 2023-2024 Matthias Klumpp
## Copyright ©      2024 David Edmundson
## 
## Permission is hereby granted, free of charge, to any person obtaining a
## copy of this software and associated documentation files (the "Software"),
## to deal in the Software without restriction, including without limitation
## the rights to use, copy, modify, merge, publish, distribute, sublicense,
## and/or sell copies of the Software, and to permit persons to whom the
## Software is furnished to do so, subject to the following conditions:
## 
## The above copyright notice and this permission notice (including the next
## paragraph) shall be included in all copies or substantial portions of the
## Software.
## 
## THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
## IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
## FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
## THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
## LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
## FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
## DEALINGS IN THE SOFTWARE.
## 

type XdgToplevelIconManagerV1Listener* = object
  iconSize*: proc(
    data: pointer;
    xdgToplevelIconManagerV1: ptr XdgToplevelIconManagerV1;
    size: int32;
  ) {.nimcall.}
  done*: proc(
    data: pointer;
    xdgToplevelIconManagerV1: ptr XdgToplevelIconManagerV1;
  ) {.nimcall.}
proc addListener*(xdgToplevelIconManagerV1: ptr XdgToplevelIconManagerV1; listener: ptr XdgToplevelIconManagerV1Listener; data: pointer): int {.inline.} =
  cast[ptr Proxy](xdgToplevelIconManagerV1).add_listener(listener, data)

proc setUserData*(xdgToplevelIconManagerV1: ptr XdgToplevelIconManagerV1; userData: pointer) {.inline.} =
  cast[ptr Proxy](xdgToplevelIconManagerV1).set_user_data(user_data)
proc getUserData*(xdgToplevelIconManagerV1: ptr XdgToplevelIconManagerV1): pointer {.inline.} =
  cast[ptr Proxy](xdgToplevelIconManagerV1).get_user_data()
proc getVersion*(xdgToplevelIconManagerV1: ptr XdgToplevelIconManagerV1): uint32 {.inline.} =
  cast[ptr Proxy](xdgToplevelIconManagerV1).get_version()
proc destroy*(xdgToplevelIconManagerV1: ptr XdgToplevelIconManagerV1) {.inline.} =
  ## destroy the toplevel icon manager
  ## 
  ## Destroy the toplevel icon manager.
  ## This does not destroy objects created with the manager.
  ## 
  cast[ptr Proxy](xdgToplevelIconManagerV1).marshal_flags(XdgToplevelIconManagerV1Request_destroy.ord, nil, cast[ptr Proxy](xdgToplevelIconManagerV1).get_version(), WL_MARSHAL_FLAG_DESTROY)
proc createIcon*(xdgToplevelIconManagerV1: ptr XdgToplevelIconManagerV1): ptr XdgToplevelIconV1 {.inline.} =
  ## create a new icon instance
  ## 
  ## Creates a new icon object. This icon can then be attached to a
  ## xdg_toplevel via the 'set_icon' request.
  ## 
  cast[ptr XdgToplevelIconV1](cast[ptr Proxy](xdgToplevelIconManagerV1).marshal_flags(XdgToplevelIconManagerV1Request_create_icon.ord, addr xdg_toplevel_icon_v1_interface, cast[ptr Proxy](xdgToplevelIconManagerV1).get_version(), 0, nil))
proc setIcon*(xdgToplevelIconManagerV1: ptr XdgToplevelIconManagerV1; toplevel: ptr XdgToplevel; icon: ptr XdgToplevelIconV1) {.inline.} =
  ## set an icon on a toplevel window
  ## 
  ## This request assigns the icon 'icon' to 'toplevel', or clears the
  ## toplevel icon if 'icon' was null.
  ## This state is double-buffered and is applied on the next
  ## wl_surface.commit of the toplevel.
  ## 
  ## After making this call, the xdg_toplevel_icon_v1 provided as 'icon'
  ## can be destroyed by the client without 'toplevel' losing its icon.
  ## The xdg_toplevel_icon_v1 is immutable from this point, and any
  ## future attempts to change it must raise the
  ## 'xdg_toplevel_icon_v1.immutable' protocol error.
  ## 
  ## The compositor must set the toplevel icon from either the pixel data
  ## the icon provides, or by loading a stock icon using the icon name.
  ## See the description of 'xdg_toplevel_icon_v1' for details.
  ## 
  ## If 'icon' is set to null, the icon of the respective toplevel is reset
  ## to its default icon (usually the icon of the application, derived from
  ## its desktop-entry file, or a placeholder icon).
  ## If this request is passed an icon with no pixel buffers or icon name
  ## assigned, the icon must be reset just like if 'icon' was null.
  ## 
  cast[ptr Proxy](xdgToplevelIconManagerV1).marshal_flags(XdgToplevelIconManagerV1Request_set_icon.ord, nil, cast[ptr Proxy](xdgToplevelIconManagerV1).get_version(), 0, toplevel, icon)
proc setUserData*(xdgToplevelIconV1: ptr XdgToplevelIconV1; userData: pointer) {.inline.} =
  cast[ptr Proxy](xdgToplevelIconV1).set_user_data(user_data)
proc getUserData*(xdgToplevelIconV1: ptr XdgToplevelIconV1): pointer {.inline.} =
  cast[ptr Proxy](xdgToplevelIconV1).get_user_data()
proc getVersion*(xdgToplevelIconV1: ptr XdgToplevelIconV1): uint32 {.inline.} =
  cast[ptr Proxy](xdgToplevelIconV1).get_version()
proc destroy*(xdgToplevelIconV1: ptr XdgToplevelIconV1) {.inline.} =
  ## destroy the icon object
  ## 
  ## Destroys the 'xdg_toplevel_icon_v1' object.
  ## The icon must still remain set on every toplevel it was assigned to,
  ## until the toplevel icon is reset explicitly.
  ## 
  cast[ptr Proxy](xdgToplevelIconV1).marshal_flags(XdgToplevelIconV1Request_destroy.ord, nil, cast[ptr Proxy](xdgToplevelIconV1).get_version(), WL_MARSHAL_FLAG_DESTROY)
proc setName*(xdgToplevelIconV1: ptr XdgToplevelIconV1; iconName: cstring) {.inline.} =
  ## set an icon name
  ## 
  ## This request assigns an icon name to this icon.
  ## Any previously set name is overridden.
  ## 
  ## The compositor must resolve 'icon_name' according to the lookup rules
  ## described in the XDG icon theme specification[1] using the
  ## environment's current icon theme.
  ## 
  ## If the compositor does not support icon names or cannot resolve
  ## 'icon_name' according to the XDG icon theme specification it must
  ## fall back to using pixel buffer data instead.
  ## 
  ## If this request is made after the icon has been assigned to a toplevel
  ## via 'set_icon', a 'immutable' error must be raised.
  ## 
  ## [1]: https://specifications.freedesktop.org/icon-theme-spec/icon-theme-spec-latest.html
  ## 
  cast[ptr Proxy](xdgToplevelIconV1).marshal_flags(XdgToplevelIconV1Request_set_name.ord, nil, cast[ptr Proxy](xdgToplevelIconV1).get_version(), 0, iconName)
proc addBuffer*(xdgToplevelIconV1: ptr XdgToplevelIconV1; buffer: ptr Buffer; scale: int32) {.inline.} =
  ## add icon data from a pixel buffer
  ## 
  ## This request adds pixel data supplied as wl_buffer to the icon.
  ## 
  ## The client should add pixel data for all icon sizes and scales that
  ## it can provide, or which are explicitly requested by the compositor
  ## via 'icon_size' events on xdg_toplevel_icon_manager_v1.
  ## 
  ## The wl_buffer supplying pixel data as 'buffer' must be backed by wl_shm
  ## and must be a square (width and height being equal).
  ## If any of these buffer requirements are not fulfilled, a 'invalid_buffer'
  ## error must be raised.
  ## 
  ## If this icon instance already has a buffer of the same size and scale
  ## from a previous 'add_buffer' request, data from the last request
  ## overrides the preexisting pixel data.
  ## 
  ## The wl_buffer must be kept alive for as long as the xdg_toplevel_icon
  ## it is associated with is not destroyed, otherwise a 'no_buffer' error
  ## is raised. The buffer contents must not be modified after it was
  ## assigned to the icon. As a result, the region of the wl_shm_pool's
  ## backing storage used for the wl_buffer must not be modified after this
  ## request is sent. The wl_buffer.release event is unused.
  ## 
  ## If this request is made after the icon has been assigned to a toplevel
  ## via 'set_icon', a 'immutable' error must be raised.
  ## 
  cast[ptr Proxy](xdgToplevelIconV1).marshal_flags(XdgToplevelIconV1Request_add_buffer.ord, nil, cast[ptr Proxy](xdgToplevelIconV1).get_version(), 0, buffer, scale)
