# Generated by wayland-nim-scanner 1.23.1
{.warning[UnusedImport]:off.}
import wayland/native/client
import wayland/native/common
import code
export code

## The ext_session_lock_v1 CLIENT protocol
## #######################################
## 
## Interfaces
## ==========
## 
## * ext_session_lock_manager_v1
## * ext_session_lock_v1
## * ext_session_lock_surface_v1
## 
## Copyright
## =========
## 
## Copyright 2021 Isaac Freund
## 
## Permission is hereby granted, free of charge, to any person obtaining a
## copy of this software and associated documentation files (the "Software"),
## to deal in the Software without restriction, including without limitation
## the rights to use, copy, modify, merge, publish, distribute, sublicense,
## and/or sell copies of the Software, and to permit persons to whom the
## Software is furnished to do so, subject to the following conditions:
## 
## The above copyright notice and this permission notice shall be included in
## all copies or substantial portions of the Software.
## 
## THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
## IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
## FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
## THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
## LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
## OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
## THE SOFTWARE.
## 

proc setUserData*(extSessionLockManagerV1: ptr ExtSessionLockManagerV1; userData: pointer) {.inline.} =
  cast[ptr Proxy](extSessionLockManagerV1).set_user_data(user_data)
proc getUserData*(extSessionLockManagerV1: ptr ExtSessionLockManagerV1): pointer {.inline.} =
  cast[ptr Proxy](extSessionLockManagerV1).get_user_data()
proc getVersion*(extSessionLockManagerV1: ptr ExtSessionLockManagerV1): uint32 {.inline.} =
  cast[ptr Proxy](extSessionLockManagerV1).get_version()
proc destroy*(extSessionLockManagerV1: ptr ExtSessionLockManagerV1) {.inline.} =
  ## destroy the session lock manager object
  ## 
  ## This informs the compositor that the session lock manager object will
  ## no longer be used. Existing objects created through this interface
  ## remain valid.
  ## 
  cast[ptr Proxy](extSessionLockManagerV1).marshal_flags(ExtSessionLockManagerV1Request_destroy.ord, nil, cast[ptr Proxy](extSessionLockManagerV1).get_version(), WL_MARSHAL_FLAG_DESTROY)
proc lock*(extSessionLockManagerV1: ptr ExtSessionLockManagerV1): ptr ExtSessionLockV1 {.inline.} =
  ## attempt to lock the session
  ## 
  ## This request creates a session lock and asks the compositor to lock the
  ## session. The compositor will send either the ext_session_lock_v1.locked
  ## or ext_session_lock_v1.finished event on the created object in
  ## response to this request.
  ## 
  cast[ptr ExtSessionLockV1](cast[ptr Proxy](extSessionLockManagerV1).marshal_flags(ExtSessionLockManagerV1Request_lock.ord, addr ext_session_lock_v1_interface, cast[ptr Proxy](extSessionLockManagerV1).get_version(), 0, nil))
type ExtSessionLockV1Listener* = object
  locked*: proc(
    data: pointer;
    extSessionLockV1: ptr ExtSessionLockV1;
  ) {.nimcall.}
  finished*: proc(
    data: pointer;
    extSessionLockV1: ptr ExtSessionLockV1;
  ) {.nimcall.}
proc addListener*(extSessionLockV1: ptr ExtSessionLockV1; listener: ptr ExtSessionLockV1Listener; data: pointer): int {.inline.} =
  cast[ptr Proxy](extSessionLockV1).add_listener(listener, data)

proc setUserData*(extSessionLockV1: ptr ExtSessionLockV1; userData: pointer) {.inline.} =
  cast[ptr Proxy](extSessionLockV1).set_user_data(user_data)
proc getUserData*(extSessionLockV1: ptr ExtSessionLockV1): pointer {.inline.} =
  cast[ptr Proxy](extSessionLockV1).get_user_data()
proc getVersion*(extSessionLockV1: ptr ExtSessionLockV1): uint32 {.inline.} =
  cast[ptr Proxy](extSessionLockV1).get_version()
proc destroy*(extSessionLockV1: ptr ExtSessionLockV1) {.inline.} =
  ## destroy the session lock
  ## 
  ## This informs the compositor that the lock object will no longer be
  ## used. Existing objects created through this interface remain valid.
  ## 
  ## After this request is made, lock surfaces created through this object
  ## should be destroyed by the client as they will no longer be used by
  ## the compositor.
  ## 
  ## It is a protocol error to make this request if the locked event was
  ## sent, the unlock_and_destroy request must be used instead.
  ## 
  cast[ptr Proxy](extSessionLockV1).marshal_flags(ExtSessionLockV1Request_destroy.ord, nil, cast[ptr Proxy](extSessionLockV1).get_version(), WL_MARSHAL_FLAG_DESTROY)
proc getLockSurface*(extSessionLockV1: ptr ExtSessionLockV1; surface: ptr Surface; output: ptr Output): ptr ExtSessionLockSurfaceV1 {.inline.} =
  ## create a lock surface for a given output
  ## 
  ## The client is expected to create lock surfaces for all outputs
  ## currently present and any new outputs as they are advertised. These
  ## won't be displayed by the compositor unless the lock is successful
  ## and the locked event is sent.
  ## 
  ## Providing a wl_surface which already has a role or already has a buffer
  ## attached or committed is a protocol error, as is attaching/committing
  ## a buffer before the first ext_session_lock_surface_v1.configure event.
  ## 
  ## Attempting to create more than one lock surface for a given output
  ## is a duplicate_output protocol error.
  ## 
  cast[ptr ExtSessionLockSurfaceV1](cast[ptr Proxy](extSessionLockV1).marshal_flags(ExtSessionLockV1Request_get_lock_surface.ord, addr ext_session_lock_surface_v1_interface, cast[ptr Proxy](extSessionLockV1).get_version(), 0, nil, surface, output))
proc unlockAndDestroy*(extSessionLockV1: ptr ExtSessionLockV1) {.inline.} =
  ## unlock the session, destroying the object
  ## 
  ## This request indicates that the session should be unlocked, for
  ## example because the user has entered their password and it has been
  ## verified by the client.
  ## 
  ## This request also informs the compositor that the lock object will
  ## no longer be used and should be destroyed. Existing objects created
  ## through this interface remain valid.
  ## 
  ## After this request is made, lock surfaces created through this object
  ## should be destroyed by the client as they will no longer be used by
  ## the compositor.
  ## 
  ## It is a protocol error to make this request if the locked event has
  ## not been sent. In that case, the lock object must be destroyed using
  ## the destroy request.
  ## 
  ## Note that a correct client that wishes to exit directly after unlocking
  ## the session must use the wl_display.sync request to ensure the server
  ## receives and processes the unlock_and_destroy request. Otherwise
  ## there is no guarantee that the server has unlocked the session due
  ## to the asynchronous nature of the Wayland protocol. For example,
  ## the server might terminate the client with a protocol error before
  ## it processes the unlock_and_destroy request.
  ## 
  cast[ptr Proxy](extSessionLockV1).marshal_flags(ExtSessionLockV1Request_unlock_and_destroy.ord, nil, cast[ptr Proxy](extSessionLockV1).get_version(), WL_MARSHAL_FLAG_DESTROY)
type ExtSessionLockSurfaceV1Listener* = object
  configure*: proc(
    data: pointer;
    extSessionLockSurfaceV1: ptr ExtSessionLockSurfaceV1;
    serial: uint32;
    width: uint32;
    height: uint32;
  ) {.nimcall.}
proc addListener*(extSessionLockSurfaceV1: ptr ExtSessionLockSurfaceV1; listener: ptr ExtSessionLockSurfaceV1Listener; data: pointer): int {.inline.} =
  cast[ptr Proxy](extSessionLockSurfaceV1).add_listener(listener, data)

proc setUserData*(extSessionLockSurfaceV1: ptr ExtSessionLockSurfaceV1; userData: pointer) {.inline.} =
  cast[ptr Proxy](extSessionLockSurfaceV1).set_user_data(user_data)
proc getUserData*(extSessionLockSurfaceV1: ptr ExtSessionLockSurfaceV1): pointer {.inline.} =
  cast[ptr Proxy](extSessionLockSurfaceV1).get_user_data()
proc getVersion*(extSessionLockSurfaceV1: ptr ExtSessionLockSurfaceV1): uint32 {.inline.} =
  cast[ptr Proxy](extSessionLockSurfaceV1).get_version()
proc destroy*(extSessionLockSurfaceV1: ptr ExtSessionLockSurfaceV1) {.inline.} =
  ## destroy the lock surface object
  ## 
  ## This informs the compositor that the lock surface object will no
  ## longer be used.
  ## 
  ## It is recommended for a lock client to destroy lock surfaces if
  ## their corresponding wl_output global is removed.
  ## 
  ## If a lock surface on an active output is destroyed before the
  ## ext_session_lock_v1.unlock_and_destroy event is sent, the compositor
  ## must fall back to rendering a solid color.
  ## 
  cast[ptr Proxy](extSessionLockSurfaceV1).marshal_flags(ExtSessionLockSurfaceV1Request_destroy.ord, nil, cast[ptr Proxy](extSessionLockSurfaceV1).get_version(), WL_MARSHAL_FLAG_DESTROY)
proc ackConfigure*(extSessionLockSurfaceV1: ptr ExtSessionLockSurfaceV1; serial: uint32) {.inline.} =
  ## ack a configure event
  ## 
  ## When a configure event is received, if a client commits the surface
  ## in response to the configure event, then the client must make an
  ## ack_configure request sometime before the commit request, passing
  ## along the serial of the configure event.
  ## 
  ## If the client receives multiple configure events before it can
  ## respond to one, it only has to ack the last configure event.
  ## 
  ## A client is not required to commit immediately after sending an
  ## ack_configure request - it may even ack_configure several times
  ## before its next surface commit.
  ## 
  ## A client may send multiple ack_configure requests before committing,
  ## but only the last request sent before a commit indicates which
  ## configure event the client really is responding to.
  ## 
  ## Sending an ack_configure request consumes the configure event
  ## referenced by the given serial, as well as all older configure events
  ## sent on this object.
  ## 
  ## It is a protocol error to issue multiple ack_configure requests
  ## referencing the same configure event or to issue an ack_configure
  ## request referencing a configure event older than the last configure
  ## event acked for a given lock surface.
  ## 
  cast[ptr Proxy](extSessionLockSurfaceV1).marshal_flags(ExtSessionLockSurfaceV1Request_ack_configure.ord, nil, cast[ptr Proxy](extSessionLockSurfaceV1).get_version(), 0, serial)
