# Generated by wayland-nim-scanner 1.23.1
import wayland/native/client_core
import wayland/native/common
import protocol_code
export protocol_code

## The wayland CLIENT protocol
## ###########################
## 
## Interfaces
## ==========
## 
## * wl_display
## * wl_registry
## * wl_callback
## * wl_compositor
## * wl_shm_pool
## * wl_shm
## * wl_buffer
## * wl_data_offer
## * wl_data_source
## * wl_data_device
## * wl_data_device_manager
## * wl_shell
## * wl_shell_surface
## * wl_surface
## * wl_seat
## * wl_pointer
## * wl_keyboard
## * wl_touch
## * wl_output
## * wl_region
## * wl_subcompositor
## * wl_subsurface
## 
## Copyright
## =========
## 
## Copyright © 2008-2011 Kristian Høgsberg
## Copyright © 2010-2011 Intel Corporation
## Copyright © 2012-2013 Collabora, Ltd.
## 
## Permission is hereby granted, free of charge, to any person
## obtaining a copy of this software and associated documentation files
## (the "Software"), to deal in the Software without restriction,
## including without limitation the rights to use, copy, modify, merge,
## publish, distribute, sublicense, and/or sell copies of the Software,
## and to permit persons to whom the Software is furnished to do so,
## subject to the following conditions:
## 
## The above copyright notice and this permission notice (including the
## next paragraph) shall be included in all copies or substantial
## portions of the Software.
## 
## THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
## EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
## MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
## NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
## BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
## ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
## CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
## SOFTWARE.
## 

type WlDisplayListener* = object
  error*: proc(
    data: pointer;
    wl_display: ptr wl_display;
    object_id: pointer;
    code: uint32;
    message: cstring;
  ) {.nimcall.}
  delete_id*: proc(
    data: pointer;
    wl_display: ptr wl_display;
    id: uint32;
  ) {.nimcall.}
proc add_listener*(wl_display: ptr wl_display; listener: ptr WlDisplayListener; data: pointer): int {.inline.} =
  cast[ptr wl_proxy](wl_display).add_listener(listener, data)

proc set_user_data*(wl_display: ptr wl_display; user_data: pointer) {.inline.} =
  cast[ptr wl_proxy](wl_display).set_user_data(user_data)
proc get_user_data*(wl_display: ptr wl_display): pointer {.inline.} =
  cast[ptr wl_proxy](wl_display).get_user_data()
proc get_version*(wl_display: ptr wl_display): uint32 {.inline.} =
  cast[ptr wl_proxy](wl_display).get_version()
proc sync*(wl_display: ptr wl_display): ptr wl_callback {.inline.} =
  ## asynchronous roundtrip
  ## 
  ## The sync request asks the server to emit the 'done' event
  ## 	on the returned wl_callback object.  Since requests are
  ## 	handled in-order and events are delivered in-order, this can
  ## 	be used as a barrier to ensure all previous requests and the
  ## 	resulting events have been handled.
  ## 
  ## 	The object returned by this request will be destroyed by the
  ## 	compositor after the callback is fired and as such the client must not
  ## 	attempt to use it after that point.
  ## 
  ## 	The callback_data passed in the callback is undefined and should be ignored.
  ## 
  cast[ptr wl_callback](cast[ptr wl_proxy](wl_display).marshal_flags(wl_display_request_sync.ord, addr wl_callback_interface, cast[ptr wl_proxy](wl_display).get_version(), 0, nil))
proc get_registry*(wl_display: ptr wl_display): ptr wl_registry {.inline.} =
  ## get global registry object
  ## 
  ## This request creates a registry object that allows the client
  ## 	to list and bind the global objects available from the
  ## 	compositor.
  ## 
  ## 	It should be noted that the server side resources consumed in
  ## 	response to a get_registry request can only be released when the
  ## 	client disconnects, not when the client side proxy is destroyed.
  ## 	Therefore, clients should invoke get_registry as infrequently as
  ## 	possible to avoid wasting memory.
  ## 
  cast[ptr wl_registry](cast[ptr wl_proxy](wl_display).marshal_flags(wl_display_request_get_registry.ord, addr wl_registry_interface, cast[ptr wl_proxy](wl_display).get_version(), 0, nil))
type WlRegistryListener* = object
  global*: proc(
    data: pointer;
    wl_registry: ptr wl_registry;
    name: uint32;
    `interface`: cstring;
    version: uint32;
  ) {.nimcall.}
  global_remove*: proc(
    data: pointer;
    wl_registry: ptr wl_registry;
    name: uint32;
  ) {.nimcall.}
proc add_listener*(wl_registry: ptr wl_registry; listener: ptr WlRegistryListener; data: pointer): int {.inline.} =
  cast[ptr wl_proxy](wl_registry).add_listener(listener, data)

proc set_user_data*(wl_registry: ptr wl_registry; user_data: pointer) {.inline.} =
  cast[ptr wl_proxy](wl_registry).set_user_data(user_data)
proc get_user_data*(wl_registry: ptr wl_registry): pointer {.inline.} =
  cast[ptr wl_proxy](wl_registry).get_user_data()
proc get_version*(wl_registry: ptr wl_registry): uint32 {.inline.} =
  cast[ptr wl_proxy](wl_registry).get_version()
proc destroy*(wl_registry: ptr wl_registry) {.inline.} =
  destroy cast[ptr wl_proxy](wl_registry)
proc `bind`*(wl_registry: ptr wl_registry; name: uint32; `interface`: ptr wl_interface; version: uint32): pointer {.inline.} =
  ## bind an object to the display
  ## 
  ## Binds a new, client-created object to the server using the
  ## 	specified name as the identifier.
  ## 
  cast[ptr wl_proxy](wl_registry).marshal_flags(wl_registry_request_bind.ord, `interface`, version, 0, name, `interface`.name, version, nil)
type WlCallbackListener* = object
  done*: proc(
    data: pointer;
    wl_callback: ptr wl_callback;
    callback_data: uint32;
  ) {.nimcall.}
proc add_listener*(wl_callback: ptr wl_callback; listener: ptr WlCallbackListener; data: pointer): int {.inline.} =
  cast[ptr wl_proxy](wl_callback).add_listener(listener, data)

proc set_user_data*(wl_callback: ptr wl_callback; user_data: pointer) {.inline.} =
  cast[ptr wl_proxy](wl_callback).set_user_data(user_data)
proc get_user_data*(wl_callback: ptr wl_callback): pointer {.inline.} =
  cast[ptr wl_proxy](wl_callback).get_user_data()
proc get_version*(wl_callback: ptr wl_callback): uint32 {.inline.} =
  cast[ptr wl_proxy](wl_callback).get_version()
proc destroy*(wl_callback: ptr wl_callback) {.inline.} =
  destroy cast[ptr wl_proxy](wl_callback)
proc set_user_data*(wl_compositor: ptr wl_compositor; user_data: pointer) {.inline.} =
  cast[ptr wl_proxy](wl_compositor).set_user_data(user_data)
proc get_user_data*(wl_compositor: ptr wl_compositor): pointer {.inline.} =
  cast[ptr wl_proxy](wl_compositor).get_user_data()
proc get_version*(wl_compositor: ptr wl_compositor): uint32 {.inline.} =
  cast[ptr wl_proxy](wl_compositor).get_version()
proc destroy*(wl_compositor: ptr wl_compositor) {.inline.} =
  destroy cast[ptr wl_proxy](wl_compositor)
proc create_surface*(wl_compositor: ptr wl_compositor): ptr wl_surface {.inline.} =
  ## create new surface
  ## 
  ## Ask the compositor to create a new surface.
  ## 
  cast[ptr wl_surface](cast[ptr wl_proxy](wl_compositor).marshal_flags(wl_compositor_request_create_surface.ord, addr wl_surface_interface, cast[ptr wl_proxy](wl_compositor).get_version(), 0, nil))
proc create_region*(wl_compositor: ptr wl_compositor): ptr wl_region {.inline.} =
  ## create new region
  ## 
  ## Ask the compositor to create a new region.
  ## 
  cast[ptr wl_region](cast[ptr wl_proxy](wl_compositor).marshal_flags(wl_compositor_request_create_region.ord, addr wl_region_interface, cast[ptr wl_proxy](wl_compositor).get_version(), 0, nil))
proc set_user_data*(wl_shm_pool: ptr wl_shm_pool; user_data: pointer) {.inline.} =
  cast[ptr wl_proxy](wl_shm_pool).set_user_data(user_data)
proc get_user_data*(wl_shm_pool: ptr wl_shm_pool): pointer {.inline.} =
  cast[ptr wl_proxy](wl_shm_pool).get_user_data()
proc get_version*(wl_shm_pool: ptr wl_shm_pool): uint32 {.inline.} =
  cast[ptr wl_proxy](wl_shm_pool).get_version()
proc create_buffer*(wl_shm_pool: ptr wl_shm_pool; offset: int32; width: int32; height: int32; stride: int32; format: uint32): ptr wl_buffer {.inline.} =
  ## create a buffer from the pool
  ## 
  ## Create a wl_buffer object from the pool.
  ## 
  ## 	The buffer is created offset bytes into the pool and has
  ## 	width and height as specified.  The stride argument specifies
  ## 	the number of bytes from the beginning of one row to the beginning
  ## 	of the next.  The format is the pixel format of the buffer and
  ## 	must be one of those advertised through the wl_shm.format event.
  ## 
  ## 	A buffer will keep a reference to the pool it was created from
  ## 	so it is valid to destroy the pool immediately after creating
  ## 	a buffer from it.
  ## 
  cast[ptr wl_buffer](cast[ptr wl_proxy](wl_shm_pool).marshal_flags(wl_shm_pool_request_create_buffer.ord, addr wl_buffer_interface, cast[ptr wl_proxy](wl_shm_pool).get_version(), 0, nil, offset, width, height, stride, format))
proc destroy*(wl_shm_pool: ptr wl_shm_pool) {.inline.} =
  ## destroy the pool
  ## 
  ## Destroy the shared memory pool.
  ## 
  ## 	The mmapped memory will be released when all
  ## 	buffers that have been created from this pool
  ## 	are gone.
  ## 
  cast[ptr wl_proxy](wl_shm_pool).marshal_flags(wl_shm_pool_request_destroy.ord, nil, cast[ptr wl_proxy](wl_shm_pool).get_version(), WL_MARSHAL_FLAG_DESTROY)
proc resize*(wl_shm_pool: ptr wl_shm_pool; size: int32) {.inline.} =
  ## change the size of the pool mapping
  ## 
  ## This request will cause the server to remap the backing memory
  ## 	for the pool from the file descriptor passed when the pool was
  ## 	created, but using the new size.  This request can only be
  ## 	used to make the pool bigger.
  ## 
  ## 	This request only changes the amount of bytes that are mmapped
  ## 	by the server and does not touch the file corresponding to the
  ## 	file descriptor passed at creation time. It is the client's
  ## 	responsibility to ensure that the file is at least as big as
  ## 	the new pool size.
  ## 
  cast[ptr wl_proxy](wl_shm_pool).marshal_flags(wl_shm_pool_request_resize.ord, nil, cast[ptr wl_proxy](wl_shm_pool).get_version(), 0, size)
type WlShmListener* = object
  format*: proc(
    data: pointer;
    wl_shm: ptr wl_shm;
    format: uint32;
  ) {.nimcall.}
proc add_listener*(wl_shm: ptr wl_shm; listener: ptr WlShmListener; data: pointer): int {.inline.} =
  cast[ptr wl_proxy](wl_shm).add_listener(listener, data)

proc set_user_data*(wl_shm: ptr wl_shm; user_data: pointer) {.inline.} =
  cast[ptr wl_proxy](wl_shm).set_user_data(user_data)
proc get_user_data*(wl_shm: ptr wl_shm): pointer {.inline.} =
  cast[ptr wl_proxy](wl_shm).get_user_data()
proc get_version*(wl_shm: ptr wl_shm): uint32 {.inline.} =
  cast[ptr wl_proxy](wl_shm).get_version()
proc destroy*(wl_shm: ptr wl_shm) {.inline.} =
  destroy cast[ptr wl_proxy](wl_shm)
proc create_pool*(wl_shm: ptr wl_shm; fd: int32; size: int32): ptr wl_shm_pool {.inline.} =
  ## create a shm pool
  ## 
  ## Create a new wl_shm_pool object.
  ## 
  ## 	The pool can be used to create shared memory based buffer
  ## 	objects.  The server will mmap size bytes of the passed file
  ## 	descriptor, to use as backing memory for the pool.
  ## 
  cast[ptr wl_shm_pool](cast[ptr wl_proxy](wl_shm).marshal_flags(wl_shm_request_create_pool.ord, addr wl_shm_pool_interface, cast[ptr wl_proxy](wl_shm).get_version(), 0, nil, fd, size))
proc release*(wl_shm: ptr wl_shm) {.inline.} =
  ## release the shm object
  ## 
  ## Using this request a client can tell the server that it is not going to
  ## 	use the shm object anymore.
  ## 
  ## 	Objects created via this interface remain unaffected.
  ## 
  cast[ptr wl_proxy](wl_shm).marshal_flags(wl_shm_request_release.ord, nil, cast[ptr wl_proxy](wl_shm).get_version(), WL_MARSHAL_FLAG_DESTROY)
type WlBufferListener* = object
  release*: proc(
    data: pointer;
    wl_buffer: ptr wl_buffer;
  ) {.nimcall.}
proc add_listener*(wl_buffer: ptr wl_buffer; listener: ptr WlBufferListener; data: pointer): int {.inline.} =
  cast[ptr wl_proxy](wl_buffer).add_listener(listener, data)

proc set_user_data*(wl_buffer: ptr wl_buffer; user_data: pointer) {.inline.} =
  cast[ptr wl_proxy](wl_buffer).set_user_data(user_data)
proc get_user_data*(wl_buffer: ptr wl_buffer): pointer {.inline.} =
  cast[ptr wl_proxy](wl_buffer).get_user_data()
proc get_version*(wl_buffer: ptr wl_buffer): uint32 {.inline.} =
  cast[ptr wl_proxy](wl_buffer).get_version()
proc destroy*(wl_buffer: ptr wl_buffer) {.inline.} =
  ## destroy a buffer
  ## 
  ## Destroy a buffer. If and how you need to release the backing
  ## 	storage is defined by the buffer factory interface.
  ## 
  ## 	For possible side-effects to a surface, see wl_surface.attach.
  ## 
  cast[ptr wl_proxy](wl_buffer).marshal_flags(wl_buffer_request_destroy.ord, nil, cast[ptr wl_proxy](wl_buffer).get_version(), WL_MARSHAL_FLAG_DESTROY)
type WlDataOfferListener* = object
  offer*: proc(
    data: pointer;
    wl_data_offer: ptr wl_data_offer;
    mime_type: cstring;
  ) {.nimcall.}
  source_actions*: proc(
    data: pointer;
    wl_data_offer: ptr wl_data_offer;
    source_actions: uint32;
  ) {.nimcall.}
  action*: proc(
    data: pointer;
    wl_data_offer: ptr wl_data_offer;
    dnd_action: uint32;
  ) {.nimcall.}
proc add_listener*(wl_data_offer: ptr wl_data_offer; listener: ptr WlDataOfferListener; data: pointer): int {.inline.} =
  cast[ptr wl_proxy](wl_data_offer).add_listener(listener, data)

proc set_user_data*(wl_data_offer: ptr wl_data_offer; user_data: pointer) {.inline.} =
  cast[ptr wl_proxy](wl_data_offer).set_user_data(user_data)
proc get_user_data*(wl_data_offer: ptr wl_data_offer): pointer {.inline.} =
  cast[ptr wl_proxy](wl_data_offer).get_user_data()
proc get_version*(wl_data_offer: ptr wl_data_offer): uint32 {.inline.} =
  cast[ptr wl_proxy](wl_data_offer).get_version()
proc accept*(wl_data_offer: ptr wl_data_offer; serial: uint32; mime_type: cstring) {.inline.} =
  ## accept one of the offered mime types
  ## 
  ## Indicate that the client can accept the given mime type, or
  ## 	NULL for not accepted.
  ## 
  ## 	For objects of version 2 or older, this request is used by the
  ## 	client to give feedback whether the client can receive the given
  ## 	mime type, or NULL if none is accepted; the feedback does not
  ## 	determine whether the drag-and-drop operation succeeds or not.
  ## 
  ## 	For objects of version 3 or newer, this request determines the
  ## 	final result of the drag-and-drop operation. If the end result
  ## 	is that no mime types were accepted, the drag-and-drop operation
  ## 	will be cancelled and the corresponding drag source will receive
  ## 	wl_data_source.cancelled. Clients may still use this event in
  ## 	conjunction with wl_data_source.action for feedback.
  ## 
  cast[ptr wl_proxy](wl_data_offer).marshal_flags(wl_data_offer_request_accept.ord, nil, cast[ptr wl_proxy](wl_data_offer).get_version(), 0, serial, mime_type)
proc receive*(wl_data_offer: ptr wl_data_offer; mime_type: cstring; fd: int32) {.inline.} =
  ## request that the data is transferred
  ## 
  ## To transfer the offered data, the client issues this request
  ## 	and indicates the mime type it wants to receive.  The transfer
  ## 	happens through the passed file descriptor (typically created
  ## 	with the pipe system call).  The source client writes the data
  ## 	in the mime type representation requested and then closes the
  ## 	file descriptor.
  ## 
  ## 	The receiving client reads from the read end of the pipe until
  ## 	EOF and then closes its end, at which point the transfer is
  ## 	complete.
  ## 
  ## 	This request may happen multiple times for different mime types,
  ## 	both before and after wl_data_device.drop. Drag-and-drop destination
  ## 	clients may preemptively fetch data or examine it more closely to
  ## 	determine acceptance.
  ## 
  cast[ptr wl_proxy](wl_data_offer).marshal_flags(wl_data_offer_request_receive.ord, nil, cast[ptr wl_proxy](wl_data_offer).get_version(), 0, mime_type, fd)
proc destroy*(wl_data_offer: ptr wl_data_offer) {.inline.} =
  ## destroy data offer
  ## 
  ## Destroy the data offer.
  ## 
  cast[ptr wl_proxy](wl_data_offer).marshal_flags(wl_data_offer_request_destroy.ord, nil, cast[ptr wl_proxy](wl_data_offer).get_version(), WL_MARSHAL_FLAG_DESTROY)
proc finish*(wl_data_offer: ptr wl_data_offer) {.inline.} =
  ## the offer will no longer be used
  ## 
  ## Notifies the compositor that the drag destination successfully
  ## 	finished the drag-and-drop operation.
  ## 
  ## 	Upon receiving this request, the compositor will emit
  ## 	wl_data_source.dnd_finished on the drag source client.
  ## 
  ## 	It is a client error to perform other requests than
  ## 	wl_data_offer.destroy after this one. It is also an error to perform
  ## 	this request after a NULL mime type has been set in
  ## 	wl_data_offer.accept or no action was received through
  ## 	wl_data_offer.action.
  ## 
  ## 	If wl_data_offer.finish request is received for a non drag and drop
  ## 	operation, the invalid_finish protocol error is raised.
  ## 
  cast[ptr wl_proxy](wl_data_offer).marshal_flags(wl_data_offer_request_finish.ord, nil, cast[ptr wl_proxy](wl_data_offer).get_version(), 0)
proc set_actions*(wl_data_offer: ptr wl_data_offer; dnd_actions: uint32; preferred_action: uint32) {.inline.} =
  ## set the available/preferred drag-and-drop actions
  ## 
  ## Sets the actions that the destination side client supports for
  ## 	this operation. This request may trigger the emission of
  ## 	wl_data_source.action and wl_data_offer.action events if the compositor
  ## 	needs to change the selected action.
  ## 
  ## 	This request can be called multiple times throughout the
  ## 	drag-and-drop operation, typically in response to wl_data_device.enter
  ## 	or wl_data_device.motion events.
  ## 
  ## 	This request determines the final result of the drag-and-drop
  ## 	operation. If the end result is that no action is accepted,
  ## 	the drag source will receive wl_data_source.cancelled.
  ## 
  ## 	The dnd_actions argument must contain only values expressed in the
  ## 	wl_data_device_manager.dnd_actions enum, and the preferred_action
  ## 	argument must only contain one of those values set, otherwise it
  ## 	will result in a protocol error.
  ## 
  ## 	While managing an "ask" action, the destination drag-and-drop client
  ## 	may perform further wl_data_offer.receive requests, and is expected
  ## 	to perform one last wl_data_offer.set_actions request with a preferred
  ## 	action other than "ask" (and optionally wl_data_offer.accept) before
  ## 	requesting wl_data_offer.finish, in order to convey the action selected
  ## 	by the user. If the preferred action is not in the
  ## 	wl_data_offer.source_actions mask, an error will be raised.
  ## 
  ## 	If the "ask" action is dismissed (e.g. user cancellation), the client
  ## 	is expected to perform wl_data_offer.destroy right away.
  ## 
  ## 	This request can only be made on drag-and-drop offers, a protocol error
  ## 	will be raised otherwise.
  ## 
  cast[ptr wl_proxy](wl_data_offer).marshal_flags(wl_data_offer_request_set_actions.ord, nil, cast[ptr wl_proxy](wl_data_offer).get_version(), 0, dnd_actions, preferred_action)
type WlDataSourceListener* = object
  target*: proc(
    data: pointer;
    wl_data_source: ptr wl_data_source;
    mime_type: cstring;
  ) {.nimcall.}
  send*: proc(
    data: pointer;
    wl_data_source: ptr wl_data_source;
    mime_type: cstring;
    fd: int32;
  ) {.nimcall.}
  cancelled*: proc(
    data: pointer;
    wl_data_source: ptr wl_data_source;
  ) {.nimcall.}
  dnd_drop_performed*: proc(
    data: pointer;
    wl_data_source: ptr wl_data_source;
  ) {.nimcall.}
  dnd_finished*: proc(
    data: pointer;
    wl_data_source: ptr wl_data_source;
  ) {.nimcall.}
  action*: proc(
    data: pointer;
    wl_data_source: ptr wl_data_source;
    dnd_action: uint32;
  ) {.nimcall.}
proc add_listener*(wl_data_source: ptr wl_data_source; listener: ptr WlDataSourceListener; data: pointer): int {.inline.} =
  cast[ptr wl_proxy](wl_data_source).add_listener(listener, data)

proc set_user_data*(wl_data_source: ptr wl_data_source; user_data: pointer) {.inline.} =
  cast[ptr wl_proxy](wl_data_source).set_user_data(user_data)
proc get_user_data*(wl_data_source: ptr wl_data_source): pointer {.inline.} =
  cast[ptr wl_proxy](wl_data_source).get_user_data()
proc get_version*(wl_data_source: ptr wl_data_source): uint32 {.inline.} =
  cast[ptr wl_proxy](wl_data_source).get_version()
proc offer*(wl_data_source: ptr wl_data_source; mime_type: cstring) {.inline.} =
  ## add an offered mime type
  ## 
  ## This request adds a mime type to the set of mime types
  ## 	advertised to targets.  Can be called several times to offer
  ## 	multiple types.
  ## 
  cast[ptr wl_proxy](wl_data_source).marshal_flags(wl_data_source_request_offer.ord, nil, cast[ptr wl_proxy](wl_data_source).get_version(), 0, mime_type)
proc destroy*(wl_data_source: ptr wl_data_source) {.inline.} =
  ## destroy the data source
  ## 
  ## Destroy the data source.
  ## 
  cast[ptr wl_proxy](wl_data_source).marshal_flags(wl_data_source_request_destroy.ord, nil, cast[ptr wl_proxy](wl_data_source).get_version(), WL_MARSHAL_FLAG_DESTROY)
proc set_actions*(wl_data_source: ptr wl_data_source; dnd_actions: uint32) {.inline.} =
  ## set the available drag-and-drop actions
  ## 
  ## Sets the actions that the source side client supports for this
  ## 	operation. This request may trigger wl_data_source.action and
  ## 	wl_data_offer.action events if the compositor needs to change the
  ## 	selected action.
  ## 
  ## 	The dnd_actions argument must contain only values expressed in the
  ## 	wl_data_device_manager.dnd_actions enum, otherwise it will result
  ## 	in a protocol error.
  ## 
  ## 	This request must be made once only, and can only be made on sources
  ## 	used in drag-and-drop, so it must be performed before
  ## 	wl_data_device.start_drag. Attempting to use the source other than
  ## 	for drag-and-drop will raise a protocol error.
  ## 
  cast[ptr wl_proxy](wl_data_source).marshal_flags(wl_data_source_request_set_actions.ord, nil, cast[ptr wl_proxy](wl_data_source).get_version(), 0, dnd_actions)
type WlDataDeviceListener* = object
  data_offer*: proc(
    data: pointer;
    wl_data_device: ptr wl_data_device;
    id: ptr wl_data_offer;
  ) {.nimcall.}
  enter*: proc(
    data: pointer;
    wl_data_device: ptr wl_data_device;
    serial: uint32;
    surface: ptr wl_surface;
    x: wl_fixed_t;
    y: wl_fixed_t;
    id: ptr wl_data_offer;
  ) {.nimcall.}
  leave*: proc(
    data: pointer;
    wl_data_device: ptr wl_data_device;
  ) {.nimcall.}
  motion*: proc(
    data: pointer;
    wl_data_device: ptr wl_data_device;
    time: uint32;
    x: wl_fixed_t;
    y: wl_fixed_t;
  ) {.nimcall.}
  drop*: proc(
    data: pointer;
    wl_data_device: ptr wl_data_device;
  ) {.nimcall.}
  selection*: proc(
    data: pointer;
    wl_data_device: ptr wl_data_device;
    id: ptr wl_data_offer;
  ) {.nimcall.}
proc add_listener*(wl_data_device: ptr wl_data_device; listener: ptr WlDataDeviceListener; data: pointer): int {.inline.} =
  cast[ptr wl_proxy](wl_data_device).add_listener(listener, data)

proc set_user_data*(wl_data_device: ptr wl_data_device; user_data: pointer) {.inline.} =
  cast[ptr wl_proxy](wl_data_device).set_user_data(user_data)
proc get_user_data*(wl_data_device: ptr wl_data_device): pointer {.inline.} =
  cast[ptr wl_proxy](wl_data_device).get_user_data()
proc get_version*(wl_data_device: ptr wl_data_device): uint32 {.inline.} =
  cast[ptr wl_proxy](wl_data_device).get_version()
proc destroy*(wl_data_device: ptr wl_data_device) {.inline.} =
  destroy cast[ptr wl_proxy](wl_data_device)
proc start_drag*(wl_data_device: ptr wl_data_device; source: ptr wl_data_source; origin: ptr wl_surface; icon: ptr wl_surface; serial: uint32) {.inline.} =
  ## start drag-and-drop operation
  ## 
  ## This request asks the compositor to start a drag-and-drop
  ## 	operation on behalf of the client.
  ## 
  ## 	The source argument is the data source that provides the data
  ## 	for the eventual data transfer. If source is NULL, enter, leave
  ## 	and motion events are sent only to the client that initiated the
  ## 	drag and the client is expected to handle the data passing
  ## 	internally. If source is destroyed, the drag-and-drop session will be
  ## 	cancelled.
  ## 
  ## 	The origin surface is the surface where the drag originates and
  ## 	the client must have an active implicit grab that matches the
  ## 	serial.
  ## 
  ## 	The icon surface is an optional (can be NULL) surface that
  ## 	provides an icon to be moved around with the cursor.  Initially,
  ## 	the top-left corner of the icon surface is placed at the cursor
  ## 	hotspot, but subsequent wl_surface.offset requests can move the
  ## 	relative position. Attach requests must be confirmed with
  ## 	wl_surface.commit as usual. The icon surface is given the role of
  ## 	a drag-and-drop icon. If the icon surface already has another role,
  ## 	it raises a protocol error.
  ## 
  ## 	The input region is ignored for wl_surfaces with the role of a
  ## 	drag-and-drop icon.
  ## 
  ## 	The given source may not be used in any further set_selection or
  ## 	start_drag requests. Attempting to reuse a previously-used source
  ## 	may send a used_source error.
  ## 
  cast[ptr wl_proxy](wl_data_device).marshal_flags(wl_data_device_request_start_drag.ord, nil, cast[ptr wl_proxy](wl_data_device).get_version(), 0, source, origin, icon, serial)
proc set_selection*(wl_data_device: ptr wl_data_device; source: ptr wl_data_source; serial: uint32) {.inline.} =
  ## copy data to the selection
  ## 
  ## This request asks the compositor to set the selection
  ## 	to the data from the source on behalf of the client.
  ## 
  ## 	To unset the selection, set the source to NULL.
  ## 
  ## 	The given source may not be used in any further set_selection or
  ## 	start_drag requests. Attempting to reuse a previously-used source
  ## 	may send a used_source error.
  ## 
  cast[ptr wl_proxy](wl_data_device).marshal_flags(wl_data_device_request_set_selection.ord, nil, cast[ptr wl_proxy](wl_data_device).get_version(), 0, source, serial)
proc release*(wl_data_device: ptr wl_data_device) {.inline.} =
  ## destroy data device
  ## 
  ## This request destroys the data device.
  ## 
  cast[ptr wl_proxy](wl_data_device).marshal_flags(wl_data_device_request_release.ord, nil, cast[ptr wl_proxy](wl_data_device).get_version(), WL_MARSHAL_FLAG_DESTROY)
proc set_user_data*(wl_data_device_manager: ptr wl_data_device_manager; user_data: pointer) {.inline.} =
  cast[ptr wl_proxy](wl_data_device_manager).set_user_data(user_data)
proc get_user_data*(wl_data_device_manager: ptr wl_data_device_manager): pointer {.inline.} =
  cast[ptr wl_proxy](wl_data_device_manager).get_user_data()
proc get_version*(wl_data_device_manager: ptr wl_data_device_manager): uint32 {.inline.} =
  cast[ptr wl_proxy](wl_data_device_manager).get_version()
proc destroy*(wl_data_device_manager: ptr wl_data_device_manager) {.inline.} =
  destroy cast[ptr wl_proxy](wl_data_device_manager)
proc create_data_source*(wl_data_device_manager: ptr wl_data_device_manager): ptr wl_data_source {.inline.} =
  ## create a new data source
  ## 
  ## Create a new data source.
  ## 
  cast[ptr wl_data_source](cast[ptr wl_proxy](wl_data_device_manager).marshal_flags(wl_data_device_manager_request_create_data_source.ord, addr wl_data_source_interface, cast[ptr wl_proxy](wl_data_device_manager).get_version(), 0, nil))
proc get_data_device*(wl_data_device_manager: ptr wl_data_device_manager; seat: ptr wl_seat): ptr wl_data_device {.inline.} =
  ## create a new data device
  ## 
  ## Create a new data device for a given seat.
  ## 
  cast[ptr wl_data_device](cast[ptr wl_proxy](wl_data_device_manager).marshal_flags(wl_data_device_manager_request_get_data_device.ord, addr wl_data_device_interface, cast[ptr wl_proxy](wl_data_device_manager).get_version(), 0, nil, seat))
proc set_user_data*(wl_shell: ptr wl_shell; user_data: pointer) {.inline.} =
  cast[ptr wl_proxy](wl_shell).set_user_data(user_data)
proc get_user_data*(wl_shell: ptr wl_shell): pointer {.inline.} =
  cast[ptr wl_proxy](wl_shell).get_user_data()
proc get_version*(wl_shell: ptr wl_shell): uint32 {.inline.} =
  cast[ptr wl_proxy](wl_shell).get_version()
proc destroy*(wl_shell: ptr wl_shell) {.inline.} =
  destroy cast[ptr wl_proxy](wl_shell)
proc get_shell_surface*(wl_shell: ptr wl_shell; surface: ptr wl_surface): ptr wl_shell_surface {.inline.} =
  ## create a shell surface from a surface
  ## 
  ## Create a shell surface for an existing surface. This gives
  ## 	the wl_surface the role of a shell surface. If the wl_surface
  ## 	already has another role, it raises a protocol error.
  ## 
  ## 	Only one shell surface can be associated with a given surface.
  ## 
  cast[ptr wl_shell_surface](cast[ptr wl_proxy](wl_shell).marshal_flags(wl_shell_request_get_shell_surface.ord, addr wl_shell_surface_interface, cast[ptr wl_proxy](wl_shell).get_version(), 0, nil, surface))
type WlShellSurfaceListener* = object
  ping*: proc(
    data: pointer;
    wl_shell_surface: ptr wl_shell_surface;
    serial: uint32;
  ) {.nimcall.}
  configure*: proc(
    data: pointer;
    wl_shell_surface: ptr wl_shell_surface;
    edges: uint32;
    width: int32;
    height: int32;
  ) {.nimcall.}
  popup_done*: proc(
    data: pointer;
    wl_shell_surface: ptr wl_shell_surface;
  ) {.nimcall.}
proc add_listener*(wl_shell_surface: ptr wl_shell_surface; listener: ptr WlShellSurfaceListener; data: pointer): int {.inline.} =
  cast[ptr wl_proxy](wl_shell_surface).add_listener(listener, data)

proc set_user_data*(wl_shell_surface: ptr wl_shell_surface; user_data: pointer) {.inline.} =
  cast[ptr wl_proxy](wl_shell_surface).set_user_data(user_data)
proc get_user_data*(wl_shell_surface: ptr wl_shell_surface): pointer {.inline.} =
  cast[ptr wl_proxy](wl_shell_surface).get_user_data()
proc get_version*(wl_shell_surface: ptr wl_shell_surface): uint32 {.inline.} =
  cast[ptr wl_proxy](wl_shell_surface).get_version()
proc destroy*(wl_shell_surface: ptr wl_shell_surface) {.inline.} =
  destroy cast[ptr wl_proxy](wl_shell_surface)
proc pong*(wl_shell_surface: ptr wl_shell_surface; serial: uint32) {.inline.} =
  ## respond to a ping event
  ## 
  ## A client must respond to a ping event with a pong request or
  ## 	the client may be deemed unresponsive.
  ## 
  cast[ptr wl_proxy](wl_shell_surface).marshal_flags(wl_shell_surface_request_pong.ord, nil, cast[ptr wl_proxy](wl_shell_surface).get_version(), 0, serial)
proc move*(wl_shell_surface: ptr wl_shell_surface; seat: ptr wl_seat; serial: uint32) {.inline.} =
  ## start an interactive move
  ## 
  ## Start a pointer-driven move of the surface.
  ## 
  ## 	This request must be used in response to a button press event.
  ## 	The server may ignore move requests depending on the state of
  ## 	the surface (e.g. fullscreen or maximized).
  ## 
  cast[ptr wl_proxy](wl_shell_surface).marshal_flags(wl_shell_surface_request_move.ord, nil, cast[ptr wl_proxy](wl_shell_surface).get_version(), 0, seat, serial)
proc resize*(wl_shell_surface: ptr wl_shell_surface; seat: ptr wl_seat; serial: uint32; edges: uint32) {.inline.} =
  ## start an interactive resize
  ## 
  ## Start a pointer-driven resizing of the surface.
  ## 
  ## 	This request must be used in response to a button press event.
  ## 	The server may ignore resize requests depending on the state of
  ## 	the surface (e.g. fullscreen or maximized).
  ## 
  cast[ptr wl_proxy](wl_shell_surface).marshal_flags(wl_shell_surface_request_resize.ord, nil, cast[ptr wl_proxy](wl_shell_surface).get_version(), 0, seat, serial, edges)
proc set_toplevel*(wl_shell_surface: ptr wl_shell_surface) {.inline.} =
  ## make the surface a toplevel surface
  ## 
  ## Map the surface as a toplevel surface.
  ## 
  ## 	A toplevel surface is not fullscreen, maximized or transient.
  ## 
  cast[ptr wl_proxy](wl_shell_surface).marshal_flags(wl_shell_surface_request_set_toplevel.ord, nil, cast[ptr wl_proxy](wl_shell_surface).get_version(), 0)
proc set_transient*(wl_shell_surface: ptr wl_shell_surface; parent: ptr wl_surface; x: int32; y: int32; flags: uint32) {.inline.} =
  ## make the surface a transient surface
  ## 
  ## Map the surface relative to an existing surface.
  ## 
  ## 	The x and y arguments specify the location of the upper left
  ## 	corner of the surface relative to the upper left corner of the
  ## 	parent surface, in surface-local coordinates.
  ## 
  ## 	The flags argument controls details of the transient behaviour.
  ## 
  cast[ptr wl_proxy](wl_shell_surface).marshal_flags(wl_shell_surface_request_set_transient.ord, nil, cast[ptr wl_proxy](wl_shell_surface).get_version(), 0, parent, x, y, flags)
proc set_fullscreen*(wl_shell_surface: ptr wl_shell_surface; `method`: uint32; framerate: uint32; output: ptr wl_output) {.inline.} =
  ## make the surface a fullscreen surface
  ## 
  ## Map the surface as a fullscreen surface.
  ## 
  ## 	If an output parameter is given then the surface will be made
  ## 	fullscreen on that output. If the client does not specify the
  ## 	output then the compositor will apply its policy - usually
  ## 	choosing the output on which the surface has the biggest surface
  ## 	area.
  ## 
  ## 	The client may specify a method to resolve a size conflict
  ## 	between the output size and the surface size - this is provided
  ## 	through the method parameter.
  ## 
  ## 	The framerate parameter is used only when the method is set
  ## 	to "driver", to indicate the preferred framerate. A value of 0
  ## 	indicates that the client does not care about framerate.  The
  ## 	framerate is specified in mHz, that is framerate of 60000 is 60Hz.
  ## 
  ## 	A method of "scale" or "driver" implies a scaling operation of
  ## 	the surface, either via a direct scaling operation or a change of
  ## 	the output mode. This will override any kind of output scaling, so
  ## 	that mapping a surface with a buffer size equal to the mode can
  ## 	fill the screen independent of buffer_scale.
  ## 
  ## 	A method of "fill" means we don't scale up the buffer, however
  ## 	any output scale is applied. This means that you may run into
  ## 	an edge case where the application maps a buffer with the same
  ## 	size of the output mode but buffer_scale 1 (thus making a
  ## 	surface larger than the output). In this case it is allowed to
  ## 	downscale the results to fit the screen.
  ## 
  ## 	The compositor must reply to this request with a configure event
  ## 	with the dimensions for the output on which the surface will
  ## 	be made fullscreen.
  ## 
  cast[ptr wl_proxy](wl_shell_surface).marshal_flags(wl_shell_surface_request_set_fullscreen.ord, nil, cast[ptr wl_proxy](wl_shell_surface).get_version(), 0, `method`, framerate, output)
proc set_popup*(wl_shell_surface: ptr wl_shell_surface; seat: ptr wl_seat; serial: uint32; parent: ptr wl_surface; x: int32; y: int32; flags: uint32) {.inline.} =
  ## make the surface a popup surface
  ## 
  ## Map the surface as a popup.
  ## 
  ## 	A popup surface is a transient surface with an added pointer
  ## 	grab.
  ## 
  ## 	An existing implicit grab will be changed to owner-events mode,
  ## 	and the popup grab will continue after the implicit grab ends
  ## 	(i.e. releasing the mouse button does not cause the popup to
  ## 	be unmapped).
  ## 
  ## 	The popup grab continues until the window is destroyed or a
  ## 	mouse button is pressed in any other client's window. A click
  ## 	in any of the client's surfaces is reported as normal, however,
  ## 	clicks in other clients' surfaces will be discarded and trigger
  ## 	the callback.
  ## 
  ## 	The x and y arguments specify the location of the upper left
  ## 	corner of the surface relative to the upper left corner of the
  ## 	parent surface, in surface-local coordinates.
  ## 
  cast[ptr wl_proxy](wl_shell_surface).marshal_flags(wl_shell_surface_request_set_popup.ord, nil, cast[ptr wl_proxy](wl_shell_surface).get_version(), 0, seat, serial, parent, x, y, flags)
proc set_maximized*(wl_shell_surface: ptr wl_shell_surface; output: ptr wl_output) {.inline.} =
  ## make the surface a maximized surface
  ## 
  ## Map the surface as a maximized surface.
  ## 
  ## 	If an output parameter is given then the surface will be
  ## 	maximized on that output. If the client does not specify the
  ## 	output then the compositor will apply its policy - usually
  ## 	choosing the output on which the surface has the biggest surface
  ## 	area.
  ## 
  ## 	The compositor will reply with a configure event telling
  ## 	the expected new surface size. The operation is completed
  ## 	on the next buffer attach to this surface.
  ## 
  ## 	A maximized surface typically fills the entire output it is
  ## 	bound to, except for desktop elements such as panels. This is
  ## 	the main difference between a maximized shell surface and a
  ## 	fullscreen shell surface.
  ## 
  ## 	The details depend on the compositor implementation.
  ## 
  cast[ptr wl_proxy](wl_shell_surface).marshal_flags(wl_shell_surface_request_set_maximized.ord, nil, cast[ptr wl_proxy](wl_shell_surface).get_version(), 0, output)
proc set_title*(wl_shell_surface: ptr wl_shell_surface; title: cstring) {.inline.} =
  ## set surface title
  ## 
  ## Set a short title for the surface.
  ## 
  ## 	This string may be used to identify the surface in a task bar,
  ## 	window list, or other user interface elements provided by the
  ## 	compositor.
  ## 
  ## 	The string must be encoded in UTF-8.
  ## 
  cast[ptr wl_proxy](wl_shell_surface).marshal_flags(wl_shell_surface_request_set_title.ord, nil, cast[ptr wl_proxy](wl_shell_surface).get_version(), 0, title)
proc set_class*(wl_shell_surface: ptr wl_shell_surface; class: cstring) {.inline.} =
  ## set surface class
  ## 
  ## Set a class for the surface.
  ## 
  ## 	The surface class identifies the general class of applications
  ## 	to which the surface belongs. A common convention is to use the
  ## 	file name (or the full path if it is a non-standard location) of
  ## 	the application's .desktop file as the class.
  ## 
  cast[ptr wl_proxy](wl_shell_surface).marshal_flags(wl_shell_surface_request_set_class.ord, nil, cast[ptr wl_proxy](wl_shell_surface).get_version(), 0, class)
type WlSurfaceListener* = object
  enter*: proc(
    data: pointer;
    wl_surface: ptr wl_surface;
    output: ptr wl_output;
  ) {.nimcall.}
  leave*: proc(
    data: pointer;
    wl_surface: ptr wl_surface;
    output: ptr wl_output;
  ) {.nimcall.}
  preferred_buffer_scale*: proc(
    data: pointer;
    wl_surface: ptr wl_surface;
    factor: int32;
  ) {.nimcall.}
  preferred_buffer_transform*: proc(
    data: pointer;
    wl_surface: ptr wl_surface;
    transform: uint32;
  ) {.nimcall.}
proc add_listener*(wl_surface: ptr wl_surface; listener: ptr WlSurfaceListener; data: pointer): int {.inline.} =
  cast[ptr wl_proxy](wl_surface).add_listener(listener, data)

proc set_user_data*(wl_surface: ptr wl_surface; user_data: pointer) {.inline.} =
  cast[ptr wl_proxy](wl_surface).set_user_data(user_data)
proc get_user_data*(wl_surface: ptr wl_surface): pointer {.inline.} =
  cast[ptr wl_proxy](wl_surface).get_user_data()
proc get_version*(wl_surface: ptr wl_surface): uint32 {.inline.} =
  cast[ptr wl_proxy](wl_surface).get_version()
proc destroy*(wl_surface: ptr wl_surface) {.inline.} =
  ## delete surface
  ## 
  ## Deletes the surface and invalidates its object ID.
  ## 
  cast[ptr wl_proxy](wl_surface).marshal_flags(wl_surface_request_destroy.ord, nil, cast[ptr wl_proxy](wl_surface).get_version(), WL_MARSHAL_FLAG_DESTROY)
proc attach*(wl_surface: ptr wl_surface; buffer: ptr wl_buffer; x: int32; y: int32) {.inline.} =
  ## set the surface contents
  ## 
  ## Set a buffer as the content of this surface.
  ## 
  ## 	The new size of the surface is calculated based on the buffer
  ## 	size transformed by the inverse buffer_transform and the
  ## 	inverse buffer_scale. This means that at commit time the supplied
  ## 	buffer size must be an integer multiple of the buffer_scale. If
  ## 	that's not the case, an invalid_size error is sent.
  ## 
  ## 	The x and y arguments specify the location of the new pending
  ## 	buffer's upper left corner, relative to the current buffer's upper
  ## 	left corner, in surface-local coordinates. In other words, the
  ## 	x and y, combined with the new surface size define in which
  ## 	directions the surface's size changes. Setting anything other than 0
  ## 	as x and y arguments is discouraged, and should instead be replaced
  ## 	with using the separate wl_surface.offset request.
  ## 
  ## 	When the bound wl_surface version is 5 or higher, passing any
  ## 	non-zero x or y is a protocol violation, and will result in an
  ## 	'invalid_offset' error being raised. The x and y arguments are ignored
  ## 	and do not change the pending state. To achieve equivalent semantics,
  ## 	use wl_surface.offset.
  ## 
  ## 	Surface contents are double-buffered state, see wl_surface.commit.
  ## 
  ## 	The initial surface contents are void; there is no content.
  ## 	wl_surface.attach assigns the given wl_buffer as the pending
  ## 	wl_buffer. wl_surface.commit makes the pending wl_buffer the new
  ## 	surface contents, and the size of the surface becomes the size
  ## 	calculated from the wl_buffer, as described above. After commit,
  ## 	there is no pending buffer until the next attach.
  ## 
  ## 	Committing a pending wl_buffer allows the compositor to read the
  ## 	pixels in the wl_buffer. The compositor may access the pixels at
  ## 	any time after the wl_surface.commit request. When the compositor
  ## 	will not access the pixels anymore, it will send the
  ## 	wl_buffer.release event. Only after receiving wl_buffer.release,
  ## 	the client may reuse the wl_buffer. A wl_buffer that has been
  ## 	attached and then replaced by another attach instead of committed
  ## 	will not receive a release event, and is not used by the
  ## 	compositor.
  ## 
  ## 	If a pending wl_buffer has been committed to more than one wl_surface,
  ## 	the delivery of wl_buffer.release events becomes undefined. A well
  ## 	behaved client should not rely on wl_buffer.release events in this
  ## 	case. Alternatively, a client could create multiple wl_buffer objects
  ## 	from the same backing storage or use wp_linux_buffer_release.
  ## 
  ## 	Destroying the wl_buffer after wl_buffer.release does not change
  ## 	the surface contents. Destroying the wl_buffer before wl_buffer.release
  ## 	is allowed as long as the underlying buffer storage isn't re-used (this
  ## 	can happen e.g. on client process termination). However, if the client
  ## 	destroys the wl_buffer before receiving the wl_buffer.release event and
  ## 	mutates the underlying buffer storage, the surface contents become
  ## 	undefined immediately.
  ## 
  ## 	If wl_surface.attach is sent with a NULL wl_buffer, the
  ## 	following wl_surface.commit will remove the surface content.
  ## 
  ## 	If a pending wl_buffer has been destroyed, the result is not specified.
  ## 	Many compositors are known to remove the surface content on the following
  ## 	wl_surface.commit, but this behaviour is not universal. Clients seeking to
  ## 	maximise compatibility should not destroy pending buffers and should
  ## 	ensure that they explicitly remove content from surfaces, even after
  ## 	destroying buffers.
  ## 
  cast[ptr wl_proxy](wl_surface).marshal_flags(wl_surface_request_attach.ord, nil, cast[ptr wl_proxy](wl_surface).get_version(), 0, buffer, x, y)
proc damage*(wl_surface: ptr wl_surface; x: int32; y: int32; width: int32; height: int32) {.inline.} =
  ## mark part of the surface damaged
  ## 
  ## This request is used to describe the regions where the pending
  ## 	buffer is different from the current surface contents, and where
  ## 	the surface therefore needs to be repainted. The compositor
  ## 	ignores the parts of the damage that fall outside of the surface.
  ## 
  ## 	Damage is double-buffered state, see wl_surface.commit.
  ## 
  ## 	The damage rectangle is specified in surface-local coordinates,
  ## 	where x and y specify the upper left corner of the damage rectangle.
  ## 
  ## 	The initial value for pending damage is empty: no damage.
  ## 	wl_surface.damage adds pending damage: the new pending damage
  ## 	is the union of old pending damage and the given rectangle.
  ## 
  ## 	wl_surface.commit assigns pending damage as the current damage,
  ## 	and clears pending damage. The server will clear the current
  ## 	damage as it repaints the surface.
  ## 
  ## 	Note! New clients should not use this request. Instead damage can be
  ## 	posted with wl_surface.damage_buffer which uses buffer coordinates
  ## 	instead of surface coordinates.
  ## 
  cast[ptr wl_proxy](wl_surface).marshal_flags(wl_surface_request_damage.ord, nil, cast[ptr wl_proxy](wl_surface).get_version(), 0, x, y, width, height)
proc frame*(wl_surface: ptr wl_surface): ptr wl_callback {.inline.} =
  ## request a frame throttling hint
  ## 
  ## Request a notification when it is a good time to start drawing a new
  ## 	frame, by creating a frame callback. This is useful for throttling
  ## 	redrawing operations, and driving animations.
  ## 
  ## 	When a client is animating on a wl_surface, it can use the 'frame'
  ## 	request to get notified when it is a good time to draw and commit the
  ## 	next frame of animation. If the client commits an update earlier than
  ## 	that, it is likely that some updates will not make it to the display,
  ## 	and the client is wasting resources by drawing too often.
  ## 
  ## 	The frame request will take effect on the next wl_surface.commit.
  ## 	The notification will only be posted for one frame unless
  ## 	requested again. For a wl_surface, the notifications are posted in
  ## 	the order the frame requests were committed.
  ## 
  ## 	The server must send the notifications so that a client
  ## 	will not send excessive updates, while still allowing
  ## 	the highest possible update rate for clients that wait for the reply
  ## 	before drawing again. The server should give some time for the client
  ## 	to draw and commit after sending the frame callback events to let it
  ## 	hit the next output refresh.
  ## 
  ## 	A server should avoid signaling the frame callbacks if the
  ## 	surface is not visible in any way, e.g. the surface is off-screen,
  ## 	or completely obscured by other opaque surfaces.
  ## 
  ## 	The object returned by this request will be destroyed by the
  ## 	compositor after the callback is fired and as such the client must not
  ## 	attempt to use it after that point.
  ## 
  ## 	The callback_data passed in the callback is the current time, in
  ## 	milliseconds, with an undefined base.
  ## 
  cast[ptr wl_callback](cast[ptr wl_proxy](wl_surface).marshal_flags(wl_surface_request_frame.ord, addr wl_callback_interface, cast[ptr wl_proxy](wl_surface).get_version(), 0, nil))
proc set_opaque_region*(wl_surface: ptr wl_surface; region: ptr wl_region) {.inline.} =
  ## set opaque region
  ## 
  ## This request sets the region of the surface that contains
  ## 	opaque content.
  ## 
  ## 	The opaque region is an optimization hint for the compositor
  ## 	that lets it optimize the redrawing of content behind opaque
  ## 	regions.  Setting an opaque region is not required for correct
  ## 	behaviour, but marking transparent content as opaque will result
  ## 	in repaint artifacts.
  ## 
  ## 	The opaque region is specified in surface-local coordinates.
  ## 
  ## 	The compositor ignores the parts of the opaque region that fall
  ## 	outside of the surface.
  ## 
  ## 	Opaque region is double-buffered state, see wl_surface.commit.
  ## 
  ## 	wl_surface.set_opaque_region changes the pending opaque region.
  ## 	wl_surface.commit copies the pending region to the current region.
  ## 	Otherwise, the pending and current regions are never changed.
  ## 
  ## 	The initial value for an opaque region is empty. Setting the pending
  ## 	opaque region has copy semantics, and the wl_region object can be
  ## 	destroyed immediately. A NULL wl_region causes the pending opaque
  ## 	region to be set to empty.
  ## 
  cast[ptr wl_proxy](wl_surface).marshal_flags(wl_surface_request_set_opaque_region.ord, nil, cast[ptr wl_proxy](wl_surface).get_version(), 0, region)
proc set_input_region*(wl_surface: ptr wl_surface; region: ptr wl_region) {.inline.} =
  ## set input region
  ## 
  ## This request sets the region of the surface that can receive
  ## 	pointer and touch events.
  ## 
  ## 	Input events happening outside of this region will try the next
  ## 	surface in the server surface stack. The compositor ignores the
  ## 	parts of the input region that fall outside of the surface.
  ## 
  ## 	The input region is specified in surface-local coordinates.
  ## 
  ## 	Input region is double-buffered state, see wl_surface.commit.
  ## 
  ## 	wl_surface.set_input_region changes the pending input region.
  ## 	wl_surface.commit copies the pending region to the current region.
  ## 	Otherwise the pending and current regions are never changed,
  ## 	except cursor and icon surfaces are special cases, see
  ## 	wl_pointer.set_cursor and wl_data_device.start_drag.
  ## 
  ## 	The initial value for an input region is infinite. That means the
  ## 	whole surface will accept input. Setting the pending input region
  ## 	has copy semantics, and the wl_region object can be destroyed
  ## 	immediately. A NULL wl_region causes the input region to be set
  ## 	to infinite.
  ## 
  cast[ptr wl_proxy](wl_surface).marshal_flags(wl_surface_request_set_input_region.ord, nil, cast[ptr wl_proxy](wl_surface).get_version(), 0, region)
proc commit*(wl_surface: ptr wl_surface) {.inline.} =
  ## commit pending surface state
  ## 
  ## Surface state (input, opaque, and damage regions, attached buffers,
  ## 	etc.) is double-buffered. Protocol requests modify the pending state,
  ## 	as opposed to the active state in use by the compositor.
  ## 
  ## 	A commit request atomically creates a content update from the pending
  ## 	state, even if the pending state has not been touched. The content
  ## 	update is placed in a queue until it becomes active. After commit, the
  ## 	new pending state is as documented for each related request.
  ## 
  ## 	When the content update is applied, the wl_buffer is applied before all
  ## 	other state. This means that all coordinates in double-buffered state
  ## 	are relative to the newly attached wl_buffers, except for
  ## 	wl_surface.attach itself. If there is no newly attached wl_buffer, the
  ## 	coordinates are relative to the previous content update.
  ## 
  ## 	All requests that need a commit to become effective are documented
  ## 	to affect double-buffered state.
  ## 
  ## 	Other interfaces may add further double-buffered surface state.
  ## 
  cast[ptr wl_proxy](wl_surface).marshal_flags(wl_surface_request_commit.ord, nil, cast[ptr wl_proxy](wl_surface).get_version(), 0)
proc set_buffer_transform*(wl_surface: ptr wl_surface; transform: int32) {.inline.} =
  ## sets the buffer transformation
  ## 
  ## This request sets the transformation that the client has already applied
  ## 	to the content of the buffer. The accepted values for the transform
  ## 	parameter are the values for wl_output.transform.
  ## 
  ## 	The compositor applies the inverse of this transformation whenever it
  ## 	uses the buffer contents.
  ## 
  ## 	Buffer transform is double-buffered state, see wl_surface.commit.
  ## 
  ## 	A newly created surface has its buffer transformation set to normal.
  ## 
  ## 	wl_surface.set_buffer_transform changes the pending buffer
  ## 	transformation. wl_surface.commit copies the pending buffer
  ## 	transformation to the current one. Otherwise, the pending and current
  ## 	values are never changed.
  ## 
  ## 	The purpose of this request is to allow clients to render content
  ## 	according to the output transform, thus permitting the compositor to
  ## 	use certain optimizations even if the display is rotated. Using
  ## 	hardware overlays and scanning out a client buffer for fullscreen
  ## 	surfaces are examples of such optimizations. Those optimizations are
  ## 	highly dependent on the compositor implementation, so the use of this
  ## 	request should be considered on a case-by-case basis.
  ## 
  ## 	Note that if the transform value includes 90 or 270 degree rotation,
  ## 	the width of the buffer will become the surface height and the height
  ## 	of the buffer will become the surface width.
  ## 
  ## 	If transform is not one of the values from the
  ## 	wl_output.transform enum the invalid_transform protocol error
  ## 	is raised.
  ## 
  cast[ptr wl_proxy](wl_surface).marshal_flags(wl_surface_request_set_buffer_transform.ord, nil, cast[ptr wl_proxy](wl_surface).get_version(), 0, transform)
proc set_buffer_scale*(wl_surface: ptr wl_surface; scale: int32) {.inline.} =
  ## sets the buffer scaling factor
  ## 
  ## This request sets an optional scaling factor on how the compositor
  ## 	interprets the contents of the buffer attached to the window.
  ## 
  ## 	Buffer scale is double-buffered state, see wl_surface.commit.
  ## 
  ## 	A newly created surface has its buffer scale set to 1.
  ## 
  ## 	wl_surface.set_buffer_scale changes the pending buffer scale.
  ## 	wl_surface.commit copies the pending buffer scale to the current one.
  ## 	Otherwise, the pending and current values are never changed.
  ## 
  ## 	The purpose of this request is to allow clients to supply higher
  ## 	resolution buffer data for use on high resolution outputs. It is
  ## 	intended that you pick the same buffer scale as the scale of the
  ## 	output that the surface is displayed on. This means the compositor
  ## 	can avoid scaling when rendering the surface on that output.
  ## 
  ## 	Note that if the scale is larger than 1, then you have to attach
  ## 	a buffer that is larger (by a factor of scale in each dimension)
  ## 	than the desired surface size.
  ## 
  ## 	If scale is not greater than 0 the invalid_scale protocol error is
  ## 	raised.
  ## 
  cast[ptr wl_proxy](wl_surface).marshal_flags(wl_surface_request_set_buffer_scale.ord, nil, cast[ptr wl_proxy](wl_surface).get_version(), 0, scale)
proc damage_buffer*(wl_surface: ptr wl_surface; x: int32; y: int32; width: int32; height: int32) {.inline.} =
  ## mark part of the surface damaged using buffer coordinates
  ## 
  ## This request is used to describe the regions where the pending
  ## 	buffer is different from the current surface contents, and where
  ## 	the surface therefore needs to be repainted. The compositor
  ## 	ignores the parts of the damage that fall outside of the surface.
  ## 
  ## 	Damage is double-buffered state, see wl_surface.commit.
  ## 
  ## 	The damage rectangle is specified in buffer coordinates,
  ## 	where x and y specify the upper left corner of the damage rectangle.
  ## 
  ## 	The initial value for pending damage is empty: no damage.
  ## 	wl_surface.damage_buffer adds pending damage: the new pending
  ## 	damage is the union of old pending damage and the given rectangle.
  ## 
  ## 	wl_surface.commit assigns pending damage as the current damage,
  ## 	and clears pending damage. The server will clear the current
  ## 	damage as it repaints the surface.
  ## 
  ## 	This request differs from wl_surface.damage in only one way - it
  ## 	takes damage in buffer coordinates instead of surface-local
  ## 	coordinates. While this generally is more intuitive than surface
  ## 	coordinates, it is especially desirable when using wp_viewport
  ## 	or when a drawing library (like EGL) is unaware of buffer scale
  ## 	and buffer transform.
  ## 
  ## 	Note: Because buffer transformation changes and damage requests may
  ## 	be interleaved in the protocol stream, it is impossible to determine
  ## 	the actual mapping between surface and buffer damage until
  ## 	wl_surface.commit time. Therefore, compositors wishing to take both
  ## 	kinds of damage into account will have to accumulate damage from the
  ## 	two requests separately and only transform from one to the other
  ## 	after receiving the wl_surface.commit.
  ## 
  cast[ptr wl_proxy](wl_surface).marshal_flags(wl_surface_request_damage_buffer.ord, nil, cast[ptr wl_proxy](wl_surface).get_version(), 0, x, y, width, height)
proc offset*(wl_surface: ptr wl_surface; x: int32; y: int32) {.inline.} =
  ## set the surface contents offset
  ## 
  ## The x and y arguments specify the location of the new pending
  ## 	buffer's upper left corner, relative to the current buffer's upper
  ## 	left corner, in surface-local coordinates. In other words, the
  ## 	x and y, combined with the new surface size define in which
  ## 	directions the surface's size changes.
  ## 
  ## 	Surface location offset is double-buffered state, see
  ## 	wl_surface.commit.
  ## 
  ## 	This request is semantically equivalent to and the replaces the x and y
  ## 	arguments in the wl_surface.attach request in wl_surface versions prior
  ## 	to 5. See wl_surface.attach for details.
  ## 
  cast[ptr wl_proxy](wl_surface).marshal_flags(wl_surface_request_offset.ord, nil, cast[ptr wl_proxy](wl_surface).get_version(), 0, x, y)
type WlSeatListener* = object
  capabilities*: proc(
    data: pointer;
    wl_seat: ptr wl_seat;
    capabilities: uint32;
  ) {.nimcall.}
  name*: proc(
    data: pointer;
    wl_seat: ptr wl_seat;
    name: cstring;
  ) {.nimcall.}
proc add_listener*(wl_seat: ptr wl_seat; listener: ptr WlSeatListener; data: pointer): int {.inline.} =
  cast[ptr wl_proxy](wl_seat).add_listener(listener, data)

proc set_user_data*(wl_seat: ptr wl_seat; user_data: pointer) {.inline.} =
  cast[ptr wl_proxy](wl_seat).set_user_data(user_data)
proc get_user_data*(wl_seat: ptr wl_seat): pointer {.inline.} =
  cast[ptr wl_proxy](wl_seat).get_user_data()
proc get_version*(wl_seat: ptr wl_seat): uint32 {.inline.} =
  cast[ptr wl_proxy](wl_seat).get_version()
proc destroy*(wl_seat: ptr wl_seat) {.inline.} =
  destroy cast[ptr wl_proxy](wl_seat)
proc get_pointer*(wl_seat: ptr wl_seat): ptr wl_pointer {.inline.} =
  ## return pointer object
  ## 
  ## The ID provided will be initialized to the wl_pointer interface
  ## 	for this seat.
  ## 
  ## 	This request only takes effect if the seat has the pointer
  ## 	capability, or has had the pointer capability in the past.
  ## 	It is a protocol violation to issue this request on a seat that has
  ## 	never had the pointer capability. The missing_capability error will
  ## 	be sent in this case.
  ## 
  cast[ptr wl_pointer](cast[ptr wl_proxy](wl_seat).marshal_flags(wl_seat_request_get_pointer.ord, addr wl_pointer_interface, cast[ptr wl_proxy](wl_seat).get_version(), 0, nil))
proc get_keyboard*(wl_seat: ptr wl_seat): ptr wl_keyboard {.inline.} =
  ## return keyboard object
  ## 
  ## The ID provided will be initialized to the wl_keyboard interface
  ## 	for this seat.
  ## 
  ## 	This request only takes effect if the seat has the keyboard
  ## 	capability, or has had the keyboard capability in the past.
  ## 	It is a protocol violation to issue this request on a seat that has
  ## 	never had the keyboard capability. The missing_capability error will
  ## 	be sent in this case.
  ## 
  cast[ptr wl_keyboard](cast[ptr wl_proxy](wl_seat).marshal_flags(wl_seat_request_get_keyboard.ord, addr wl_keyboard_interface, cast[ptr wl_proxy](wl_seat).get_version(), 0, nil))
proc get_touch*(wl_seat: ptr wl_seat): ptr wl_touch {.inline.} =
  ## return touch object
  ## 
  ## The ID provided will be initialized to the wl_touch interface
  ## 	for this seat.
  ## 
  ## 	This request only takes effect if the seat has the touch
  ## 	capability, or has had the touch capability in the past.
  ## 	It is a protocol violation to issue this request on a seat that has
  ## 	never had the touch capability. The missing_capability error will
  ## 	be sent in this case.
  ## 
  cast[ptr wl_touch](cast[ptr wl_proxy](wl_seat).marshal_flags(wl_seat_request_get_touch.ord, addr wl_touch_interface, cast[ptr wl_proxy](wl_seat).get_version(), 0, nil))
proc release*(wl_seat: ptr wl_seat) {.inline.} =
  ## release the seat object
  ## 
  ## Using this request a client can tell the server that it is not going to
  ## 	use the seat object anymore.
  ## 
  cast[ptr wl_proxy](wl_seat).marshal_flags(wl_seat_request_release.ord, nil, cast[ptr wl_proxy](wl_seat).get_version(), WL_MARSHAL_FLAG_DESTROY)
type WlPointerListener* = object
  enter*: proc(
    data: pointer;
    wl_pointer: ptr wl_pointer;
    serial: uint32;
    surface: ptr wl_surface;
    surface_x: wl_fixed_t;
    surface_y: wl_fixed_t;
  ) {.nimcall.}
  leave*: proc(
    data: pointer;
    wl_pointer: ptr wl_pointer;
    serial: uint32;
    surface: ptr wl_surface;
  ) {.nimcall.}
  motion*: proc(
    data: pointer;
    wl_pointer: ptr wl_pointer;
    time: uint32;
    surface_x: wl_fixed_t;
    surface_y: wl_fixed_t;
  ) {.nimcall.}
  button*: proc(
    data: pointer;
    wl_pointer: ptr wl_pointer;
    serial: uint32;
    time: uint32;
    button: uint32;
    state: uint32;
  ) {.nimcall.}
  axis*: proc(
    data: pointer;
    wl_pointer: ptr wl_pointer;
    time: uint32;
    axis: uint32;
    value: wl_fixed_t;
  ) {.nimcall.}
  frame*: proc(
    data: pointer;
    wl_pointer: ptr wl_pointer;
  ) {.nimcall.}
  axis_source*: proc(
    data: pointer;
    wl_pointer: ptr wl_pointer;
    axis_source: uint32;
  ) {.nimcall.}
  axis_stop*: proc(
    data: pointer;
    wl_pointer: ptr wl_pointer;
    time: uint32;
    axis: uint32;
  ) {.nimcall.}
  axis_discrete*: proc(
    data: pointer;
    wl_pointer: ptr wl_pointer;
    axis: uint32;
    discrete: int32;
  ) {.nimcall.}
  axis_value120*: proc(
    data: pointer;
    wl_pointer: ptr wl_pointer;
    axis: uint32;
    value120: int32;
  ) {.nimcall.}
  axis_relative_direction*: proc(
    data: pointer;
    wl_pointer: ptr wl_pointer;
    axis: uint32;
    direction: uint32;
  ) {.nimcall.}
proc add_listener*(wl_pointer: ptr wl_pointer; listener: ptr WlPointerListener; data: pointer): int {.inline.} =
  cast[ptr wl_proxy](wl_pointer).add_listener(listener, data)

proc set_user_data*(wl_pointer: ptr wl_pointer; user_data: pointer) {.inline.} =
  cast[ptr wl_proxy](wl_pointer).set_user_data(user_data)
proc get_user_data*(wl_pointer: ptr wl_pointer): pointer {.inline.} =
  cast[ptr wl_proxy](wl_pointer).get_user_data()
proc get_version*(wl_pointer: ptr wl_pointer): uint32 {.inline.} =
  cast[ptr wl_proxy](wl_pointer).get_version()
proc destroy*(wl_pointer: ptr wl_pointer) {.inline.} =
  destroy cast[ptr wl_proxy](wl_pointer)
proc set_cursor*(wl_pointer: ptr wl_pointer; serial: uint32; surface: ptr wl_surface; hotspot_x: int32; hotspot_y: int32) {.inline.} =
  ## set the pointer surface
  ## 
  ## Set the pointer surface, i.e., the surface that contains the
  ## 	pointer image (cursor). This request gives the surface the role
  ## 	of a cursor. If the surface already has another role, it raises
  ## 	a protocol error.
  ## 
  ## 	The cursor actually changes only if the pointer
  ## 	focus for this device is one of the requesting client's surfaces
  ## 	or the surface parameter is the current pointer surface. If
  ## 	there was a previous surface set with this request it is
  ## 	replaced. If surface is NULL, the pointer image is hidden.
  ## 
  ## 	The parameters hotspot_x and hotspot_y define the position of
  ## 	the pointer surface relative to the pointer location. Its
  ## 	top-left corner is always at (x, y) - (hotspot_x, hotspot_y),
  ## 	where (x, y) are the coordinates of the pointer location, in
  ## 	surface-local coordinates.
  ## 
  ## 	On wl_surface.offset requests to the pointer surface, hotspot_x
  ## 	and hotspot_y are decremented by the x and y parameters
  ## 	passed to the request. The offset must be applied by
  ## 	wl_surface.commit as usual.
  ## 
  ## 	The hotspot can also be updated by passing the currently set
  ## 	pointer surface to this request with new values for hotspot_x
  ## 	and hotspot_y.
  ## 
  ## 	The input region is ignored for wl_surfaces with the role of
  ## 	a cursor. When the use as a cursor ends, the wl_surface is
  ## 	unmapped.
  ## 
  ## 	The serial parameter must match the latest wl_pointer.enter
  ## 	serial number sent to the client. Otherwise the request will be
  ## 	ignored.
  ## 
  cast[ptr wl_proxy](wl_pointer).marshal_flags(wl_pointer_request_set_cursor.ord, nil, cast[ptr wl_proxy](wl_pointer).get_version(), 0, serial, surface, hotspot_x, hotspot_y)
proc release*(wl_pointer: ptr wl_pointer) {.inline.} =
  ## release the pointer object
  ## 
  ## Using this request a client can tell the server that it is not going to
  ## 	use the pointer object anymore.
  ## 
  ## 	This request destroys the pointer proxy object, so clients must not call
  ## 	wl_pointer_destroy() after using this request.
  ## 
  cast[ptr wl_proxy](wl_pointer).marshal_flags(wl_pointer_request_release.ord, nil, cast[ptr wl_proxy](wl_pointer).get_version(), WL_MARSHAL_FLAG_DESTROY)
type WlKeyboardListener* = object
  keymap*: proc(
    data: pointer;
    wl_keyboard: ptr wl_keyboard;
    format: uint32;
    fd: int32;
    size: uint32;
  ) {.nimcall.}
  enter*: proc(
    data: pointer;
    wl_keyboard: ptr wl_keyboard;
    serial: uint32;
    surface: ptr wl_surface;
    keys: ptr wl_array;
  ) {.nimcall.}
  leave*: proc(
    data: pointer;
    wl_keyboard: ptr wl_keyboard;
    serial: uint32;
    surface: ptr wl_surface;
  ) {.nimcall.}
  key*: proc(
    data: pointer;
    wl_keyboard: ptr wl_keyboard;
    serial: uint32;
    time: uint32;
    key: uint32;
    state: uint32;
  ) {.nimcall.}
  modifiers*: proc(
    data: pointer;
    wl_keyboard: ptr wl_keyboard;
    serial: uint32;
    mods_depressed: uint32;
    mods_latched: uint32;
    mods_locked: uint32;
    group: uint32;
  ) {.nimcall.}
  repeat_info*: proc(
    data: pointer;
    wl_keyboard: ptr wl_keyboard;
    rate: int32;
    delay: int32;
  ) {.nimcall.}
proc add_listener*(wl_keyboard: ptr wl_keyboard; listener: ptr WlKeyboardListener; data: pointer): int {.inline.} =
  cast[ptr wl_proxy](wl_keyboard).add_listener(listener, data)

proc set_user_data*(wl_keyboard: ptr wl_keyboard; user_data: pointer) {.inline.} =
  cast[ptr wl_proxy](wl_keyboard).set_user_data(user_data)
proc get_user_data*(wl_keyboard: ptr wl_keyboard): pointer {.inline.} =
  cast[ptr wl_proxy](wl_keyboard).get_user_data()
proc get_version*(wl_keyboard: ptr wl_keyboard): uint32 {.inline.} =
  cast[ptr wl_proxy](wl_keyboard).get_version()
proc destroy*(wl_keyboard: ptr wl_keyboard) {.inline.} =
  destroy cast[ptr wl_proxy](wl_keyboard)
proc release*(wl_keyboard: ptr wl_keyboard) {.inline.} =
  ## release the keyboard object
  cast[ptr wl_proxy](wl_keyboard).marshal_flags(wl_keyboard_request_release.ord, nil, cast[ptr wl_proxy](wl_keyboard).get_version(), WL_MARSHAL_FLAG_DESTROY)
type WlTouchListener* = object
  down*: proc(
    data: pointer;
    wl_touch: ptr wl_touch;
    serial: uint32;
    time: uint32;
    surface: ptr wl_surface;
    id: int32;
    x: wl_fixed_t;
    y: wl_fixed_t;
  ) {.nimcall.}
  up*: proc(
    data: pointer;
    wl_touch: ptr wl_touch;
    serial: uint32;
    time: uint32;
    id: int32;
  ) {.nimcall.}
  motion*: proc(
    data: pointer;
    wl_touch: ptr wl_touch;
    time: uint32;
    id: int32;
    x: wl_fixed_t;
    y: wl_fixed_t;
  ) {.nimcall.}
  frame*: proc(
    data: pointer;
    wl_touch: ptr wl_touch;
  ) {.nimcall.}
  cancel*: proc(
    data: pointer;
    wl_touch: ptr wl_touch;
  ) {.nimcall.}
  shape*: proc(
    data: pointer;
    wl_touch: ptr wl_touch;
    id: int32;
    major: wl_fixed_t;
    minor: wl_fixed_t;
  ) {.nimcall.}
  orientation*: proc(
    data: pointer;
    wl_touch: ptr wl_touch;
    id: int32;
    orientation: wl_fixed_t;
  ) {.nimcall.}
proc add_listener*(wl_touch: ptr wl_touch; listener: ptr WlTouchListener; data: pointer): int {.inline.} =
  cast[ptr wl_proxy](wl_touch).add_listener(listener, data)

proc set_user_data*(wl_touch: ptr wl_touch; user_data: pointer) {.inline.} =
  cast[ptr wl_proxy](wl_touch).set_user_data(user_data)
proc get_user_data*(wl_touch: ptr wl_touch): pointer {.inline.} =
  cast[ptr wl_proxy](wl_touch).get_user_data()
proc get_version*(wl_touch: ptr wl_touch): uint32 {.inline.} =
  cast[ptr wl_proxy](wl_touch).get_version()
proc destroy*(wl_touch: ptr wl_touch) {.inline.} =
  destroy cast[ptr wl_proxy](wl_touch)
proc release*(wl_touch: ptr wl_touch) {.inline.} =
  ## release the touch object
  cast[ptr wl_proxy](wl_touch).marshal_flags(wl_touch_request_release.ord, nil, cast[ptr wl_proxy](wl_touch).get_version(), WL_MARSHAL_FLAG_DESTROY)
type WlOutputListener* = object
  geometry*: proc(
    data: pointer;
    wl_output: ptr wl_output;
    x: int32;
    y: int32;
    physical_width: int32;
    physical_height: int32;
    subpixel: int32;
    make: cstring;
    model: cstring;
    transform: int32;
  ) {.nimcall.}
  mode*: proc(
    data: pointer;
    wl_output: ptr wl_output;
    flags: uint32;
    width: int32;
    height: int32;
    refresh: int32;
  ) {.nimcall.}
  done*: proc(
    data: pointer;
    wl_output: ptr wl_output;
  ) {.nimcall.}
  scale*: proc(
    data: pointer;
    wl_output: ptr wl_output;
    factor: int32;
  ) {.nimcall.}
  name*: proc(
    data: pointer;
    wl_output: ptr wl_output;
    name: cstring;
  ) {.nimcall.}
  description*: proc(
    data: pointer;
    wl_output: ptr wl_output;
    description: cstring;
  ) {.nimcall.}
proc add_listener*(wl_output: ptr wl_output; listener: ptr WlOutputListener; data: pointer): int {.inline.} =
  cast[ptr wl_proxy](wl_output).add_listener(listener, data)

proc set_user_data*(wl_output: ptr wl_output; user_data: pointer) {.inline.} =
  cast[ptr wl_proxy](wl_output).set_user_data(user_data)
proc get_user_data*(wl_output: ptr wl_output): pointer {.inline.} =
  cast[ptr wl_proxy](wl_output).get_user_data()
proc get_version*(wl_output: ptr wl_output): uint32 {.inline.} =
  cast[ptr wl_proxy](wl_output).get_version()
proc destroy*(wl_output: ptr wl_output) {.inline.} =
  destroy cast[ptr wl_proxy](wl_output)
proc release*(wl_output: ptr wl_output) {.inline.} =
  ## release the output object
  ## 
  ## Using this request a client can tell the server that it is not going to
  ## 	use the output object anymore.
  ## 
  cast[ptr wl_proxy](wl_output).marshal_flags(wl_output_request_release.ord, nil, cast[ptr wl_proxy](wl_output).get_version(), WL_MARSHAL_FLAG_DESTROY)
proc set_user_data*(wl_region: ptr wl_region; user_data: pointer) {.inline.} =
  cast[ptr wl_proxy](wl_region).set_user_data(user_data)
proc get_user_data*(wl_region: ptr wl_region): pointer {.inline.} =
  cast[ptr wl_proxy](wl_region).get_user_data()
proc get_version*(wl_region: ptr wl_region): uint32 {.inline.} =
  cast[ptr wl_proxy](wl_region).get_version()
proc destroy*(wl_region: ptr wl_region) {.inline.} =
  ## destroy region
  ## 
  ## Destroy the region.  This will invalidate the object ID.
  ## 
  cast[ptr wl_proxy](wl_region).marshal_flags(wl_region_request_destroy.ord, nil, cast[ptr wl_proxy](wl_region).get_version(), WL_MARSHAL_FLAG_DESTROY)
proc add*(wl_region: ptr wl_region; x: int32; y: int32; width: int32; height: int32) {.inline.} =
  ## add rectangle to region
  ## 
  ## Add the specified rectangle to the region.
  ## 
  cast[ptr wl_proxy](wl_region).marshal_flags(wl_region_request_add.ord, nil, cast[ptr wl_proxy](wl_region).get_version(), 0, x, y, width, height)
proc subtract*(wl_region: ptr wl_region; x: int32; y: int32; width: int32; height: int32) {.inline.} =
  ## subtract rectangle from region
  ## 
  ## Subtract the specified rectangle from the region.
  ## 
  cast[ptr wl_proxy](wl_region).marshal_flags(wl_region_request_subtract.ord, nil, cast[ptr wl_proxy](wl_region).get_version(), 0, x, y, width, height)
proc set_user_data*(wl_subcompositor: ptr wl_subcompositor; user_data: pointer) {.inline.} =
  cast[ptr wl_proxy](wl_subcompositor).set_user_data(user_data)
proc get_user_data*(wl_subcompositor: ptr wl_subcompositor): pointer {.inline.} =
  cast[ptr wl_proxy](wl_subcompositor).get_user_data()
proc get_version*(wl_subcompositor: ptr wl_subcompositor): uint32 {.inline.} =
  cast[ptr wl_proxy](wl_subcompositor).get_version()
proc destroy*(wl_subcompositor: ptr wl_subcompositor) {.inline.} =
  ## unbind from the subcompositor interface
  ## 
  ## Informs the server that the client will not be using this
  ## 	protocol object anymore. This does not affect any other
  ## 	objects, wl_subsurface objects included.
  ## 
  cast[ptr wl_proxy](wl_subcompositor).marshal_flags(wl_subcompositor_request_destroy.ord, nil, cast[ptr wl_proxy](wl_subcompositor).get_version(), WL_MARSHAL_FLAG_DESTROY)
proc get_subsurface*(wl_subcompositor: ptr wl_subcompositor; surface: ptr wl_surface; parent: ptr wl_surface): ptr wl_subsurface {.inline.} =
  ## give a surface the role sub-surface
  ## 
  ## Create a sub-surface interface for the given surface, and
  ## 	associate it with the given parent surface. This turns a
  ## 	plain wl_surface into a sub-surface.
  ## 
  ## 	The to-be sub-surface must not already have another role, and it
  ## 	must not have an existing wl_subsurface object. Otherwise the
  ## 	bad_surface protocol error is raised.
  ## 
  ## 	Adding sub-surfaces to a parent is a double-buffered operation on the
  ## 	parent (see wl_surface.commit). The effect of adding a sub-surface
  ## 	becomes visible on the next time the state of the parent surface is
  ## 	applied.
  ## 
  ## 	The parent surface must not be one of the child surface's descendants,
  ## 	and the parent must be different from the child surface, otherwise the
  ## 	bad_parent protocol error is raised.
  ## 
  ## 	This request modifies the behaviour of wl_surface.commit request on
  ## 	the sub-surface, see the documentation on wl_subsurface interface.
  ## 
  cast[ptr wl_subsurface](cast[ptr wl_proxy](wl_subcompositor).marshal_flags(wl_subcompositor_request_get_subsurface.ord, addr wl_subsurface_interface, cast[ptr wl_proxy](wl_subcompositor).get_version(), 0, nil, surface, parent))
proc set_user_data*(wl_subsurface: ptr wl_subsurface; user_data: pointer) {.inline.} =
  cast[ptr wl_proxy](wl_subsurface).set_user_data(user_data)
proc get_user_data*(wl_subsurface: ptr wl_subsurface): pointer {.inline.} =
  cast[ptr wl_proxy](wl_subsurface).get_user_data()
proc get_version*(wl_subsurface: ptr wl_subsurface): uint32 {.inline.} =
  cast[ptr wl_proxy](wl_subsurface).get_version()
proc destroy*(wl_subsurface: ptr wl_subsurface) {.inline.} =
  ## remove sub-surface interface
  ## 
  ## The sub-surface interface is removed from the wl_surface object
  ## 	that was turned into a sub-surface with a
  ## 	wl_subcompositor.get_subsurface request. The wl_surface's association
  ## 	to the parent is deleted. The wl_surface is unmapped immediately.
  ## 
  cast[ptr wl_proxy](wl_subsurface).marshal_flags(wl_subsurface_request_destroy.ord, nil, cast[ptr wl_proxy](wl_subsurface).get_version(), WL_MARSHAL_FLAG_DESTROY)
proc set_position*(wl_subsurface: ptr wl_subsurface; x: int32; y: int32) {.inline.} =
  ## reposition the sub-surface
  ## 
  ## This schedules a sub-surface position change.
  ## 	The sub-surface will be moved so that its origin (top left
  ## 	corner pixel) will be at the location x, y of the parent surface
  ## 	coordinate system. The coordinates are not restricted to the parent
  ## 	surface area. Negative values are allowed.
  ## 
  ## 	The scheduled coordinates will take effect whenever the state of the
  ## 	parent surface is applied.
  ## 
  ## 	If more than one set_position request is invoked by the client before
  ## 	the commit of the parent surface, the position of a new request always
  ## 	replaces the scheduled position from any previous request.
  ## 
  ## 	The initial position is 0, 0.
  ## 
  cast[ptr wl_proxy](wl_subsurface).marshal_flags(wl_subsurface_request_set_position.ord, nil, cast[ptr wl_proxy](wl_subsurface).get_version(), 0, x, y)
proc place_above*(wl_subsurface: ptr wl_subsurface; sibling: ptr wl_surface) {.inline.} =
  ## restack the sub-surface
  ## 
  ## This sub-surface is taken from the stack, and put back just
  ## 	above the reference surface, changing the z-order of the sub-surfaces.
  ## 	The reference surface must be one of the sibling surfaces, or the
  ## 	parent surface. Using any other surface, including this sub-surface,
  ## 	will cause a protocol error.
  ## 
  ## 	The z-order is double-buffered. Requests are handled in order and
  ## 	applied immediately to a pending state. The final pending state is
  ## 	copied to the active state the next time the state of the parent
  ## 	surface is applied.
  ## 
  ## 	A new sub-surface is initially added as the top-most in the stack
  ## 	of its siblings and parent.
  ## 
  cast[ptr wl_proxy](wl_subsurface).marshal_flags(wl_subsurface_request_place_above.ord, nil, cast[ptr wl_proxy](wl_subsurface).get_version(), 0, sibling)
proc place_below*(wl_subsurface: ptr wl_subsurface; sibling: ptr wl_surface) {.inline.} =
  ## restack the sub-surface
  ## 
  ## The sub-surface is placed just below the reference surface.
  ## 	See wl_subsurface.place_above.
  ## 
  cast[ptr wl_proxy](wl_subsurface).marshal_flags(wl_subsurface_request_place_below.ord, nil, cast[ptr wl_proxy](wl_subsurface).get_version(), 0, sibling)
proc set_sync*(wl_subsurface: ptr wl_subsurface) {.inline.} =
  ## set sub-surface to synchronized mode
  ## 
  ## Change the commit behaviour of the sub-surface to synchronized
  ## 	mode, also described as the parent dependent mode.
  ## 
  ## 	In synchronized mode, wl_surface.commit on a sub-surface will
  ## 	accumulate the committed state in a cache, but the state will
  ## 	not be applied and hence will not change the compositor output.
  ## 	The cached state is applied to the sub-surface immediately after
  ## 	the parent surface's state is applied. This ensures atomic
  ## 	updates of the parent and all its synchronized sub-surfaces.
  ## 	Applying the cached state will invalidate the cache, so further
  ## 	parent surface commits do not (re-)apply old state.
  ## 
  ## 	See wl_subsurface for the recursive effect of this mode.
  ## 
  cast[ptr wl_proxy](wl_subsurface).marshal_flags(wl_subsurface_request_set_sync.ord, nil, cast[ptr wl_proxy](wl_subsurface).get_version(), 0)
proc set_desync*(wl_subsurface: ptr wl_subsurface) {.inline.} =
  ## set sub-surface to desynchronized mode
  ## 
  ## Change the commit behaviour of the sub-surface to desynchronized
  ## 	mode, also described as independent or freely running mode.
  ## 
  ## 	In desynchronized mode, wl_surface.commit on a sub-surface will
  ## 	apply the pending state directly, without caching, as happens
  ## 	normally with a wl_surface. Calling wl_surface.commit on the
  ## 	parent surface has no effect on the sub-surface's wl_surface
  ## 	state. This mode allows a sub-surface to be updated on its own.
  ## 
  ## 	If cached state exists when wl_surface.commit is called in
  ## 	desynchronized mode, the pending state is added to the cached
  ## 	state, and applied as a whole. This invalidates the cache.
  ## 
  ## 	Note: even if a sub-surface is set to desynchronized, a parent
  ## 	sub-surface may override it to behave as synchronized. For details,
  ## 	see wl_subsurface.
  ## 
  ## 	If a surface's parent surface behaves as desynchronized, then
  ## 	the cached state is applied on set_desync.
  ## 
  cast[ptr wl_proxy](wl_subsurface).marshal_flags(wl_subsurface_request_set_desync.ord, nil, cast[ptr wl_proxy](wl_subsurface).get_version(), 0)
